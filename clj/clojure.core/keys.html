<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="1291807219"><div data-reactid="2"><div class="nses" data-reactid="3"><div data-reactid="4"><div class="tag" data-reactid="5">CLJS</div><a href="../../cljs/basic-lein-cljs.core.html" data-reactid="6">basic-lein-cljs.core</a></div><div data-reactid="7"><a href="../../clj/cljs.analyzer.html" data-reactid="8">cljs.analyzer</a></div><div data-reactid="9"><a href="../../clj/cljs.compiler.html" data-reactid="10">cljs.compiler</a></div><div data-reactid="11"><div class="tag" data-reactid="12">CLJS</div><a href="../../cljs/cljs.core.html" data-reactid="13">cljs.core</a></div><div data-reactid="14"><div class="tag" data-reactid="15">CLJS</div><a href="../../cljs/cljs.core.async.html" data-reactid="16">cljs.core.async</a></div><div data-reactid="17"><div class="tag" data-reactid="18">CLJS</div><a href="../../cljs/cljs.core.async.impl.buffers.html" data-reactid="19">cljs.core.async.impl.buffers</a></div><div data-reactid="20"><div class="tag" data-reactid="21">CLJS</div><a href="../../cljs/cljs.core.async.impl.channels.html" data-reactid="22">cljs.core.async.impl.channels</a></div><div data-reactid="23"><div class="tag" data-reactid="24">CLJS</div><a href="../../cljs/cljs.core.async.impl.dispatch.html" data-reactid="25">cljs.core.async.impl.dispatch</a></div><div data-reactid="26"><div class="tag" data-reactid="27">CLJS</div><a href="../../cljs/cljs.core.async.impl.ioc-helpers.html" data-reactid="28">cljs.core.async.impl.ioc-helpers</a></div><div data-reactid="29"><div class="tag" data-reactid="30">CLJS</div><a href="../../cljs/cljs.core.async.impl.protocols.html" data-reactid="31">cljs.core.async.impl.protocols</a></div><div data-reactid="32"><div class="tag" data-reactid="33">CLJS</div><a href="../../cljs/cljs.core.async.impl.timers.html" data-reactid="34">cljs.core.async.impl.timers</a></div><div data-reactid="35"><a href="../../clj/cljs.env.html" data-reactid="36">cljs.env</a></div><div data-reactid="37"><a href="../../clj/cljs.externs.html" data-reactid="38">cljs.externs</a></div><div data-reactid="39"><div class="tag" data-reactid="40">CLJS</div><a href="../../cljs/cljs.js.html" data-reactid="41">cljs.js</a></div><div data-reactid="42"><a href="../../clj/cljs.js-deps.html" data-reactid="43">cljs.js-deps</a></div><div data-reactid="44"><div class="tag" data-reactid="45">CLJS</div><a href="../../cljs/cljs.pprint.html" data-reactid="46">cljs.pprint</a></div><div data-reactid="47"><div class="tag" data-reactid="48">CLJS</div><a href="../../cljs/cljs.reader.html" data-reactid="49">cljs.reader</a></div><div data-reactid="50"><div class="tag" data-reactid="51">CLJS</div><a href="../../cljs/cljs.repl.html" data-reactid="52">cljs.repl</a></div><div data-reactid="53"><a href="../../clj/cljs.source-map.html" data-reactid="54">cljs.source-map</a></div><div data-reactid="55"><div class="tag" data-reactid="56">CLJS</div><a href="../../cljs/cljs.source-map.html" data-reactid="57">cljs.source-map</a></div><div data-reactid="58"><a href="../../clj/cljs.source-map.base64.html" data-reactid="59">cljs.source-map.base64</a></div><div data-reactid="60"><div class="tag" data-reactid="61">CLJS</div><a href="../../cljs/cljs.source-map.base64.html" data-reactid="62">cljs.source-map.base64</a></div><div data-reactid="63"><a href="../../clj/cljs.source-map.base64-vlq.html" data-reactid="64">cljs.source-map.base64-vlq</a></div><div data-reactid="65"><div class="tag" data-reactid="66">CLJS</div><a href="../../cljs/cljs.source-map.base64-vlq.html" data-reactid="67">cljs.source-map.base64-vlq</a></div><div data-reactid="68"><div class="tag" data-reactid="69">CLJS</div><a href="../../cljs/cljs.spec.alpha.html" data-reactid="70">cljs.spec.alpha</a></div><div data-reactid="71"><div class="tag" data-reactid="72">CLJS</div><a href="../../cljs/cljs.spec.gen.alpha.html" data-reactid="73">cljs.spec.gen.alpha</a></div><div data-reactid="74"><a href="../../clj/cljs.tagged-literals.html" data-reactid="75">cljs.tagged-literals</a></div><div data-reactid="76"><div class="tag" data-reactid="77">CLJS</div><a href="../../cljs/cljs.tools.reader.html" data-reactid="78">cljs.tools.reader</a></div><div data-reactid="79"><div class="tag" data-reactid="80">CLJS</div><a href="../../cljs/cljs.tools.reader.edn.html" data-reactid="81">cljs.tools.reader.edn</a></div><div data-reactid="82"><div class="tag" data-reactid="83">CLJS</div><a href="../../cljs/cljs.tools.reader.impl.commons.html" data-reactid="84">cljs.tools.reader.impl.commons</a></div><div data-reactid="85"><div class="tag" data-reactid="86">CLJS</div><a href="../../cljs/cljs.tools.reader.impl.errors.html" data-reactid="87">cljs.tools.reader.impl.errors</a></div><div data-reactid="88"><div class="tag" data-reactid="89">CLJS</div><a href="../../cljs/cljs.tools.reader.impl.inspect.html" data-reactid="90">cljs.tools.reader.impl.inspect</a></div><div data-reactid="91"><div class="tag" data-reactid="92">CLJS</div><a href="../../cljs/cljs.tools.reader.impl.utils.html" data-reactid="93">cljs.tools.reader.impl.utils</a></div><div data-reactid="94"><div class="tag" data-reactid="95">CLJS</div><a href="../../cljs/cljs.tools.reader.reader-types.html" data-reactid="96">cljs.tools.reader.reader-types</a></div><div data-reactid="97"><a href="../../clj/cljs.util.html" data-reactid="98">cljs.util</a></div><div data-reactid="99"><a href="../../clj/clojure.core.html" data-reactid="100">clojure.core</a></div><div data-reactid="101"><a href="../../clj/clojure.core.async.html" data-reactid="102">clojure.core.async</a></div><div data-reactid="103"><a href="../../clj/clojure.core.async.impl.buffers.html" data-reactid="104">clojure.core.async.impl.buffers</a></div><div data-reactid="105"><a href="../../clj/clojure.core.async.impl.channels.html" data-reactid="106">clojure.core.async.impl.channels</a></div><div data-reactid="107"><a href="../../clj/clojure.core.async.impl.concurrent.html" data-reactid="108">clojure.core.async.impl.concurrent</a></div><div data-reactid="109"><a href="../../clj/clojure.core.async.impl.dispatch.html" data-reactid="110">clojure.core.async.impl.dispatch</a></div><div data-reactid="111"><a href="../../clj/clojure.core.async.impl.exec.threadpool.html" data-reactid="112">clojure.core.async.impl.exec.threadpool</a></div><div data-reactid="113"><a href="../../clj/clojure.core.async.impl.ioc-macros.html" data-reactid="114">clojure.core.async.impl.ioc-macros</a></div><div data-reactid="115"><a href="../../clj/clojure.core.async.impl.mutex.html" data-reactid="116">clojure.core.async.impl.mutex</a></div><div data-reactid="117"><a href="../../clj/clojure.core.async.impl.protocols.html" data-reactid="118">clojure.core.async.impl.protocols</a></div><div data-reactid="119"><a href="../../clj/clojure.core.async.impl.timers.html" data-reactid="120">clojure.core.async.impl.timers</a></div><div data-reactid="121"><a href="../../clj/clojure.core.cache.html" data-reactid="122">clojure.core.cache</a></div><div data-reactid="123"><a href="../../clj/clojure.core.memoize.html" data-reactid="124">clojure.core.memoize</a></div><div data-reactid="125"><a href="../../clj/clojure.core.protocols.html" data-reactid="126">clojure.core.protocols</a></div><div data-reactid="127"><a href="../../clj/clojure.core.server.html" data-reactid="128">clojure.core.server</a></div><div data-reactid="129"><a href="../../clj/clojure.data.json.html" data-reactid="130">clojure.data.json</a></div><div data-reactid="131"><a href="../../clj/clojure.data.priority-map.html" data-reactid="132">clojure.data.priority-map</a></div><div data-reactid="133"><a href="../../clj/clojure.edn.html" data-reactid="134">clojure.edn</a></div><div data-reactid="135"><a href="../../clj/clojure.instant.html" data-reactid="136">clojure.instant</a></div><div data-reactid="137"><a href="../../clj/clojure.java.io.html" data-reactid="138">clojure.java.io</a></div><div data-reactid="139"><a href="../../clj/clojure.main.html" data-reactid="140">clojure.main</a></div><div data-reactid="141"><a href="../../clj/clojure.pprint.html" data-reactid="142">clojure.pprint</a></div><div data-reactid="143"><a href="../../clj/clojure.reflect.html" data-reactid="144">clojure.reflect</a></div><div data-reactid="145"><a href="../../clj/clojure.repl.html" data-reactid="146">clojure.repl</a></div><div data-reactid="147"><a href="../../clj/clojure.set.html" data-reactid="148">clojure.set</a></div><div data-reactid="149"><div class="tag" data-reactid="150">CLJS</div><a href="../../cljs/clojure.set.html" data-reactid="151">clojure.set</a></div><div data-reactid="152"><a href="../../clj/clojure.spec.alpha.html" data-reactid="153">clojure.spec.alpha</a></div><div data-reactid="154"><a href="../../clj/clojure.spec.gen.alpha.html" data-reactid="155">clojure.spec.gen.alpha</a></div><div data-reactid="156"><a href="../../clj/clojure.string.html" data-reactid="157">clojure.string</a></div><div data-reactid="158"><div class="tag" data-reactid="159">CLJS</div><a href="../../cljs/clojure.string.html" data-reactid="160">clojure.string</a></div><div data-reactid="161"><a href="../../clj/clojure.tools.analyzer.html" data-reactid="162">clojure.tools.analyzer</a></div><div data-reactid="163"><a href="../../clj/clojure.tools.analyzer.ast.html" data-reactid="164">clojure.tools.analyzer.ast</a></div><div data-reactid="165"><a href="../../clj/clojure.tools.analyzer.env.html" data-reactid="166">clojure.tools.analyzer.env</a></div><div data-reactid="167"><a href="../../clj/clojure.tools.analyzer.jvm.html" data-reactid="168">clojure.tools.analyzer.jvm</a></div><div data-reactid="169"><a href="../../clj/clojure.tools.analyzer.jvm.utils.html" data-reactid="170">clojure.tools.analyzer.jvm.utils</a></div><div data-reactid="171"><a href="../../clj/clojure.tools.analyzer.passes.html" data-reactid="172">clojure.tools.analyzer.passes</a></div><div data-reactid="173"><a href="../../clj/clojure.tools.analyzer.passes.add-binding-atom.html" data-reactid="174">clojure.tools.analyzer.passes.add-binding-atom</a></div><div data-reactid="175"><a href="../../clj/clojure.tools.analyzer.passes.cleanup.html" data-reactid="176">clojure.tools.analyzer.passes.cleanup</a></div><div data-reactid="177"><a href="../../clj/clojure.tools.analyzer.passes.constant-lifter.html" data-reactid="178">clojure.tools.analyzer.passes.constant-lifter</a></div><div data-reactid="179"><a href="../../clj/clojure.tools.analyzer.passes.elide-meta.html" data-reactid="180">clojure.tools.analyzer.passes.elide-meta</a></div><div data-reactid="181"><a href="../../clj/clojure.tools.analyzer.passes.emit-form.html" data-reactid="182">clojure.tools.analyzer.passes.emit-form</a></div><div data-reactid="183"><a href="../../clj/clojure.tools.analyzer.passes.jvm.analyze-host-expr.html" data-reactid="184">clojure.tools.analyzer.passes.jvm.analyze-host-expr</a></div><div data-reactid="185"><a href="../../clj/clojure.tools.analyzer.passes.jvm.annotate-host-info.html" data-reactid="186">clojure.tools.analyzer.passes.jvm.annotate-host-info</a></div><div data-reactid="187"><a href="../../clj/clojure.tools.analyzer.passes.jvm.annotate-loops.html" data-reactid="188">clojure.tools.analyzer.passes.jvm.annotate-loops</a></div><div data-reactid="189"><a href="../../clj/clojure.tools.analyzer.passes.jvm.annotate-tag.html" data-reactid="190">clojure.tools.analyzer.passes.jvm.annotate-tag</a></div><div data-reactid="191"><a href="../../clj/clojure.tools.analyzer.passes.jvm.box.html" data-reactid="192">clojure.tools.analyzer.passes.jvm.box</a></div><div data-reactid="193"><a href="../../clj/clojure.tools.analyzer.passes.jvm.classify-invoke.html" data-reactid="194">clojure.tools.analyzer.passes.jvm.classify-invoke</a></div><div data-reactid="195"><a href="../../clj/clojure.tools.analyzer.passes.jvm.constant-lifter.html" data-reactid="196">clojure.tools.analyzer.passes.jvm.constant-lifter</a></div><div data-reactid="197"><a href="../../clj/clojure.tools.analyzer.passes.jvm.emit-form.html" data-reactid="198">clojure.tools.analyzer.passes.jvm.emit-form</a></div><div data-reactid="199"><a href="../../clj/clojure.tools.analyzer.passes.jvm.fix-case-test.html" data-reactid="200">clojure.tools.analyzer.passes.jvm.fix-case-test</a></div><div data-reactid="201"><a href="../../clj/clojure.tools.analyzer.passes.jvm.infer-tag.html" data-reactid="202">clojure.tools.analyzer.passes.jvm.infer-tag</a></div><div data-reactid="203"><a href="../../clj/clojure.tools.analyzer.passes.jvm.validate.html" data-reactid="204">clojure.tools.analyzer.passes.jvm.validate</a></div><div data-reactid="205"><a href="../../clj/clojure.tools.analyzer.passes.jvm.validate-loop-locals.html" data-reactid="206">clojure.tools.analyzer.passes.jvm.validate-loop-locals</a></div><div data-reactid="207"><a href="../../clj/clojure.tools.analyzer.passes.jvm.validate-recur.html" data-reactid="208">clojure.tools.analyzer.passes.jvm.validate-recur</a></div><div data-reactid="209"><a href="../../clj/clojure.tools.analyzer.passes.jvm.warn-on-reflection.html" data-reactid="210">clojure.tools.analyzer.passes.jvm.warn-on-reflection</a></div><div data-reactid="211"><a href="../../clj/clojure.tools.analyzer.passes.source-info.html" data-reactid="212">clojure.tools.analyzer.passes.source-info</a></div><div data-reactid="213"><a href="../../clj/clojure.tools.analyzer.passes.trim.html" data-reactid="214">clojure.tools.analyzer.passes.trim</a></div><div data-reactid="215"><a href="../../clj/clojure.tools.analyzer.passes.uniquify.html" data-reactid="216">clojure.tools.analyzer.passes.uniquify</a></div><div data-reactid="217"><a href="../../clj/clojure.tools.analyzer.passes.warn-earmuff.html" data-reactid="218">clojure.tools.analyzer.passes.warn-earmuff</a></div><div data-reactid="219"><a href="../../clj/clojure.tools.analyzer.utils.html" data-reactid="220">clojure.tools.analyzer.utils</a></div><div data-reactid="221"><a href="../../clj/clojure.tools.cli.html" data-reactid="222">clojure.tools.cli</a></div><div data-reactid="223"><a href="../../clj/clojure.tools.namespace.dependency.html" data-reactid="224">clojure.tools.namespace.dependency</a></div><div data-reactid="225"><a href="../../clj/clojure.tools.namespace.file.html" data-reactid="226">clojure.tools.namespace.file</a></div><div data-reactid="227"><a href="../../clj/clojure.tools.namespace.find.html" data-reactid="228">clojure.tools.namespace.find</a></div><div data-reactid="229"><a href="../../clj/clojure.tools.namespace.parse.html" data-reactid="230">clojure.tools.namespace.parse</a></div><div data-reactid="231"><a href="../../clj/clojure.tools.namespace.track.html" data-reactid="232">clojure.tools.namespace.track</a></div><div data-reactid="233"><a href="../../clj/clojure.tools.reader.html" data-reactid="234">clojure.tools.reader</a></div><div data-reactid="235"><a href="../../clj/clojure.tools.reader.default-data-readers.html" data-reactid="236">clojure.tools.reader.default-data-readers</a></div><div data-reactid="237"><a href="../../clj/clojure.tools.reader.impl.commons.html" data-reactid="238">clojure.tools.reader.impl.commons</a></div><div data-reactid="239"><a href="../../clj/clojure.tools.reader.impl.errors.html" data-reactid="240">clojure.tools.reader.impl.errors</a></div><div data-reactid="241"><a href="../../clj/clojure.tools.reader.impl.inspect.html" data-reactid="242">clojure.tools.reader.impl.inspect</a></div><div data-reactid="243"><a href="../../clj/clojure.tools.reader.impl.utils.html" data-reactid="244">clojure.tools.reader.impl.utils</a></div><div data-reactid="245"><a href="../../clj/clojure.tools.reader.reader-types.html" data-reactid="246">clojure.tools.reader.reader-types</a></div><div data-reactid="247"><a href="../../clj/clojure.walk.html" data-reactid="248">clojure.walk</a></div><div data-reactid="249"><div class="tag" data-reactid="250">CLJS</div><a href="../../cljs/clojure.walk.html" data-reactid="251">clojure.walk</a></div><div data-reactid="252"><a href="../../clj/dynadoc.aliases.html" data-reactid="253">dynadoc.aliases</a></div><div data-reactid="254"><a href="../../clj/dynadoc.common.html" data-reactid="255">dynadoc.common</a></div><div data-reactid="256"><a href="../../clj/dynadoc.core.html" data-reactid="257">dynadoc.core</a></div><div data-reactid="258"><div class="tag" data-reactid="259">CLJS</div><a href="../../cljs/dynadoc.core.html" data-reactid="260">dynadoc.core</a></div><div data-reactid="261"><a href="../../clj/dynadoc.example.html" data-reactid="262">dynadoc.example</a></div><div data-reactid="263"><div class="tag" data-reactid="264">CLJS</div><a href="../../cljs/dynadoc.state.html" data-reactid="265">dynadoc.state</a></div><div data-reactid="266"><a href="../../clj/dynadoc.static.html" data-reactid="267">dynadoc.static</a></div><div data-reactid="268"><a href="../../clj/dynadoc.utils.html" data-reactid="269">dynadoc.utils</a></div><div data-reactid="270"><a href="../../clj/dynadoc.watch.html" data-reactid="271">dynadoc.watch</a></div><div data-reactid="272"><a href="../../clj/eval-soup.clojail.html" data-reactid="273">eval-soup.clojail</a></div><div data-reactid="274"><a href="../../clj/eval-soup.core.html" data-reactid="275">eval-soup.core</a></div><div data-reactid="276"><div class="tag" data-reactid="277">CLJS</div><a href="../../cljs/eval-soup.core.html" data-reactid="278">eval-soup.core</a></div><div data-reactid="279"><div class="tag" data-reactid="280">CLJS</div><a href="../../cljs/figwheel.client.html" data-reactid="281">figwheel.client</a></div><div data-reactid="282"><div class="tag" data-reactid="283">CLJS</div><a href="../../cljs/figwheel.client.file-reloading.html" data-reactid="284">figwheel.client.file-reloading</a></div><div data-reactid="285"><div class="tag" data-reactid="286">CLJS</div><a href="../../cljs/figwheel.client.heads-up.html" data-reactid="287">figwheel.client.heads-up</a></div><div data-reactid="288"><div class="tag" data-reactid="289">CLJS</div><a href="../../cljs/figwheel.client.socket.html" data-reactid="290">figwheel.client.socket</a></div><div data-reactid="291"><div class="tag" data-reactid="292">CLJS</div><a href="../../cljs/figwheel.client.utils.html" data-reactid="293">figwheel.client.utils</a></div><div data-reactid="294"><a href="../../clj/hawk.core.html" data-reactid="295">hawk.core</a></div><div data-reactid="296"><a href="../../clj/hawk.watcher.html" data-reactid="297">hawk.watcher</a></div><div data-reactid="298"><a href="../../clj/html-soup.core.html" data-reactid="299">html-soup.core</a></div><div data-reactid="300"><a href="../../clj/ns-tracker.core.html" data-reactid="301">ns-tracker.core</a></div><div data-reactid="302"><a href="../../clj/ns-tracker.dependency.html" data-reactid="303">ns-tracker.dependency</a></div><div data-reactid="304"><a href="../../clj/ns-tracker.nsdeps.html" data-reactid="305">ns-tracker.nsdeps</a></div><div data-reactid="306"><a href="../../clj/ns-tracker.parse.html" data-reactid="307">ns-tracker.parse</a></div><div data-reactid="308"><div class="tag" data-reactid="309">CLJS</div><a href="../../cljs/oakcljs.tools.reader.html" data-reactid="310">oakcljs.tools.reader</a></div><div data-reactid="311"><div class="tag" data-reactid="312">CLJS</div><a href="../../cljs/oakcljs.tools.reader.impl.commons.html" data-reactid="313">oakcljs.tools.reader.impl.commons</a></div><div data-reactid="314"><div class="tag" data-reactid="315">CLJS</div><a href="../../cljs/oakcljs.tools.reader.impl.errors.html" data-reactid="316">oakcljs.tools.reader.impl.errors</a></div><div data-reactid="317"><div class="tag" data-reactid="318">CLJS</div><a href="../../cljs/oakcljs.tools.reader.impl.inspect.html" data-reactid="319">oakcljs.tools.reader.impl.inspect</a></div><div data-reactid="320"><div class="tag" data-reactid="321">CLJS</div><a href="../../cljs/oakcljs.tools.reader.impl.utils.html" data-reactid="322">oakcljs.tools.reader.impl.utils</a></div><div data-reactid="323"><div class="tag" data-reactid="324">CLJS</div><a href="../../cljs/oakcljs.tools.reader.reader-types.html" data-reactid="325">oakcljs.tools.reader.reader-types</a></div><div data-reactid="326"><a href="../../clj/oakclojure.tools.reader.html" data-reactid="327">oakclojure.tools.reader</a></div><div data-reactid="328"><a href="../../clj/oakclojure.tools.reader.default-data-readers.html" data-reactid="329">oakclojure.tools.reader.default-data-readers</a></div><div data-reactid="330"><a href="../../clj/oakclojure.tools.reader.impl.commons.html" data-reactid="331">oakclojure.tools.reader.impl.commons</a></div><div data-reactid="332"><a href="../../clj/oakclojure.tools.reader.impl.errors.html" data-reactid="333">oakclojure.tools.reader.impl.errors</a></div><div data-reactid="334"><a href="../../clj/oakclojure.tools.reader.impl.inspect.html" data-reactid="335">oakclojure.tools.reader.impl.inspect</a></div><div data-reactid="336"><a href="../../clj/oakclojure.tools.reader.impl.utils.html" data-reactid="337">oakclojure.tools.reader.impl.utils</a></div><div data-reactid="338"><a href="../../clj/oakclojure.tools.reader.reader-types.html" data-reactid="339">oakclojure.tools.reader.reader-types</a></div><div data-reactid="340"><a href="../../clj/org.httpkit.server.html" data-reactid="341">org.httpkit.server</a></div><div data-reactid="342"><div class="tag" data-reactid="343">CLJS</div><a href="../../cljs/paren-soup.console.html" data-reactid="344">paren-soup.console</a></div><div data-reactid="345"><div class="tag" data-reactid="346">CLJS</div><a href="../../cljs/paren-soup.core.html" data-reactid="347">paren-soup.core</a></div><div data-reactid="348"><div class="tag" data-reactid="349">CLJS</div><a href="../../cljs/paren-soup.dom.html" data-reactid="350">paren-soup.dom</a></div><div data-reactid="351"><div class="tag" data-reactid="352">CLJS</div><a href="../../cljs/paren-soup.instarepl.html" data-reactid="353">paren-soup.instarepl</a></div><div data-reactid="354"><div class="tag" data-reactid="355">CLJS</div><a href="../../cljs/reagent.core.html" data-reactid="356">reagent.core</a></div><div data-reactid="357"><div class="tag" data-reactid="358">CLJS</div><a href="../../cljs/reagent.debug.html" data-reactid="359">reagent.debug</a></div><div data-reactid="360"><div class="tag" data-reactid="361">CLJS</div><a href="../../cljs/reagent.dom.html" data-reactid="362">reagent.dom</a></div><div data-reactid="363"><div class="tag" data-reactid="364">CLJS</div><a href="../../cljs/reagent.impl.batching.html" data-reactid="365">reagent.impl.batching</a></div><div data-reactid="366"><div class="tag" data-reactid="367">CLJS</div><a href="../../cljs/reagent.impl.component.html" data-reactid="368">reagent.impl.component</a></div><div data-reactid="369"><div class="tag" data-reactid="370">CLJS</div><a href="../../cljs/reagent.impl.template.html" data-reactid="371">reagent.impl.template</a></div><div data-reactid="372"><div class="tag" data-reactid="373">CLJS</div><a href="../../cljs/reagent.impl.util.html" data-reactid="374">reagent.impl.util</a></div><div data-reactid="375"><div class="tag" data-reactid="376">CLJS</div><a href="../../cljs/reagent.ratom.html" data-reactid="377">reagent.ratom</a></div><div data-reactid="378"><a href="../../clj/ring.middleware.content-type.html" data-reactid="379">ring.middleware.content-type</a></div><div data-reactid="380"><a href="../../clj/ring.middleware.file.html" data-reactid="381">ring.middleware.file</a></div><div data-reactid="382"><a href="../../clj/ring.middleware.head.html" data-reactid="383">ring.middleware.head</a></div><div data-reactid="384"><a href="../../clj/ring.middleware.keyword-params.html" data-reactid="385">ring.middleware.keyword-params</a></div><div data-reactid="386"><a href="../../clj/ring.middleware.params.html" data-reactid="387">ring.middleware.params</a></div><div data-reactid="388"><a href="../../clj/ring.middleware.reload.html" data-reactid="389">ring.middleware.reload</a></div><div data-reactid="390"><a href="../../clj/ring.middleware.resource.html" data-reactid="391">ring.middleware.resource</a></div><div data-reactid="392"><a href="../../clj/ring.util.codec.html" data-reactid="393">ring.util.codec</a></div><div data-reactid="394"><a href="../../clj/ring.util.io.html" data-reactid="395">ring.util.io</a></div><div data-reactid="396"><a href="../../clj/ring.util.mime-type.html" data-reactid="397">ring.util.mime-type</a></div><div data-reactid="398"><a href="../../clj/ring.util.parsing.html" data-reactid="399">ring.util.parsing</a></div><div data-reactid="400"><a href="../../clj/ring.util.request.html" data-reactid="401">ring.util.request</a></div><div data-reactid="402"><a href="../../clj/ring.util.response.html" data-reactid="403">ring.util.response</a></div><div data-reactid="404"><a href="../../clj/ring.util.time.html" data-reactid="405">ring.util.time</a></div><div data-reactid="406"><a href="../../clj/rum.core.html" data-reactid="407">rum.core</a></div><div data-reactid="408"><div class="tag" data-reactid="409">CLJS</div><a href="../../cljs/rum.core.html" data-reactid="410">rum.core</a></div><div data-reactid="411"><a href="../../clj/rum.cursor.html" data-reactid="412">rum.cursor</a></div><div data-reactid="413"><a href="../../clj/rum.derived-atom.html" data-reactid="414">rum.derived-atom</a></div><div data-reactid="415"><a href="../../clj/rum.server-render.html" data-reactid="416">rum.server-render</a></div><div data-reactid="417"><a href="../../clj/rum.util.html" data-reactid="418">rum.util</a></div><div data-reactid="419"><a href="../../clj/sablono.compiler.html" data-reactid="420">sablono.compiler</a></div><div data-reactid="421"><div class="tag" data-reactid="422">CLJS</div><a href="../../cljs/sablono.core.html" data-reactid="423">sablono.core</a></div><div data-reactid="424"><a href="../../clj/sablono.normalize.html" data-reactid="425">sablono.normalize</a></div><div data-reactid="426"><a href="../../clj/sablono.util.html" data-reactid="427">sablono.util</a></div><div data-reactid="428"><a href="../../clj/tag-soup.core.html" data-reactid="429">tag-soup.core</a></div></div></div><div style="left:300px;" class="vars" data-reactid="430"><!-- react-empty: 431 --><div class="var-info" data-reactid="432"><div data-reactid="433"><h2 data-reactid="434">(keys map)</h2></div><div class="section doc" data-reactid="435">Returns a sequence of the map&#x27;s keys, in the same order as (seq map).</div><div class="section" data-reactid="436"><h2 data-reactid="437">Source</h2><div class="paren-soup" data-reactid="438"><div class="content" data-reactid="439"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>defn</span> <span class='symbol'>keys</span>
  <span class='string'>&quot;Returns a sequence of the map&apos;s keys, in the same order as (seq map).&quot;</span>
  <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:added</span> <span class='string'>&quot;1.0&quot;</span>
   <span class='keyword'>:static</span> <span class='boolean'>true</span><span class='delimiter'>}</span></span>
  <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>map</span><span class='delimiter'>]</span></span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>.</span> <span class='symbol'>clojure.lang.RT</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>keys</span> <span class='symbol'>map</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span></div></div></div></div><div class="footer" data-reactid="440"><!-- react-text: 441 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="442">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:ns-meta {:doc "Fundamental library of the Clojure language", :author "Rich Hickey"}, :var-sym keys, :type :clj, :nses ({:var-syms [clicks get-lib-version], :type :cljs, :sym basic-lein-cljs.core} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [sort-by ITransientAssociative chunk-first m3-hash-int pr-str* tree-seq unchecked-remainder-int seq reduce contains? every? keep-indexed subs IFind MODULE_URIS take-last bit-set string-hash-cache-count qualified-keyword? -with-meta unchecked-subtract-int -iterator *print-namespace-maps* first native-satisfies? seq? -sorted-seq-from inst-ms iterate -empty ILookup -chunked-rest fn? -assoc keyword-identical? *print-err-fn* dissoc atom bit-shift-right *clojurescript-version* -first peek IKVReduce aget -write iter last namespace -conj = ITransientMap take vector? boolean IChunk bit-shift-left any? aclone vreset! chunk dec APersistentVector map < rest -drop-first boolean? -clone char? -reduce -count swap-vals! keep char mapcat unchecked-long m3-seed some? unchecked-negate symbol-identical? *command-line-args* reverse inst? bit-count sort unchecked-inc-int -compare map-indexed comp array-chunk bit-shift-right-zero-fill -as-transient simple-symbol? IIndexed disj IPrintWithWriter IVector IIterable cons floats pos? fnil merge-with nthrest *warn-on-infer* -find sequential? m3-mix-H1 prim-seq *print-level* shuffle hash-keyword find alength bit-xor unsigned-bit-shift-right neg? js-invoke m3-mix-K1 unchecked-float undefined? IMeta reduced? disj! -lookup float? ICloneable booleans int-array set? iterable? -pr-writer take-while vary-meta INext is_proto_ ICounted IMapEntry <= MODULE_INFOS conj! -pop repeatedly reset-vals! IStack -remove-watch IVolatile remove * min -persistent! -nth pop! chunk-append *unchecked-arrays* IReversible reversible? -realized? -add-watch -deref-with-timeout conj -sorted-seq transduce -swap! *print-length* js-delete truth_ compare-and-set! array-seq interleave map? m3-C1 get identity into long double volatile? -key nfirst meta -kv-reduce IHash bit-and-not var? -comparator unchecked-add-int hash-ordered-coll IEquiv cycle -deref empty? short -chunked-first filterv hash quot unchecked-double ranged-iterator ITransientVector longs not= set-print-err-fn! string? es6-iterator m3-C2 *print-newline* unchecked-multiply-int chunk-rest double? vec *print-meta* -notify-watches int second IEditableCollection hash-combine > -name int? associative? unchecked-int js-keys inst-ms* keyword? array-iter -rseq unchecked-multiply even? es6-iterator-seq unchecked-dec Inst double-array spread rseq IReset IEmptyableCollection *print-fn-bodies* float IRecord concat IDerefWithTimeout symbol to-array-2d mod ISet pop IPending -entry-key dissoc! indexed? - -equiv assoc! reduce-kv reset! Fn ffirst counted? assoc-in bit-test ISwap zero? simple-keyword? *main-cli-fn* -assoc-n unchecked-dec-int persistent! set-print-fn! nnext not-every? rem ifind? some INamed IReduce neg-int? drop js-obj ITransientCollection nth sorted? nil? split-at not-native bit-and bounded-count update list* update-in ensure-reduced instance? mix-collection-hash unchecked-add transformer-iterator not -vreset! with-meta unreduced record? type identical? -namespace unchecked-divide-int *out* hash-string set-validator! ident? -meta swap! -chunked-next unchecked-subtract IMap cloneable? qualified-ident? hash-string* true? array -peek ISeq empty volatile! / bit-or m3-fmix vector >= drop-last object? not-empty partition DEMUNGE_PATTERN IAssociative bit-flip long-array ISeqable js-mod integer? mapv infinite? ISequential equiv-map object-array seq-iter IChunkedSeq -next flatten -dissoc doubles -contains-key? ifn? IAtom nat-int? IWatchable subvec -pop! partial chunked-seq? replicate reduced ITransientSet unchecked-byte every-pred missing-protocol load-file distinct? pos-int? unchecked-short odd? reduceable? string-hash-cache inc type->str bit-clear filter -assoc-n! IWithMeta list + aset int-rotate-left keyword *ns* *assert* ICollection chars next ASeq IFn -reset! -rest nil-iter false? *print-readably* ints some-fn *flush-on-newline* to-array list? array? simple-ident? clone bit-not byte max IComparable == count -disjoin! *loaded-libs* apply add-to-string-hash-cache IChunkedNext interpose deref assoc transient -disjoin chunk-cons drop-while IWriter *print-fn* compare complement -assoc! *print-dup* string-iter IDeref sequence constantly chunked-seq ISorted make-array shorts *unchecked-if* enable-console-print! -flush completing unchecked-negate-int hash-unordered-coll repeat unchecked-inc nthnext get-validator number? -conj! chunk-next not-any? into-array -hash qualified-symbol? -dissoc! chunk-buffer seqable? symbol? m3-hash-unencoded-chars unchecked-char system-time -invoke coll? get-in fnext IList -val bytes -seq], :type :cljs, :sym cljs.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into pipeline sub map> pipe unmix filter< sub* remove< untap* toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! map< do-alts pipeline-async Mix toggle* mult mapcat< ioc-alts! unblocking-buffer? put! take!], :type :cljs, :sym cljs.core.async} {:var-syms [acopy ring-buffer fixed-buffer dropping-buffer sliding-buffer promise-buffer], :type :cljs, :sym cljs.core.async.impl.buffers} {:var-syms [box put-active? MAX_DIRTY abort MMC chan], :type :cljs, :sym cljs.core.async.impl.channels} {:var-syms [tasks running? queued? TASK_BATCH_SIZE process-messages queue-dispatcher run queue-delay], :type :cljs, :sym cljs.core.async.impl.dispatch} {:var-syms [EXCEPTION-FRAMES process-exception STATE-IDX aset-object add-exception-frame run-state-machine-wrapped FN-IDX aget-object return-chan BINDINGS-IDX CURRENT-EXCEPTION run-state-machine finished? USER-START-IDX put! take! VALUE-IDX], :type :cljs, :sym cljs.core.async.impl.ioc-helpers} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :cljs, :sym cljs.core.async.impl.protocols} {:var-syms [MAX_LEVEL P random-level skip-list-node least-greater-node skip-list timeouts-map TIMEOUT_RESOLUTION_MS timeout], :type :cljs, :sym cljs.core.async.impl.timers} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [*load-fn* eval compile-str ns->relpath *loaded* require file->ns eval-str js-eval load-source-map! analyze-str *eval-fn*], :type :cljs, :sym cljs.js} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [pprint get-pretty-writer *print-suppress-namespaces* char-code *print-pretty* *print-pprint-dispatch* pprint-newline float? pprint-tab pprint-set print-table set-pprint-dispatch fresh-line pprint-indent *print-radix* IPrettyFlush cl-format *print-miser-width* write -ppflush *print-right-margin* write-out *print-base*], :type :cljs, :sym cljs.pprint} {:var-syms [*default-data-reader-fn* read *tag-table* parse-and-validate-timestamp register-tag-parser! register-default-tag-parser! deregister-default-tag-parser! read-string deregister-tag-parser! parse-timestamp], :type :cljs, :sym cljs.reader} {:var-syms [print-doc], :type :cljs, :sym cljs.repl} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [update-result invert-reverse-map decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources seg-combine], :type :cljs, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [chars64 char->int int->char encode decode], :type :cljs, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [vlq-base-shift vlq-base vlq-base-mask vlq-continuation-bit to-vlq-signed from-vlq-signed encode-val encode decode], :type :cljs, :sym cljs.source-map.base64-vlq} {:var-syms [form nilable-impl *recursion-limit* *coll-error-limit* explain-printer Specize alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* MAX_INT check-asserts assert* inst-in-range? and-spec-impl describe* map-spec-impl explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen nonconforming unform* abbrev regex? int-in-range? spec? registry rep+impl exercise explain-data tuple-impl multi-spec-impl conform gen* fspec-impl *coll-check-limit* get-spec every-impl spec-impl invalid? amp-impl cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl describe explain-out specize* maybe-impl explain*], :type :cljs, :sym cljs.spec.alpha} {:var-syms [quick-check for-all* delay-impl cat gen-for-pred], :type :cljs, :sym cljs.spec.gen.alpha} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [bool? *suppress-read* *default-data-reader-fn* read default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex sb read-string map-func], :type :cljs, :sym cljs.tools.reader} {:var-syms [read read-string], :type :cljs, :sym cljs.tools.reader.edn} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern matches? throwing-reader ratio-pattern], :type :cljs, :sym cljs.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-dup-keys throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :cljs, :sym cljs.tools.reader.impl.errors} {:var-syms [inspect], :type :cljs, :sym cljs.tools.reader.impl.inspect} {:var-syms [reader-conditional whitespace? last-id char numeric? second' desugar-meta next-id ex-info? reader-conditional? newline? namespace-keys ws-rx], :type :cljs, :sym cljs.tools.reader.impl.utils} {:var-syms [indexing-push-back-reader log-source* merge-meta Reader source-logging-push-back-reader unread peek-char IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line string-push-back-reader line-start? source-logging-reader? IndexingReader node-readable-push-back-reader get-line-number], :type :cljs, :sym cljs.tools.reader.reader-types} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :cljs, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :cljs, :sym clojure.string} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [cli parse-opts summarize get-default-options format-lines make-summary-part], :type :clj, :sym clojure.tools.cli} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [add-files remove-files read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile find-namespaces-in-dir find-ns-decls-in-jarfile read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? deps-from-ns-decl read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated clojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [walk postwalk prewalk keywordize-keys stringify-keys prewalk-replace postwalk-replace], :type :cljs, :sym clojure.walk} {:var-syms [chan <!! put!], :type :clj, :sym dynadoc.aliases} {:var-syms [var-sym->url spec->html example->html init-editor expandable-section ns-sym->url sidebar var->html page-url export-form export source->html app init-example-editor], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler page-state get-clj-vars dev-start get-cljs-nses-and-vars-dynamically -main get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [add-focus clj-compiler-fn version form->serializable init-editor add-callback *state cljs-compiler-fn transform init add-card prod check-version api-url with-focus->binding init-example-editor init-watcher!], :type :cljs, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [*state], :type :cljs, :sym dynadoc.state} {:var-syms [read-cljs-file visible? get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable parse-uri flatten-vals cli-options process-example], :type :clj, :sym dynadoc.utils} {:var-syms [*cljs-info watch-request *channel->uri init-watcher!], :type :clj, :sym dynadoc.watch} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [chan? code->results], :type :cljs, :sym eval-soup.core} {:var-syms [focus-msgs handle-deprecated-jsload-callback default-on-compile-fail reload-file?* add-json-message-watch enforce-figwheel-version-plugin repl-result-pr-str error-msg-format compile-fail-warning-plugin console-intro-message add-message-watch auto-jump-to-error repl-out-print-fn add-plugins set-repl-pprint bad-compile-helper-app figwheel-repl-print file-reloader-plugin repl-pprint set-autoload get-ua-product heads-up-plugin-msg-handler watch-and-reload-with-opts compile-fail-state? format-messages css-reloader-plugin _figwheel-version_ console-out-print watch-and-reload start repl-plugin repl-err-print-fn heads-up-plugin file-line-column css-loaded-state? block-reload-file-state? fill-url-template rewarning-state? js-stringify toggle-autoload get-essential-messages default-on-jsload base-plugins default-on-cssload console-err-print enforce-project-plugin warning-append-state? config-defaults compile-refail-state? autoload? fetch-data-from-env reload-file-state? default-on-compile-warning warning-state? default-before-load enable-repl-print! truncate-stack-trace], :type :cljs, :sym figwheel.client} {:var-syms [figwheel-require create-node-script-import-fn matches-file? build-topo-sort unprovide! get-all-dependents addDependency figwheel-no-load? write-script-tag-import namespace-file-map? path->name get-figwheel-always name-to-parent! current-links on-cssload-custom-event blocking-load reload-css-files add-cache-buster ns->dependents on-load-callbacks reload-chan get-correct-link expand-files setup-ns->dependents! before-jsload-custom-event setup-path->name! js-reload get-requires add-link-to-document truncate-url clone-link name->path reloader-loop require-with-callback distinctify bootstrap-goog-base reload-css-deferred-chain reload-css-files* in-upper-level? get-all-dependencies queued-file-reload gloader patch-goog-base reload-file? on-jsload-custom-event dependencies-loaded reload-css-file provided? immutable-ns? figwheel-meta-pragmas sort-files resolve-ns reload-js-file eval-body load-all-js-files reload-file* path-to-name! create-link reload-js-files worker-import-script reload-file dependency-data], :type :cljs, :sym figwheel.client.file-reloading} {:var-syms [get-content auto-notify-source-file-line display-exception set-style! heading clear escape inline-error-line pad-line-number get-dataset flatten-exception display-heads-up format-line format-inline-error-line pad-line-numbers heads-up-onclick-handler set-content! warning-data->display-data display-warning file-selector-div display-loaded-start ensure-container node exception->display-data cljs-logo-svg close-bad-compile-screen format-inline-error format-warning-message display-system-warning close-link ancestor-nodes flash-loaded], :type :cljs, :sym figwheel.client.heads-up} {:var-syms [get-websocket-imp message-history-atom socket-atom send! close! handle-incoming-message open], :type :cljs, :sym figwheel.client.socket} {:var-syms [mapConcatD base-url-path log create-custom-event worker-env? host-env? persistent-config-set! html-or-react-native-env? node-env? html-env? liftContD *print-debug* pprint-to-string local-persistent-config dispatch-custom-event debug-prn persistent-config-get react-native-env? eval-helper], :type :cljs, :sym figwheel.client.utils} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [bool? *suppress-read* *default-data-reader-fn* read default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex sb read-string map-func], :type :cljs, :sym oakcljs.tools.reader} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern matches? throwing-reader ratio-pattern], :type :cljs, :sym oakcljs.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-dup-keys throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :cljs, :sym oakcljs.tools.reader.impl.errors} {:var-syms [inspect], :type :cljs, :sym oakcljs.tools.reader.impl.inspect} {:var-syms [reader-conditional whitespace? last-id char numeric? second' desugar-meta next-id ex-info? reader-conditional? newline? namespace-keys ws-rx], :type :cljs, :sym oakcljs.tools.reader.impl.utils} {:var-syms [indexing-push-back-reader log-source* merge-meta Reader source-logging-push-back-reader unread peek-char IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line string-push-back-reader line-start? source-logging-reader? IndexingReader node-readable-push-back-reader get-line-number], :type :cljs, :sym oakcljs.tools.reader.reader-types} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated oakclojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [create-console-history get-console-start update-console-start! update-console-history! get-previous-line get-next-line up! down!], :type :cljs, :sym paren-soup.console} {:var-syms [can-undo show-error-message! focused-text selected-text can-redo? can-redo rainbow-delimiters up! refresh! undo! key-name? eval channel? create-editor key-code redo! post-refresh-content! tab! transient-map? refresh-content-element! elem? enter! append-text! line-numbers update-highlight! init can-undo? refresh-content! redo debounce-function refresh-instarepl! edit-and-refresh! rainbow-count update-cursor-position! init-state eval! add-parinfer-after-console-start refresh-numbers! refresh-after-cut-paste! refresh-after-key-event! add-newline update-edit-history! refresh-console-content! append-text prevent-default? initialize! add-parinfer undo obj? down! add-event-listeners! reset-edit-history! hide-error-messages! Editor], :type :cljs, :sym paren-soup.core} {:var-syms [top-level? get-selection get-cursor-position text-node? get-focused-form get-focused-top-level get-parent coll-node? get-nearest-ns get-completion-info get-focused-elem error-node? get-completion-context common-ancestor get-parents node?], :type :cljs, :sym paren-soup.dom} {:var-syms [elem? elems->locations results->html get-collections collection->content create-compiler-fn], :type :cljs, :sym paren-soup.instarepl} {:var-syms [after-render current-component as-component adapt-react-class atom merge-props force-update-all as-element rswap! next-tick track props dispose! state-atom flush children wrap reactify-component unmount-component-at-node render-component component-path cursor state dom-node track! is-client replace-state partial set-state argv render force-update create-class create-element], :type :cljs, :sym reagent.core} {:var-syms [has-console tracking warnings track-warnings], :type :cljs, :sym reagent.debug} {:var-syms [render unmount-component-at-node dom-node force-update-all], :type :cljs, :sym reagent.dom} {:var-syms [fake-raf do-before-flush flush-after-render queue-render next-tick flush mark-rendered schedule render-queue compare-mount-order mount-count next-mount-count do-after-render run-queue ratom-flush], :type :cljs, :sym reagent.impl.batching} {:var-syms [get-props get-wrapper get-argv wrap-render rat-opts obligatory props-argv as-element do-render comp-name add-obligatory cached-react-class state-atom fiber-component-path dash-to-camel reagent-component? static-fns as-class reagent-class? fn-to-class reactify-component extract-children component-path extract-props get-children camelify-map-keys shallow-obj-to-map cljsify react-class? cache-react-class custom-wrapper create-class wrap-funs], :type :cljs, :sym reagent.impl.component} {:var-syms [valid-tag? adapt-react-class synthetic-input-spec has-selection-api? str-coll get-key re-tag as-element input-component? input-render-setup input-component-set-value stringify-class oget hiccup-tag? set-id-class reagent-synthetic-input input-node-set-value convert-props hiccup-err named? kv-conv key-from-vec js-val? input-unmount reagent-input-class native-element reagent-input cache-get input-handle-change input-spec expand-seq-dev cached-prop-name these-inputs-have-selection-api expand-seq reagent-synthetic-input-class find-dom-node cached-parse try-get-key], :type :cljs, :sym reagent.impl.template} {:var-syms [merge-props capitalize dash-to-camel dont-camel-case memoize-1 make-partial-fn *non-reactive* fun-name is-client force-update *always-update*], :type :cljs, :sym reagent.impl.util} {:var-syms [make-track atom make-wrapper IReactiveAtom track dispose! run add-on-dispose! make-track! run-in-reaction IDisposable with-let-destroy make-reaction flush! debug cursor running IRunnable reactive? with-let-values track! check-derefs], :type :cljs, :sym reagent.ratom} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [state build-defcs build-defcc request-render mount unmount], :type :cljs, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [wrap-attrs include-css include-react *group* file-upload], :type :cljs, :sym sablono.core} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}), :cljs-nses-and-vars {eval-soup.core ({:sym chan?, :meta {}, :source "(def\n chan?\n (partial instance? cljs.core.async.impl.channels.ManyToManyChannel))\n"} {:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n"}), reagent.impl.util ({:sym merge-props, :meta {:doc nil, :arglists ([p1 p2])}, :source "(defn\n merge-props\n [p1 p2]\n (if\n  (nil? p1)\n  p2\n  (do\n   (assert (map? p1) (str \"Property must be a map, not \" (pr-str p1)))\n   (merge-style p1 (merge-class p1 (merge p1 p2))))))\n"} {:sym capitalize, :meta {:doc nil, :arglists ([s])}, :source "(defn\n capitalize\n [s]\n (if\n  (< (count s) 2)\n  (string/upper-case s)\n  (str (string/upper-case (subs s 0 1)) (subs s 1))))\n"} {:sym dash-to-camel, :meta {:doc nil, :arglists ([dashed])}, :source "(defn\n dash-to-camel\n [dashed]\n (if\n  (string? dashed)\n  dashed\n  (let\n   [name-str\n    (name dashed)\n    [start & parts]\n    (string/split name-str #\"-\")]\n   (if\n    (dont-camel-case start)\n    name-str\n    (apply str start (map capitalize parts))))))\n"} {:sym dont-camel-case, :meta {}, :source "(def dont-camel-case #{\"aria\" \"data\"})\n"} {:sym memoize-1, :meta {:doc nil, :arglists ([f])}, :source "(defn\n memoize-1\n [f]\n (let\n  [mem (atom {})]\n  (fn\n   [arg]\n   (let\n    [v (get @mem arg)]\n    (if-not\n     (nil? v)\n     v\n     (let [ret (f arg)] (swap! mem assoc arg ret) ret))))))\n"} {:sym make-partial-fn, :meta {:doc nil, :arglists ([f args])}, :source "(defn\n make-partial-fn\n [f args]\n (->PartialFn (apply partial f args) f args))\n"} {:sym *non-reactive*, :meta {}, :source "(def *non-reactive* false)\n"} {:sym fun-name, :meta {:doc nil, :arglists ([f])}, :source "(defn\n fun-name\n [f]\n (let\n  [n\n   (or\n    (and (fn? f) (or ($ f :displayName) ($ f :name)))\n    (and (implements? INamed f) (name f))\n    (let [m (meta f)] (if (map? m) (:name m))))]\n  (-> n str (clojure.string/replace \"$\" \".\"))))\n"} {:sym is-client, :meta {}, :source "(def\n is-client\n (and (exists? js/window) (-> js/window ($ :document) nil? not)))\n"} {:sym force-update, :meta {:doc nil, :arglists ([comp deep])}, :source "(defn\n force-update\n [comp deep]\n (if\n  deep\n  (binding [*always-update* true] ($ comp forceUpdate))\n  ($ comp forceUpdate)))\n"} {:sym *always-update*, :meta {}, :source "(def *always-update* false)\n"}), cljs.source-map.base64 ({:sym chars64, :meta {}, :source "(def\n chars64\n \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n"} {:sym char->int, :meta {}, :source "(def char->int (zipmap chars64 (range 0 64)))\n"} {:sym int->char, :meta {}, :source "(def int->char (zipmap (range 0 64) chars64))\n"} {:sym encode, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode\n [n]\n (let\n  [e (find int->char n)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Must be between 0 and 63: \" n))))))\n"} {:sym decode, :meta {:doc nil, :arglists ([c])}, :source "(defn\n decode\n [c]\n (let\n  [e (find char->int c)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Not a valid base 64 digit: \" c))))))\n"}), oakcljs.tools.reader.impl.utils ({:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :source "(defn\n reader-conditional\n \"Construct a data representation of a reader conditional.\\n  If true, splicing? indicates read-cond-splicing.\"\n [form splicing?]\n (ReaderConditional. splicing? form))\n"} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :source "(defn\n whitespace?\n \"Checks whether a given character is whitespace\"\n [ch]\n (when-not (nil? ch) (if (identical? ch \\,) true (.test ws-rx ch))))\n"} {:sym last-id, :meta {}, :source "(def last-id (atom 0))\n"} {:sym char, :meta {:doc nil, :arglists ([x])}, :source "(defn char [x] (when-not (nil? x) (cljs.core/char x)))\n"} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :source "(defn\n numeric?\n \"Checks whether a given character is numeric\"\n [ch]\n (when-not (nil? ch) (gstring/isNumeric ch)))\n"} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :source "(defn second' [[a b]] (when-not a b))\n"} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :source "(defn\n desugar-meta\n \"Resolves syntactical sugar in metadata\"\n [f]\n (cond\n  (keyword? f)\n  {f true}\n  (symbol? f)\n  {:tag f}\n  (string? f)\n  {:tag f}\n  :else\n  f))\n"} {:sym next-id, :meta {:doc nil, :arglists ([])}, :source "(defn next-id [] (swap! last-id inc))\n"} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :source "(defn ex-info? [ex] (instance? cljs.core.ExceptionInfo ex))\n"} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :source "(defn\n reader-conditional?\n \"Return true if the value is the data representation of a reader conditional\"\n [value]\n (instance? ReaderConditional value))\n"} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :source "(defn\n newline?\n \"Checks whether the character is a newline\"\n [c]\n (or (identical? \\newline c) (identical? \"\\n\" c) (nil? c)))\n"} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :source "(defn\n namespace-keys\n [ns keys]\n (for\n  [key keys]\n  (if\n   (or (symbol? key) (keyword? key))\n   (let\n    [[key-ns key-name]\n     ((juxt namespace name) key)\n     ->key\n     (if (symbol? key) symbol keyword)]\n    (cond\n     (nil? key-ns)\n     (->key ns key-name)\n     (= \"_\" key-ns)\n     (->key key-name)\n     :else\n     key))\n   key)))\n"} {:sym ws-rx, :meta {}, :source "(def ws-rx #\"[\\s]\")\n"}), cljs.core.async.impl.channels ({:sym box, :meta {:doc nil, :arglists ([val])}, :source "(defn box [val] (reify cljs.core/IDeref (-deref [_] val)))\n"} {:sym put-active?, :meta {:doc nil, :arglists ([box])}, :source "(defn put-active? [box] (impl/active? (.-handler box)))\n"} {:sym MAX_DIRTY, :meta {}, :source "(def MAX_DIRTY 64)\n"} {:sym abort, :meta {:doc nil, :arglists ([this])}, :protocol MMC} {:sym MMC, :meta {:doc nil}, :methods (abort)} {:sym chan, :meta {:doc nil, :arglists [[buf] [buf xform] [buf xform exh]]}, :source "(defn\n chan\n ([buf] (chan buf nil))\n ([buf xform] (chan buf xform nil))\n ([buf xform exh]\n  (ManyToManyChannel.\n   (buffers/ring-buffer 32)\n   0\n   (buffers/ring-buffer 32)\n   0\n   buf\n   false\n   (let\n    [add! (if xform (xform impl/add!) impl/add!)]\n    (fn\n     ([buf] (try (add! buf) (catch :default t (handle buf exh t))))\n     ([buf val]\n      (try (add! buf val) (catch :default t (handle buf exh t)))))))))\n"}), cljs.core.async.impl.dispatch ({:sym tasks, :meta {}, :source "(def tasks (buffers/ring-buffer 32))\n"} {:sym running?, :meta {}, :source "(def running? false)\n"} {:sym queued?, :meta {}, :source "(def queued? false)\n"} {:sym TASK_BATCH_SIZE, :meta {}, :source "(def TASK_BATCH_SIZE 1024)\n"} {:sym process-messages, :meta {:doc nil, :arglists ([])}, :source "(defn\n process-messages\n []\n (set! running? true)\n (set! queued? false)\n (loop\n  [count 0]\n  (let\n   [m (.pop tasks)]\n   (when-not\n    (nil? m)\n    (m)\n    (when (< count TASK_BATCH_SIZE) (recur (inc count))))))\n (set! running? false)\n (when (> (.-length tasks) 0) (queue-dispatcher)))\n"} {:sym queue-dispatcher, :meta {:doc nil, :arglists ([])}, :source "(defn\n queue-dispatcher\n []\n (when-not\n  (and queued? running?)\n  (set! queued? true)\n  (goog.async.nextTick process-messages)))\n"} {:sym run, :meta {:doc nil, :arglists ([f])}, :source "(defn run [f] (.unbounded-unshift tasks f) (queue-dispatcher))\n"} {:sym queue-delay, :meta {:doc nil, :arglists ([f delay])}, :source "(defn queue-delay [f delay] (js/setTimeout f delay))\n"}), paren-soup.core ({:sym can-undo, :meta {:doc nil, :arglists ([editor])}, :source "(defn can-undo [editor] (can-undo? editor))\n"} {:sym show-error-message!, :meta {:doc "Shows a popup with an error message.", :arglists ([parent-elem event])}, :source "(defn\n show-error-message!\n \"Shows a popup with an error message.\"\n [parent-elem event]\n (let\n  [elem\n   (.-target event)\n   x\n   (.-clientX event)\n   y\n   (.-clientY event)\n   popup\n   (.createElement js/document \"div\")]\n  (set! (.-textContent popup) (-> elem .-dataset .-message))\n  (set! (.-top (.-style popup)) (str y \"px\"))\n  (set! (.-left (.-style popup)) (str x \"px\"))\n  (set! (.-className popup) \"error-text\")\n  (.appendChild parent-elem popup)))\n"} {:sym focused-text, :meta {:doc nil, :arglists ([])}, :source "(defn focused-text [] (some-> (dom/get-focused-form) .-textContent))\n"} {:sym selected-text, :meta {:doc nil, :arglists ([])}, :source "(defn\n selected-text\n []\n (let\n  [s (-> js/window .getSelection .toString)]\n  (when-not (empty? s) s)))\n"} {:sym can-redo?, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym can-redo, :meta {:doc nil, :arglists ([editor])}, :source "(defn can-redo [editor] (can-redo? editor))\n"} {:sym rainbow-delimiters, :meta {:doc "Returns a map of elements and class names.", :arglists [[parent level] [parent level m]]}, :source "(defn\n rainbow-delimiters\n \"Returns a map of elements and class names.\"\n ([parent level]\n  (persistent! (rainbow-delimiters parent level (transient {}))))\n ([parent level m]\n  (reduce\n   (fn\n    [m elem]\n    (let\n     [classes (.-classList elem)]\n     (cond\n      (.contains classes \"delimiter\")\n      (assoc! m elem (str \"rainbow-\" (mod level rainbow-count)))\n      (.contains classes \"collection\")\n      (rainbow-delimiters elem (inc level) m)\n      :else\n      m)))\n   m\n   (-> parent .-children array-seq))))\n"} {:sym up!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh!, :meta {:doc nil, :arglists ([this state])}, :protocol Editor} {:sym undo!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym key-name?, :meta {:doc "Returns true if the supplied key event involves the key(s) described by key-name.", :arglists ([event key-name])}, :source "(defn\n key-name?\n \"Returns true if the supplied key event involves the key(s) described by key-name.\"\n [event key-name]\n (let\n  [code (key-code event)]\n  (case\n   key-name\n   :undo-or-redo\n   (and (or (.-metaKey event) (.-ctrlKey event)) (= code 90))\n   :tab\n   (= code 9)\n   :enter\n   (= code 13)\n   :arrows\n   (contains? #{39 40 38 37} code)\n   :up-arrow\n   (= code 38)\n   :down-arrow\n   (= code 40)\n   :general\n   (not\n    (or\n     (contains? #{0 91 93 17 16 18} code)\n     (.-ctrlKey event)\n     (.-metaKey event)))\n   false)))\n"} {:sym eval, :meta {:doc nil, :arglists ([editor form callback])}, :source "(defn eval [editor form callback] (eval! editor form callback))\n"} {:sym channel?, :meta {}, :source "(def channel? any?)\n"} {:sym create-editor, :meta {:doc nil, :arglists ([paren-soup content events-chan {:keys [history-limit append-limit compiler-fn console-callback disable-clj? edit-history], :or {history-limit 100, append-limit 5000}}])}, :source "(defn\n create-editor\n [paren-soup\n  content\n  events-chan\n  {:keys\n   [history-limit\n    append-limit\n    compiler-fn\n    console-callback\n    disable-clj?\n    edit-history],\n   :or {history-limit 100, append-limit 5000}}]\n (let\n  [clj?\n   (not disable-clj?)\n   editor?\n   (not console-callback)\n   compiler-fn\n   (or compiler-fn (ir/create-compiler-fn))\n   edit-history\n   (doto\n    (or edit-history (mwm/create-edit-history))\n    (swap! assoc :limit history-limit))\n   refresh-instarepl-with-delay!\n   (debounce refresh-instarepl! 300)\n   console-history\n   (console/create-console-history)\n   last-highlight-elem\n   (atom nil)\n   allow-tab?\n   (atom false)]\n  (when-not\n   editor?\n   (set-validator!\n    edit-history\n    (fn\n     [{:keys [current-state states]}]\n     (if-let\n      [state (get states current-state)]\n      (->\n       state\n       :cursor-position\n       first\n       (>= (console/get-console-start console-history)))\n      true))))\n  (reify\n   Editor\n   (undo! [this] (some->> edit-history mwm/undo! (refresh! this)))\n   (redo! [this] (some->> edit-history mwm/redo! (refresh! this)))\n   (can-undo? [this] (mwm/can-undo? edit-history))\n   (can-redo? [this] (mwm/can-redo? edit-history))\n   (update-cursor-position!\n    [this position]\n    (try\n     (mwm/update-cursor-position! edit-history position)\n     (catch\n      js/Error\n      _\n      (when\n       (apply = position)\n       (let\n        [start (console/get-console-start console-history)]\n        (dom/set-cursor-position! content [start start])\n        (mwm/update-cursor-position! edit-history [start start])))))\n    (update-highlight! content last-highlight-elem))\n   (reset-edit-history!\n    [this start]\n    (console/update-console-start! console-history start)\n    (dom/set-cursor-position! content [start start])\n    (let\n     [new-edit-history\n      (mwm/create-edit-history)\n      state\n      {:cursor-position [start start], :text (.-textContent content)}]\n     (update-edit-history! new-edit-history state)\n     (reset! edit-history @new-edit-history)))\n   (append-text!\n    [this text]\n    (let\n     [node\n      (.createTextNode js/document text)\n      _\n      (.appendChild content node)\n      all-text\n      (.-textContent content)\n      char-count\n      (max 0 (- (count all-text) append-limit))\n      new-all-text\n      (subs all-text char-count)\n      char-count\n      (if\n       (.endsWith new-all-text \"\\n\")\n       (dec (count new-all-text))\n       (count new-all-text))]\n     (when\n      (not= all-text new-all-text)\n      (set! (.-textContent content) new-all-text))\n     (reset-edit-history! this char-count)))\n   (enter!\n    [this]\n    (if\n     editor?\n     (.execCommand js/document \"insertHTML\" false \"\\n\")\n     (let\n      [text\n       (trimr (.-textContent content))\n       post-text\n       (subs text (console/get-console-start console-history))]\n      (reset-edit-history! this (count text))\n      (console/update-console-history! console-history post-text)\n      (console-callback post-text))))\n   (up!\n    [this]\n    (when-not\n     editor?\n     (let\n      [text\n       (.-textContent content)\n       pre-text\n       (subs text 0 (console/get-console-start console-history))\n       line\n       (or (console/up! console-history) \"\")\n       state\n       {:cursor-position (dom/get-cursor-position content false),\n        :text (str pre-text line \\newline)}]\n      (->>\n       state\n       (update-edit-history! edit-history)\n       (refresh! this)))))\n   (down!\n    [this]\n    (when-not\n     editor?\n     (let\n      [text\n       (.-textContent content)\n       pre-text\n       (subs text 0 (console/get-console-start console-history))\n       line\n       (or (console/down! console-history) \"\")\n       state\n       {:cursor-position (dom/get-cursor-position content false),\n        :text (str pre-text line \\newline)}]\n      (->>\n       state\n       (update-edit-history! edit-history)\n       (refresh! this)))))\n   (tab! [this] (when editor? (reset! allow-tab? true)))\n   (refresh!\n    [this state]\n    (post-refresh-content!\n     content\n     events-chan\n     (if\n      editor?\n      (refresh-content! content state)\n      (refresh-console-content!\n       content\n       state\n       (console/get-console-start console-history)\n       clj?)))\n    (when\n     editor?\n     (some->\n      (.querySelector paren-soup \".numbers\")\n      (refresh-numbers! (count (re-seq #\"\\n\" (:text state)))))\n     (when\n      clj?\n      (when-let\n       [elem (.querySelector paren-soup \".instarepl\")]\n       (when-not\n        (-> elem .-style .-display (= \"none\"))\n        (refresh-instarepl-with-delay! elem content compiler-fn)))))\n    (update-highlight! content last-highlight-elem))\n   (edit-and-refresh!\n    [this state]\n    (->>\n     state\n     (add-newline)\n     (add-parinfer clj? (console/get-console-start console-history))\n     (update-edit-history! edit-history)\n     (refresh! this)))\n   (initialize!\n    [this]\n    (when\n     editor?\n     (->> (init-state content false false) (edit-and-refresh! this))))\n   (refresh-after-key-event!\n    [this event]\n    (let\n     [tab?\n      (key-name? event :tab)\n      state\n      (init-state content editor? tab?)]\n     (when-not\n      (and tab? (not @allow-tab?))\n      (edit-and-refresh!\n       this\n       (case\n        (key-code event)\n        13\n        (assoc state :indent-type :return)\n        9\n        (assoc\n         state\n         :indent-type\n         (if (.-shiftKey event) :back :forward))\n        (assoc state :indent-type :normal))))\n     (when tab? (reset! allow-tab? false))))\n   (refresh-after-cut-paste!\n    [this]\n    (let\n     [html\n      (.-innerHTML content)\n      insert-newlines?\n      (-> html (.indexOf \"</tr>\") (> 0))\n      crop?\n      (and editor? (not insert-newlines?))]\n     (when\n      insert-newlines?\n      (set! (.-innerHTML content) (replace html \"</tr>\" \\newline)))\n     (edit-and-refresh!\n      this\n      (assoc (init-state content crop? false) :indent-type :normal))))\n   (eval!\n    [this form callback]\n    (compiler-fn\n     [form]\n     (fn* [p1__18520#] (callback (first p1__18520#))))))))\n"} {:sym key-code, :meta {:doc nil, :arglists ([event])}, :source "(defn\n key-code\n [event]\n (let [code (.-keyCode event)] (if (pos? code) code (.-which event))))\n"} {:sym redo!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym post-refresh-content!, :meta {:doc "Does additional work on the content after it is rendered.", :arglists ([content events-chan state])}, :source "(defn\n post-refresh-content!\n \"Does additional work on the content after it is rendered.\"\n [content events-chan state]\n (if-let\n  [crop (:cropped-state state)]\n  (some->\n   (:element crop)\n   (dom/set-cursor-position! (:cursor-position crop)))\n  (dom/set-cursor-position! content (:cursor-position state)))\n (hide-error-messages! (.-parentElement content))\n (doseq\n  [elem (-> content (.querySelectorAll \".error\") array-seq)]\n  (let\n   [show-error-icon!\n    (fn [elem] (set! (.-display (.-style elem)) \"inline-block\"))\n    show-error-icon!\n    (debounce show-error-icon! 1000)]\n   (show-error-icon! elem))\n  (events/listen\n   elem\n   \"mouseenter\"\n   (fn* [p1__18516#] (put! events-chan p1__18516#)))\n  (events/listen\n   elem\n   \"mouseleave\"\n   (fn* [p1__18517#] (put! events-chan p1__18517#))))\n (doseq\n  [[elem class-name] (rainbow-delimiters content -1)]\n  (.add (.-classList elem) class-name)))\n"} {:sym tab!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym transient-map?, :meta {}, :source "(def\n transient-map?\n (fn*\n  [p1__18512#]\n  (or\n   (instance? cljs.core/TransientArrayMap p1__18512#)\n   (instance? cljs.core/TransientHashMap p1__18512#))))\n"} {:sym refresh-content-element!, :meta {:doc "Replaces a single node in the content, and siblings if necessary.", :arglists ([cropped-state])}, :source "(defn\n refresh-content-element!\n \"Replaces a single node in the content, and siblings if necessary.\"\n [cropped-state]\n (let\n  [{:keys [element text]}\n   cropped-state\n   parent\n   (.-parentElement element)\n   last-elem\n   (.-lastChild parent)\n   last-error\n   (loop\n    [current-elem last-elem]\n    (cond\n     (dom/error-node? current-elem)\n     current-elem\n     (or (nil? current-elem) (= element current-elem))\n     nil\n     :else\n     (recur (.-previousSibling current-elem))))\n   last-elem-to-refresh\n   (when\n    last-error\n    (loop\n     [current-elem last-error]\n     (if-let\n      [sibling (.-nextSibling current-elem)]\n      (if (dom/coll-node? sibling) current-elem (recur sibling))\n      current-elem)))\n   old-elems\n   (loop\n    [elems [element] current-elem element]\n    (cond\n     (= last-elem-to-refresh current-elem)\n     elems\n     (or (some? last-elem-to-refresh) (dom/text-node? current-elem))\n     (if-let\n      [sibling (.-nextSibling current-elem)]\n      (recur (conj elems sibling) sibling)\n      elems)\n     :else\n     elems))\n   _\n   (set! (.-textContent element) text)\n   text\n   (join (map (fn* [p1__18518#] (.-textContent p1__18518#)) old-elems))\n   temp-elem\n   (.createElement js/document \"span\")\n   _\n   (set! (.-innerHTML temp-elem) (hs/code->html text))\n   new-elems\n   (doall\n    (for\n     [i (range (-> temp-elem .-childNodes .-length))]\n     (-> temp-elem .-childNodes (.item i))))]\n  (doseq [new-elem new-elems] (.insertBefore parent new-elem element))\n  (doseq [old-elem old-elems] (.removeChild parent old-elem))\n  (assoc cropped-state :element (first new-elems))))\n"} {:sym elem?, :meta {}, :source "(def elem? (fn* [p1__18513#] (instance? js/Element p1__18513#)))\n"} {:sym enter!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym append-text!, :meta {:doc nil, :arglists ([this text])}, :protocol Editor} {:sym line-numbers, :meta {:doc "Adds line numbers to the numbers.", :arglists ([line-count])}, :source "(defn\n line-numbers\n \"Adds line numbers to the numbers.\"\n [line-count]\n (join (for [i (range line-count)] (str \"<div>\" (inc i) \"</div>\"))))\n"} {:sym update-highlight!, :meta {:doc nil, :arglists ([content last-elem])}, :source "(defn\n update-highlight!\n [content last-elem]\n (when-let\n  [elem @last-elem]\n  (set! (.-backgroundColor (.-style elem)) nil)\n  (reset! last-elem nil))\n (when-let\n  [elem (dom/get-focused-form)]\n  (when-let\n   [color\n    (.getPropertyValue\n     (.getComputedStyle js/window (.-firstChild elem))\n     \"color\")]\n   (let\n    [new-color (-> color (replace #\"rgb\\(\" \"\") (replace #\"\\)\" \"\"))]\n    (set!\n     (.-backgroundColor (.-style elem))\n     (str \"rgba(\" new-color \", 0.1)\"))\n    (reset! last-elem elem)))))\n"} {:sym init, :meta {:doc nil, :arglists ([paren-soup opts])}, :source "(defn\n init\n [paren-soup opts]\n (.init js/rangy)\n (let\n  [opts\n   (js->clj opts :keywordize-keys true)\n   content\n   (.querySelector paren-soup \".content\")\n   events-chan\n   (chan)\n   editor\n   (create-editor paren-soup content events-chan opts)]\n  (set! (.-spellcheck paren-soup) false)\n  (when-not\n   content\n   (throw (js/Error. \"Can't find a div with class 'content'\")))\n  (initialize! editor)\n  (add-event-listeners! content events-chan opts)\n  (go\n   (while\n    true\n    (let\n     [event (<! events-chan)]\n     (when-not\n      (some->\n       opts\n       :before-change-callback\n       ((fn* [p1__18525#] (p1__18525# event))))\n      (case\n       (.-type event)\n       \"keydown\"\n       (cond\n        (and\n         (key-name? event :undo-or-redo)\n         (-> opts :disable-undo-redo? not))\n        (if (.-shiftKey event) (redo! editor) (undo! editor))\n        (key-name? event :enter)\n        (enter! editor)\n        (key-name? event :up-arrow)\n        (up! editor)\n        (key-name? event :down-arrow)\n        (down! editor)\n        (key-name? event :tab)\n        (tab! editor))\n       \"keyup\"\n       (cond\n        (key-name? event :arrows)\n        (update-cursor-position!\n         editor\n         (dom/get-cursor-position content false))\n        (key-name? event :general)\n        (refresh-after-key-event! editor event))\n       \"cut\"\n       (refresh-after-cut-paste! editor)\n       \"paste\"\n       (refresh-after-cut-paste! editor)\n       \"mouseup\"\n       (update-cursor-position!\n        editor\n        (dom/get-cursor-position\n         content\n         (some? (:console-callback opts))))\n       \"mouseenter\"\n       (show-error-message! paren-soup event)\n       \"mouseleave\"\n       (hide-error-messages! paren-soup)\n       nil)\n      (some->\n       opts\n       :change-callback\n       ((fn* [p1__18526#] (p1__18526# event))))))))\n  editor))\n"} {:sym can-undo?, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh-content!, :meta {:doc "Refreshes the content.", :arglists ([content state])}, :source "(defn\n refresh-content!\n \"Refreshes the content.\"\n [content state]\n (if-let\n  [crop (:cropped-state state)]\n  (let\n   [crop (refresh-content-element! crop)]\n   (if\n    (not= (:text state) (.-textContent content))\n    (refresh-content! content (dissoc state :cropped-state))\n    (assoc state :cropped-state crop)))\n  (do\n   (set! (.-innerHTML content) (hs/code->html (:text state)))\n   (dissoc state :cropped-state))))\n"} {:sym redo, :meta {:doc nil, :arglists ([editor])}, :source "(defn redo [editor] (redo! editor))\n"} {:sym debounce-function, :meta {:doc nil, :arglists ([f millis])}, :source "(defn debounce-function [f millis] (debounce f millis))\n"} {:sym refresh-instarepl!, :meta {:doc "Refreshes the InstaREPL.", :arglists ([instarepl content compiler-fn])}, :source "(defn\n refresh-instarepl!\n \"Refreshes the InstaREPL.\"\n [instarepl content compiler-fn]\n (let\n  [elems\n   (ir/get-collections content)\n   locations\n   (ir/elems->locations elems (.-offsetTop instarepl))\n   forms\n   (->>\n    elems\n    (map ir/collection->content)\n    (map (fn* [p1__18515#] (replace p1__18515# \\  \" \"))))]\n  (compiler-fn\n   forms\n   (fn\n    [results]\n    (when\n     (.-parentElement instarepl)\n     (set!\n      (.-innerHTML instarepl)\n      (ir/results->html results locations)))))))\n"} {:sym edit-and-refresh!, :meta {:doc nil, :arglists ([this state])}, :protocol Editor} {:sym rainbow-count, :meta {}, :source "(def rainbow-count 5)\n"} {:sym update-cursor-position!, :meta {:doc nil, :arglists ([this position])}, :protocol Editor} {:sym init-state, :meta {:doc "Returns the editor's state. If full-selection? is true, it will try to save\nthe entire selection rather than just the cursor position.", :arglists ([content crop? full-selection?])}, :source "(defn\n init-state\n \"Returns the editor's state. If full-selection? is true, it will try to save\\nthe entire selection rather than just the cursor position.\"\n [content crop? full-selection?]\n (let\n  [selection\n   (.getSelection js/rangy)\n   anchor\n   (.-anchorNode selection)\n   focus\n   (.-focusNode selection)\n   parent\n   (when (and anchor focus) (dom/common-ancestor anchor focus))\n   state\n   {:cursor-position\n    (-> content (dom/get-selection full-selection?) :cursor-position),\n    :text (.-textContent content)}]\n  (if-let\n   [cropped-selection (some-> parent (dom/get-selection false))]\n   (if\n    crop?\n    (assoc\n     state\n     :cropped-state\n     (assoc cropped-selection :text (.-textContent parent)))\n    state)\n   state)))\n"} {:sym eval!, :meta {:doc nil, :arglists ([this form callback])}, :protocol Editor} {:sym add-parinfer-after-console-start, :meta {:doc nil, :arglists ([console-start-num state])}, :source "(defn\n add-parinfer-after-console-start\n [console-start-num state]\n (let\n  [pre-text\n   (subs (:text state) 0 console-start-num)\n   post-text\n   (subs (:text state) console-start-num)\n   cleared-text\n   (str (replace pre-text #\"[^\\r^\\n]\" \" \") post-text)\n   temp-state\n   (assoc state :text cleared-text)\n   temp-state\n   (cp/add-parinfer :both temp-state)\n   new-text\n   (str pre-text (subs (:text temp-state) console-start-num))]\n  (assoc state :text new-text)))\n"} {:sym refresh-numbers!, :meta {:doc "Refreshes the line numbers.", :arglists ([numbers line-count])}, :source "(defn\n refresh-numbers!\n \"Refreshes the line numbers.\"\n [numbers line-count]\n (set! (.-innerHTML numbers) (line-numbers line-count)))\n"} {:sym refresh-after-cut-paste!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh-after-key-event!, :meta {:doc nil, :arglists ([this event])}, :protocol Editor} {:sym add-newline, :meta {:doc nil, :arglists ([{:keys [text], :as state}])}, :source "(defn\n add-newline\n [{:keys [text], :as state}]\n (if-not\n  (= \\newline (last text))\n  (assoc state :text (str text \\newline))\n  state))\n"} {:sym update-edit-history!, :meta {:doc nil, :arglists ([edit-history state])}, :source "(defn\n update-edit-history!\n [edit-history state]\n (try\n  (mwm/update-edit-history! edit-history (dissoc state :cropped-state))\n  state\n  (catch js/Error _ (mwm/get-current-state edit-history))))\n"} {:sym refresh-console-content!, :meta {:doc nil, :arglists ([content state console-start-num clj?])}, :source "(defn\n refresh-console-content!\n [content state console-start-num clj?]\n (set!\n  (.-innerHTML content)\n  (if\n   clj?\n   (let\n    [pre-text\n     (subs (:text state) 0 console-start-num)\n     post-text\n     (subs (:text state) console-start-num)]\n    (str (hs/escape-html-str pre-text) (hs/code->html post-text)))\n   (hs/escape-html-str (:text state))))\n state)\n"} {:sym append-text, :meta {:doc nil, :arglists ([editor text])}, :source "(defn append-text [editor text] (append-text! editor text))\n"} {:sym prevent-default?, :meta {:doc nil, :arglists ([event opts])}, :source "(defn\n prevent-default?\n [event opts]\n (or\n  (key-name? event :undo-or-redo)\n  (key-name? event :tab)\n  (key-name? event :enter)\n  (and\n   (:console-callback opts)\n   (or (key-name? event :up-arrow) (key-name? event :down-arrow)))))\n"} {:sym initialize!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym add-parinfer, :meta {:doc nil, :arglists ([enable? console-start-num state])}, :source "(defn\n add-parinfer\n [enable? console-start-num state]\n (if\n  enable?\n  (let\n   [cropped-state\n    (:cropped-state state)\n    indent-type\n    (:indent-type state)\n    state\n    (cond\n     (pos? console-start-num)\n     (add-parinfer-after-console-start console-start-num state)\n     indent-type\n     (cp/add-indent state)\n     :else\n     (cp/add-parinfer :paren state))]\n   (if\n    (and cropped-state indent-type)\n    (assoc\n     state\n     :cropped-state\n     (merge\n      cropped-state\n      (cp/add-indent (assoc cropped-state :indent-type indent-type))))\n    state))\n  state))\n"} {:sym undo, :meta {:doc nil, :arglists ([editor])}, :source "(defn undo [editor] (undo! editor))\n"} {:sym obj?, :meta {}, :source "(def obj? (fn* [p1__18514#] (instance? js/Object p1__18514#)))\n"} {:sym down!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym add-event-listeners!, :meta {:doc nil, :arglists ([content events-chan opts])}, :source "(defn\n add-event-listeners!\n [content events-chan opts]\n (doto\n  content\n  (events/removeAll)\n  (events/listen\n   \"keydown\"\n   (fn\n    [e]\n    (when (prevent-default? e opts) (.preventDefault e))\n    (put! events-chan e)))\n  (events/listen\n   \"keyup\"\n   (fn* [p1__18521#] (put! events-chan p1__18521#)))\n  (events/listen\n   \"cut\"\n   (fn* [p1__18522#] (put! events-chan p1__18522#)))\n  (events/listen\n   \"paste\"\n   (fn* [p1__18523#] (put! events-chan p1__18523#)))\n  (events/listen\n   \"mouseup\"\n   (fn* [p1__18524#] (put! events-chan p1__18524#)))))\n"} {:sym reset-edit-history!, :meta {:doc nil, :arglists ([this start])}, :protocol Editor} {:sym hide-error-messages!, :meta {:doc "Hides all error popups.", :arglists ([parent-elem])}, :source "(defn\n hide-error-messages!\n \"Hides all error popups.\"\n [parent-elem]\n (doseq\n  [elem (-> parent-elem (.querySelectorAll \".error-text\") array-seq)]\n  (.removeChild parent-elem elem)))\n"} {:sym Editor, :meta {:doc nil}, :methods (append-text! can-redo? can-undo? down! edit-and-refresh! enter! eval! initialize! redo! refresh! refresh-after-cut-paste! refresh-after-key-event! reset-edit-history! tab! undo! up! update-cursor-position!)}), cljs.tools.reader.impl.commons ({:sym match-number, :meta {:doc nil, :arglists ([s])}, :source "(defn\n match-number\n [s]\n (if\n  (matches? int-pattern s)\n  (match-int s)\n  (if\n   (matches? float-pattern s)\n   (match-float s)\n   (when (matches? ratio-pattern s) (match-ratio s)))))\n"} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :source "(defn\n skip-line\n \"Advances the reader to the end of a line. Returns the reader\"\n [reader]\n (loop [] (when-not (newline? (read-char reader)) (recur)))\n reader)\n"} {:sym int-pattern, :meta {}, :source "(def\n int-pattern\n #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n"} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :source "(defn read-comment [rdr & _] (skip-line rdr))\n"} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :source "(defn\n parse-symbol\n \"Parses a string into a vector of the namespace and symbol\"\n [token]\n (when-not\n  (or\n   (identical? \"\" token)\n   (true? (.test #\":$\" token))\n   (true? (.test #\"^::\" token)))\n  (let\n   [ns-idx\n    (.indexOf token \"/\")\n    ns\n    (when (pos? ns-idx) (subs token 0 ns-idx))]\n   (if-not\n    (nil? ns)\n    (let\n     [ns-idx (inc ns-idx)]\n     (when-not\n      (== ns-idx (count token))\n      (let\n       [sym (subs token ns-idx)]\n       (when\n        (and\n         (not (numeric? (nth sym 0)))\n         (not (identical? \"\" sym))\n         (false? (.test #\":$\" ns))\n         (or (identical? sym \"/\") (== -1 (.indexOf sym \"/\"))))\n        [ns sym]))))\n    (when\n     (or (identical? token \"/\") (== -1 (.indexOf token \"/\")))\n     [nil token])))))\n"} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :source "(defn\n number-literal?\n \"Checks whether the reader is at the start of a number literal\"\n [reader initch]\n (or\n  (numeric? initch)\n  (and\n   (or (identical? \\+ initch) (identical? \\- initch))\n   (numeric? (peek-char reader)))))\n"} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :source "(defn\n read-past\n \"Read until first character that doesn't match pred, returning\\n   char.\"\n [pred rdr]\n (loop [ch (read-char rdr)] (if (pred ch) (recur (read-char rdr)) ch)))\n"} {:sym float-pattern, :meta {}, :source "(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n"} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :source "(defn\n matches?\n [pattern s]\n (let [[match] (re-find pattern s)] (identical? match s)))\n"} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :source "(defn throwing-reader [msg] (fn [rdr & _] (reader-error rdr msg)))\n"} {:sym ratio-pattern, :meta {}, :source "(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n"}), cljs.tools.reader.edn ({:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader] (read {} reader))\n ([{:keys [eof], :as opts} reader]\n  (let\n   [eof-error? (not (contains? opts :eof))]\n   (read reader eof-error? eof opts)))\n ([reader eof-error? eof opts]\n  (try\n   (loop\n    []\n    (let\n     [ch (read-char reader)]\n     (cond\n      (whitespace? ch)\n      (recur)\n      (nil? ch)\n      (if eof-error? (err/throw-eof-error reader nil) eof)\n      (number-literal? reader ch)\n      (read-number reader ch opts)\n      :else\n      (let\n       [f (macros ch)]\n       (if\n        f\n        (let\n         [res (f reader ch opts)]\n         (if (identical? res reader) (recur) res))\n        (read-symbol reader ch))))))\n   (catch\n    js/Error\n    e\n    (if\n     (ex-info? e)\n     (let\n      [d (ex-data e)]\n      (if\n       (= :reader-exception (:type d))\n       (throw e)\n       (throw\n        (ex-info\n         (.-message e)\n         (merge\n          {:type :reader-exception}\n          d\n          (if\n           (indexing-reader? reader)\n           {:line (get-line-number reader),\n            :column (get-column-number reader),\n            :file (get-file-name reader)}))\n         e))))\n     (throw\n      (ex-info\n       (.-message e)\n       (merge\n        {:type :reader-exception}\n        (if\n         (indexing-reader? reader)\n         {:line (get-line-number reader),\n          :column (get-column-number reader),\n          :file (get-file-name reader)}))\n       e)))))))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per clojure.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per clojure.tools.reader.edn/read\"\n ([s] (read-string {:eof nil} s))\n ([opts s]\n  (when (and s (not= s \"\")) (read opts (string-push-back-reader s)))))\n"}), cljs.source-map.base64-vlq ({:sym vlq-base-shift, :meta {}, :source "(def vlq-base-shift 5)\n"} {:sym vlq-base, :meta {}, :source "(def vlq-base (bit-shift-left 1 vlq-base-shift))\n"} {:sym vlq-base-mask, :meta {}, :source "(def vlq-base-mask (dec vlq-base))\n"} {:sym vlq-continuation-bit, :meta {}, :source "(def vlq-continuation-bit vlq-base)\n"} {:sym to-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n to-vlq-signed\n [v]\n (if\n  (neg? v)\n  (inc (bit-shift-left (- v) 1))\n  (+ (bit-shift-left v 1) 0)))\n"} {:sym from-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n from-vlq-signed\n [v]\n (let\n  [neg? (= (bit-and v 1) 1) shifted (bit-shift-right v 1)]\n  (if neg? (- shifted) shifted)))\n"} {:sym encode-val, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode-val\n [n]\n (let\n  [sb (StringBuffer.) vlq (to-vlq-signed n)]\n  (loop\n   [digit\n    (bit-and vlq vlq-base-mask)\n    vlq\n    (bit-shift-right-zero-fill vlq vlq-base-shift)]\n   (if\n    (pos? vlq)\n    (let\n     [digit (bit-or digit vlq-continuation-bit)]\n     (.append sb (base64/encode digit))\n     (recur\n      (bit-and vlq vlq-base-mask)\n      (bit-shift-right-zero-fill vlq vlq-base-shift)))\n    (.append sb (base64/encode digit))))\n  (str sb)))\n"} {:sym encode, :meta {:doc nil, :arglists ([v])}, :source "(defn encode [v] (apply str (map encode-val v)))\n"} {:sym decode, :meta {:doc nil, :arglists ([s])}, :source "(defn\n decode\n [s]\n (let\n  [l (.-length s)]\n  (loop\n   [i 0 result 0 shift 0]\n   (when\n    (>= i l)\n    (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n   (let\n    [digit (base64/decode (.charAt s i))]\n    (let\n     [i\n      (inc i)\n      continuation?\n      (pos? (bit-and digit vlq-continuation-bit))\n      digit\n      (bit-and digit vlq-base-mask)\n      result\n      (+ result (bit-shift-left digit shift))\n      shift\n      (+ shift vlq-base-shift)]\n     (if\n      continuation?\n      (recur i result shift)\n      (lazy-seq\n       (cons\n        (from-vlq-signed result)\n        (let\n         [s (.substring s i)]\n         (when-not (string/blank? s) (decode s)))))))))))\n"}), oakcljs.tools.reader ({:sym bool?, :meta {:doc nil, :arglists ([x])}, :source "(defn bool? [x] (or (instance? js/Boolean x) (true? x) (false? x)))\n"} {:sym *suppress-read*, :meta {}, :source "(def *suppress-read* false)\n"} {:sym *default-data-reader-fn*, :meta {}, :source "(def\n *default-data-reader-fn*\n \"When no data reader is found for a tag and *default-data-reader-fn*\\n  is non-nil, it will be called with two arguments, the tag and the value.\\n  If *default-data-reader-fn* is nil (the default value), an exception\\n  will be thrown for the unknown tag.\"\n (fn [tag value]))\n"} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use oakclojure.tools.reader.edn/read\n\n   Note that the function signature of oakclojure.tools.reader/read and\n   oakclojure.tools.reader.edn/read is not the same for eof-handling", :arglists [[reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true.\\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\\n\\n   Opts is a persistent map with valid keys:\\n    :read-cond - :allow to process reader conditionals, or\\n                 :preserve to keep all branches\\n    :features - persistent set of feature keywords for reader conditionals\\n    :eof - on eof, return value unless :eofthrow, then throw.\\n           if not specified, will throw\\n\\n   To read data structures only, use oakclojure.tools.reader.edn/read\\n\\n   Note that the function signature of oakclojure.tools.reader/read and\\n   oakclojure.tools.reader.edn/read is not the same for eof-handling\"\n {:arglists '([] [reader] [opts reader] [reader eof-error? eof-value])}\n ([reader] (read reader true nil))\n ([{eof :eof, :as opts, :or {eof :eofthrow}} reader]\n  (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n ([reader eof-error? sentinel]\n  (read* reader eof-error? sentinel nil {} (to-array []))))\n"} {:sym default-data-readers, :meta {}, :source "(def\n default-data-readers\n \"Default map of data reader functions provided by Clojure.\\n  May be overridden by binding *data-readers*\"\n {})\n"} {:sym *data-readers*, :meta {}, :source "(def\n *data-readers*\n \"Map from reader tag symbols to data reader Vars.\\n  Reader tags without namespace qualifiers are reserved for Clojure.\\n  This light version of tools.reader has no implementation for default\\n  reader tags such as #inst and #uuid.\"\n {})\n"} {:sym *read-delim*, :meta {}, :source "(def *read-delim* false)\n"} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :source "(defn\n resolve-symbol\n \"Resolve a symbol s into its fully qualified namespace version\"\n [s]\n s)\n"} {:sym *alias-map*, :meta {}, :source "(def\n *alias-map*\n \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\\n   ns aliases.\\n\\n   Defaults to nil\"\n nil)\n"} {:sym *wrap-value-and-add-metadata?*, :meta {}, :source "(def *wrap-value-and-add-metadata?* false)\n"} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :source "(defn\n read-regex\n [rdr ch opts pending-forms]\n (let\n  [sb (StringBuffer.)]\n  (loop\n   [ch (read-char rdr)]\n   (if\n    (identical? \\\" ch)\n    (re-pattern (str sb))\n    (if\n     (nil? ch)\n     (err/throw-eof-reading rdr :regex sb)\n     (do\n      (.append sb ch)\n      (when\n       (identical? \\\\ ch)\n       (let\n        [ch (read-char rdr)]\n        (if (nil? ch) (err/throw-eof-reading rdr :regex sb))\n        (.append sb ch)))\n      (recur (read-char rdr))))))))\n"} {:sym sb, :meta {}, :source "(def sb (StringBuffer.))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use oakclojure.tools.reader.edn/read-string\n\n   Note that the function signature of oakclojure.tools.reader/read-string and\n   oakclojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   To read data structures only, use oakclojure.tools.reader.edn/read-string\\n\\n   Note that the function signature of oakclojure.tools.reader/read-string and\\n   oakclojure.tools.reader.edn/read-string is not the same for eof-handling\"\n ([s] (read-string {} s))\n ([opts s]\n  (when\n   (and s (not (identical? s \"\")))\n   (read opts (string-push-back-reader s)))))\n"} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :source "(defn\n map-func\n \"Decide which map type to use, array-map if less than 16 elements\"\n [coll]\n (if (>= (count coll) 16) 'cljs.core/hash-map 'cljs.core/array-map))\n"}), cljs.tools.reader ({:sym bool?, :meta {:doc nil, :arglists ([x])}, :source "(defn bool? [x] (or (instance? js/Boolean x) (true? x) (false? x)))\n"} {:sym *suppress-read*, :meta {}, :source "(def *suppress-read* false)\n"} {:sym *default-data-reader-fn*, :meta {}, :source "(def\n *default-data-reader-fn*\n \"When no data reader is found for a tag and *default-data-reader-fn*\\n  is non-nil, it will be called with two arguments, the tag and the value.\\n  If *default-data-reader-fn* is nil (the default value), an exception\\n  will be thrown for the unknown tag.\"\n nil)\n"} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling", :arglists [[reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true.\\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\\n\\n   Opts is a persistent map with valid keys:\\n    :read-cond - :allow to process reader conditionals, or\\n                 :preserve to keep all branches\\n    :features - persistent set of feature keywords for reader conditionals\\n    :eof - on eof, return value unless :eofthrow, then throw.\\n           if not specified, will throw\\n\\n   To read data structures only, use clojure.tools.reader.edn/read\\n\\n   Note that the function signature of clojure.tools.reader/read and\\n   clojure.tools.reader.edn/read is not the same for eof-handling\"\n {:arglists '([] [reader] [opts reader] [reader eof-error? eof-value])}\n ([reader] (read reader true nil))\n ([{eof :eof, :as opts, :or {eof :eofthrow}} reader]\n  (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n ([reader eof-error? sentinel]\n  (read* reader eof-error? sentinel nil {} (to-array []))))\n"} {:sym default-data-readers, :meta {}, :source "(def\n default-data-readers\n \"Default map of data reader functions provided by Clojure.\\n  May be overridden by binding *data-readers*\"\n {})\n"} {:sym *data-readers*, :meta {}, :source "(def\n *data-readers*\n \"Map from reader tag symbols to data reader Vars.\\n  Reader tags without namespace qualifiers are reserved for Clojure.\\n  This light version of tools.reader has no implementation for default\\n  reader tags such as #inst and #uuid.\"\n {})\n"} {:sym *read-delim*, :meta {}, :source "(def *read-delim* false)\n"} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :source "(defn\n resolve-symbol\n \"Resolve a symbol s into its fully qualified namespace version\"\n [s]\n (throw (ex-info \"resolve-symbol is not implemented\" {:sym s})))\n"} {:sym *alias-map*, :meta {}, :source "(def\n *alias-map*\n \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\\n   ns aliases.\\n\\n   Defaults to nil\"\n nil)\n"} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :source "(defn\n read-regex\n [rdr ch opts pending-forms]\n (let\n  [sb (StringBuffer.)]\n  (loop\n   [ch (read-char rdr)]\n   (if\n    (identical? \\\" ch)\n    (re-pattern (str sb))\n    (if\n     (nil? ch)\n     (err/throw-eof-reading rdr :regex sb)\n     (do\n      (.append sb ch)\n      (when\n       (identical? \\\\ ch)\n       (let\n        [ch (read-char rdr)]\n        (if (nil? ch) (err/throw-eof-reading rdr :regex sb))\n        (.append sb ch)))\n      (recur (read-char rdr))))))))\n"} {:sym sb, :meta {}, :source "(def sb (StringBuffer.))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   To read data structures only, use clojure.tools.reader.edn/read-string\\n\\n   Note that the function signature of clojure.tools.reader/read-string and\\n   clojure.tools.reader.edn/read-string is not the same for eof-handling\"\n ([s] (read-string {} s))\n ([opts s]\n  (when\n   (and s (not (identical? s \"\")))\n   (read opts (string-push-back-reader s)))))\n"} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :source "(defn\n map-func\n \"Decide which map type to use, array-map if less than 16 elements\"\n [coll]\n (if (>= (count coll) 16) 'cljs.core/hash-map 'cljs.core/array-map))\n"}), paren-soup.dom ({:sym top-level?, :meta {:doc nil, :arglists ([node])}, :source "(defn\n top-level?\n [node]\n (some-> node .-parentElement .-classList (.contains \"content\")))\n"} {:sym get-selection, :meta {:doc "Returns the objects related to selection for the given element. If full-selection? is true,\nit will use rangy instead of the native selection API in order to get the beginning and ending\nof the selection (it is, however, much slower).", :arglists ([element full-selection?])}, :source "(defn\n get-selection\n \"Returns the objects related to selection for the given element. If full-selection? is true,\\nit will use rangy instead of the native selection API in order to get the beginning and ending\\nof the selection (it is, however, much slower).\"\n [element full-selection?]\n {:element element,\n  :cursor-position\n  (cond\n   full-selection?\n   (let\n    [selection\n     (.getSelection js/rangy)\n     ranges\n     (.saveCharacterRanges selection element)]\n    (if-let\n     [char-range (some-> ranges (aget 0) (gobj/get \"characterRange\"))]\n     [(gobj/get char-range \"start\") (gobj/get char-range \"end\")]\n     [0 0]))\n   (= 0 (.-rangeCount (.getSelection js/window)))\n   [0 0]\n   :else\n   (let\n    [selection\n     (.getSelection js/window)\n     range\n     (.getRangeAt selection 0)\n     pre-caret-range\n     (doto\n      (.cloneRange range)\n      (.selectNodeContents element)\n      (.setEnd (.-endContainer range) (.-endOffset range)))\n     pos\n     (-> pre-caret-range .toString .-length)]\n    [pos pos]))})\n"} {:sym get-cursor-position, :meta {:doc "Returns the cursor position.", :arglists ([element full-selection?])}, :source "(defn\n get-cursor-position\n \"Returns the cursor position.\"\n [element full-selection?]\n (-> element (get-selection full-selection?) :cursor-position))\n"} {:sym text-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn text-node? [node] (= 3 (.-nodeType node)))\n"} {:sym get-focused-form, :meta {}, :source "(def get-focused-form (fn* [] (get-focused-elem \"collection\")))\n"} {:sym get-focused-top-level, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-focused-top-level\n []\n (when-let\n  [node (some-> js/rangy .getSelection .-anchorNode)]\n  (loop\n   [node node]\n   (if\n    (top-level? node)\n    node\n    (when-let [parent (.-parentElement node)] (recur parent))))))\n"} {:sym get-parent, :meta {:doc "Returns the nearest parent with the given class name.", :arglists ([node class-name])}, :source "(defn\n get-parent\n \"Returns the nearest parent with the given class name.\"\n [node class-name]\n (loop\n  [node node]\n  (when-let\n   [parent (.-parentElement node)]\n   (if\n    (.contains (.-classList parent) class-name)\n    parent\n    (recur parent)))))\n"} {:sym coll-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn\n coll-node?\n [node]\n (some-> node .-classList (.contains \"collection\")))\n"} {:sym get-nearest-ns, :meta {:doc nil, :arglists ([node])}, :source "(defn\n get-nearest-ns\n [node]\n (loop\n  [node node]\n  (if\n   (some-> node .-childNodes (.item 1) .-textContent (= \"ns\"))\n   (some-> node .-childNodes (.item 3) .-textContent symbol)\n   (when-let [sibling (.-previousSibling node)] (recur sibling)))))\n"} {:sym get-completion-info, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-completion-info\n []\n (when-let\n  [prefix-elem (get-focused-elem \"symbol\")]\n  (let\n   [pos\n    (-> prefix-elem (get-cursor-position false) first)\n    text\n    (.-textContent prefix-elem)\n    prefix\n    (subs text 0 pos)]\n   (assoc\n    (get-completion-context (count text) (count prefix))\n    :text\n    text\n    :prefix\n    prefix))))\n"} {:sym get-focused-elem, :meta {:doc nil, :arglists ([class-name])}, :source "(defn\n get-focused-elem\n [class-name]\n (some-> js/rangy .getSelection .-anchorNode (get-parent class-name)))\n"} {:sym error-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn error-node? [node] (some-> node .-classList (.contains \"error\")))\n"} {:sym get-completion-context, :meta {:doc nil, :arglists ([symbol-length cursor-offset])}, :source "(defn\n get-completion-context\n [symbol-length cursor-offset]\n (when-let\n  [top-level-elem (get-focused-top-level)]\n  (let\n   [pos\n    (-> top-level-elem (get-cursor-position false) first)\n    prefix-start\n    (- pos cursor-offset)\n    text\n    (.-textContent top-level-elem)]\n   {:ns (get-nearest-ns top-level-elem),\n    :context-before (subs text 0 prefix-start),\n    :context-after (subs text (+ prefix-start symbol-length)),\n    :start-position prefix-start})))\n"} {:sym common-ancestor, :meta {:doc "Returns the common ancestor of the given nodes.", :arglists ([first-node second-node])}, :source "(defn\n common-ancestor\n \"Returns the common ancestor of the given nodes.\"\n [first-node second-node]\n (let\n  [first-parent\n   (first (get-parents first-node \"collection\"))\n   second-parent\n   (first (get-parents second-node \"collection\"))]\n  (cond\n   (and first-parent second-parent (= first-parent second-parent))\n   first-parent\n   (and\n    (= first-node second-node)\n    (text-node? first-node)\n    (top-level? first-node))\n   first-node)))\n"} {:sym get-parents, :meta {:doc "Returns all the parents with the given class name.", :arglists ([node class-name])}, :source "(defn\n get-parents\n \"Returns all the parents with the given class name.\"\n [node class-name]\n (loop\n  [node node elems '()]\n  (if-let\n   [parent (get-parent node class-name)]\n   (recur parent (conj elems parent))\n   elems)))\n"} {:sym node?, :meta {}, :source "(def node? (fn* [p1__18509#] (instance? js/Node p1__18509#)))\n"}), reagent.ratom ({:sym make-track, :meta {:doc nil, :arglists ([f args])}, :source "(defn make-track [f args] (Track. f args nil))\n"} {:sym atom, :meta {:doc "Like clojure.core/atom, except that it keeps track of derefs.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Like clojure.core/atom, except that it keeps track of derefs.\"\n ([x] (->RAtom x nil nil nil))\n ([x & {:keys [meta validator]}] (->RAtom x meta validator nil)))\n"} {:sym make-wrapper, :meta {:doc nil, :arglists ([value callback-fn args])}, :source "(defn\n make-wrapper\n [value callback-fn args]\n (->Wrapper value (util/make-partial-fn callback-fn args) false nil))\n"} {:sym IReactiveAtom, :meta {:doc nil}, :methods ()} {:sym track, :meta {:doc nil, :arglists ([f & args])}, :source "(defn track [f & args] {:pre [(ifn? f)]} (make-track f args))\n"} {:sym dispose!, :meta {:doc nil, :arglists ([this])}, :protocol IDisposable} {:sym run, :meta {:doc nil, :arglists ([this])}, :protocol IRunnable} {:sym add-on-dispose!, :meta {:doc nil, :arglists ([this f])}, :protocol IDisposable} {:sym make-track!, :meta {:doc nil, :arglists ([f args])}, :source "(defn\n make-track!\n [f args]\n (let\n  [t\n   (make-track f args)\n   r\n   (make-reaction (fn* [] (-deref t)) :auto-run true)]\n  @r\n  r))\n"} {:sym run-in-reaction, :meta {:doc nil, :arglists ([f obj key run opts])}, :source "(defn\n run-in-reaction\n [f obj key run opts]\n (let\n  [r temp-reaction res (deref-capture f r)]\n  (when-not\n   (nil? (.-watching r))\n   (set! temp-reaction (make-reaction nil))\n   (._set-opts r opts)\n   (set! (.-f r) f)\n   (set! (.-auto-run r) (fn* [] (run obj)))\n   (aset obj key r))\n  res))\n"} {:sym IDisposable, :meta {:doc nil}, :methods (add-on-dispose! dispose!)} {:sym with-let-destroy, :meta {:doc nil, :arglists ([v])}, :source "(defn with-let-destroy [v] (when-some [f (.-destroy v)] (f)))\n"} {:sym make-reaction, :meta {:doc nil, :arglists ([f & {:keys [auto-run on-set on-dispose]}])}, :source "(defn\n make-reaction\n [f & {:keys [auto-run on-set on-dispose]}]\n (let\n  [reaction (->Reaction f nil true false nil nil nil nil)]\n  (._set-opts\n   reaction\n   {:auto-run auto-run, :on-set on-set, :on-dispose on-dispose})\n  reaction))\n"} {:sym flush!, :meta {:doc nil, :arglists ([])}, :source "(defn\n flush!\n []\n (loop\n  []\n  (let\n   [q rea-queue]\n   (when-not\n    (nil? q)\n    (set! rea-queue nil)\n    (dotimes [i (alength q)] (._queued-run (aget q i)))\n    (recur)))))\n"} {:sym debug, :meta {}, :source "(defonce debug false)\n"} {:sym cursor, :meta {:doc nil, :arglists ([src path])}, :source "(defn\n cursor\n [src path]\n (assert\n  (or\n   (satisfies? IReactiveAtom src)\n   (and (ifn? src) (not (vector? src))))\n  (str \"src must be a reactive atom or a function, not \" (pr-str src)))\n (->RCursor src path nil nil nil))\n"} {:sym running, :meta {:doc nil, :arglists ([])}, :source "(defn running [] (+ @-running))\n"} {:sym IRunnable, :meta {:doc nil}, :methods (run)} {:sym reactive?, :meta {:doc nil, :arglists ([])}, :source "(defn reactive? [] (some? *ratom-context*))\n"} {:sym with-let-values, :meta {:doc nil, :arglists ([key])}, :source "(defn\n with-let-values\n [key]\n (if-some\n  [c *ratom-context*]\n  (cached-reaction array c key nil with-let-destroy)\n  (array)))\n"} {:sym track!, :meta {:doc nil, :arglists ([f & args])}, :source "(defn track! [f & args] {:pre [(ifn? f)]} (make-track! f args))\n"} {:sym check-derefs, :meta {:doc nil, :arglists ([f])}, :source "(defn\n check-derefs\n [f]\n (let\n  [ctx (js-obj) res (in-context ctx f)]\n  [res (some? (.-captured ctx))]))\n"}), oakcljs.tools.reader.impl.errors ({:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-dispatch\n [rdr ch]\n (reader-error rdr \"No dispatch macro for \" ch \".\"))\n"} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-escape\n [rdr ch]\n (reader-error rdr \"Invalid unicode escape: \\\\u\" ch \".\"))\n"} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :source "(defn\n throw-dup-keys\n [rdr kind ks]\n (reader-error\n  rdr\n  (duplicate-keys-error\n   (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n   ks)))\n"} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-bad-ns\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Invalid value used as namespace in namespaced map: \"\n  ns-name\n  \".\"))\n"} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-unknown-reader-tag\n [rdr tag]\n (reader-error rdr \"No reader function for tag \" (i/inspect tag) \".\"))\n"} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-at-dispatch\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n"} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :source "(defn\n throw-bad-metadata-target\n [rdr target]\n (reader-error\n  rdr\n  \"Metadata can not be applied to \"\n  (i/inspect target)\n  \". \"\n  \"Metadata can only be applied to IMetas.\"))\n"} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-number\n [rdr token]\n (reader-error rdr \"Invalid number: \" token \".\"))\n"} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n reader-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :reader-error (apply str msgs)))\n"} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-literal\n [rdr token]\n (throw\n  (illegal-arg-error rdr \"Invalid unicode literal: \\\\\" token \".\")))\n"} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-ns-map-no-map\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Namespaced map with namespace \"\n  ns-name\n  \" does not specify a map.\"))\n"} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-unsupported-character\n [rdr token]\n (reader-error rdr \"Unsupported character: \" token \".\"))\n"} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :source "(defn\n throw-feature-not-keyword\n [rdr feature]\n (reader-error\n  rdr\n  \"Feature cannot be \"\n  (i/inspect feature)\n  \" Features must be keywords.\"))\n"} {:sym throw-eof-delimited, :meta {:doc nil, :arglists [[rdr kind column line] [rdr kind line column n]]}, :source "(defn\n throw-eof-delimited\n ([rdr kind column line]\n  (throw-eof-delimited rdr kind line column nil))\n ([rdr kind line column n]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading \"\n   (if n (str \"item \" n \" of \"))\n   (name kind)\n   (if line (str \", starting at line \" line \" and column \" column))\n   \".\")))\n"} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-in-character\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading character.\"))\n"} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :source "(defn\n throw-bad-char\n [rdr kind ch]\n (reader-error\n  rdr\n  \"Invalid character: \"\n  ch\n  \" found while reading \"\n  (name kind)\n  \".\"))\n"} {:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n eof-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :eof (apply str msgs)))\n"} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :source "(defn\n throw-bad-metadata\n [rdr x]\n (reader-error\n  rdr\n  \"Metadata cannot be \"\n  (i/inspect x)\n  \". Metadata must be a Symbol, Keyword, String or Map.\"))\n"} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :source "(defn\n throw-eof-reading\n [rdr kind & start]\n (let\n  [init (case kind :regex \"#\\\"\" :string \\\")]\n  (eof-error\n   rdr\n   \"Unexpected EOF reading \"\n   (name kind)\n   \" starting \"\n   (apply str init start)\n   \".\")))\n"} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :source "(defn\n throw-eof-error\n [rdr line]\n (if\n  line\n  (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n  (eof-error rdr \"EOF while reading.\")))\n"} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n illegal-arg-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :illegal-argument (apply str msgs)))\n"} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-octal-len\n [rdr token]\n (reader-error\n  rdr\n  \"Invalid octal escape sequence in a character literal:\"\n  token\n  \". Octal escape sequences must be 3 or fewer digits.\"))\n"} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-digit\n [rdr ch]\n (illegal-arg-error rdr \"Invalid digit \" ch \" in unicode character.\"))\n"} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :source "(defn\n throw-invalid-unicode-digit-in-token\n [rdr ch token]\n (illegal-arg-error\n  rdr\n  \"Invalid digit \"\n  ch\n  \" in unicode character \\\\\"\n  token\n  \".\"))\n"} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :source "(defn\n throw-invalid-unicode-len\n [rdr actual expected]\n (illegal-arg-error\n  rdr\n  \"Invalid unicode literal. Unicode literals should be \"\n  expected\n  \"characters long.  \"\n  \"value suppled is \"\n  actual\n  \"characters long.\"))\n"} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-single-colon\n [rdr]\n (reader-error rdr \"A single colon is not a valid keyword.\"))\n"} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :source "(defn\n throw-odd-map\n [rdr line col elements]\n (reader-error\n  rdr\n  \"The map literal starting with \"\n  (i/inspect (first elements))\n  (if line (str \" on line \" line \" column \" col))\n  \" contains \"\n  (count elements)\n  \" form(s). Map literals must contain an even number of forms.\"))\n"} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-bad-octal-number\n [rdr]\n (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n"} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-bad-reader-tag\n [rdr tag]\n (reader-error\n  rdr\n  \"Invalid reader tag: \"\n  (i/inspect tag)\n  \". Reader tags must be symbols.\"))\n"} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-unmatch-delimiter\n [rdr ch]\n (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n"} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-character-literal\n [rdr token]\n (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n"} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-char\n [rdr token]\n (reader-error rdr \"Invalid unicode character \\\\\" token \".\"))\n"} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-escape-char\n [rdr ch]\n (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n"} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn throw-no-dispatch [rdr ch] (throw-bad-dispatch rdr ch))\n"} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :source "(defn\n throw-eof-at-start\n [rdr kind]\n (eof-error\n  rdr\n  \"Unexpected EOF while reading start of \"\n  (name kind)\n  \".\"))\n"} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :source "(defn\n throw-invalid\n [rdr kind token]\n (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n"}), reagent.core ({:sym after-render, :meta {:doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just after any queued renders in the next animation\n  frame (and even if no renders actually occur).", :arglists ([f])}, :source "(defn\n after-render\n \"Run f using requestAnimationFrame or equivalent.\\n\\n  f will be called just after any queued renders in the next animation\\n  frame (and even if no renders actually occur).\"\n [f]\n (batch/do-after-render f))\n"} {:sym current-component, :meta {:doc "Returns the current React component (a.k.a this) in a component\n  function.", :arglists ([])}, :source "(defn\n current-component\n \"Returns the current React component (a.k.a this) in a component\\n  function.\"\n []\n comp/*current-component*)\n"} {:sym as-component, :meta {}, :source "(def as-component as-element)\n"} {:sym adapt-react-class, :meta {:doc "Returns an adapter for a native React class, that may be used\n  just like a Reagent component function or class in Hiccup forms.", :arglists [[c opts] [c]]}, :source "(defn\n adapt-react-class\n \"Returns an adapter for a native React class, that may be used\\n  just like a Reagent component function or class in Hiccup forms.\"\n ([c opts] (assert-some c \"Component\") (tmpl/adapt-react-class c opts))\n ([c] (adapt-react-class c {})))\n"} {:sym atom, :meta {:doc "Like clojure.core/atom, except that it keeps track of derefs.\n  Reagent components that derefs one of these are automatically\n  re-rendered.", :arglists [[x] [x & rest]]}, :source "(defn\n atom\n \"Like clojure.core/atom, except that it keeps track of derefs.\\n  Reagent components that derefs one of these are automatically\\n  re-rendered.\"\n ([x] (ratom/atom x))\n ([x & rest] (apply ratom/atom x rest)))\n"} {:sym merge-props, :meta {:doc "Utility function that merges two maps, handling :class and :style\n  specially, like React's transferPropsTo.", :arglists ([defaults props])}, :source "(defn\n merge-props\n \"Utility function that merges two maps, handling :class and :style\\n  specially, like React's transferPropsTo.\"\n [defaults props]\n (util/merge-props defaults props))\n"} {:sym force-update-all, :meta {:doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead.", :arglists ([])}, :source "(defn\n force-update-all\n \"Force re-rendering of all mounted Reagent components. This is\\n  probably only useful in a development environment, when you want to\\n  update components in response to some dynamic changes to code.\\n\\n  Note that force-update-all may not update root components. This\\n  happens if a component 'foo' is mounted with `(render [foo])` (since\\n  functions are passed by value, and not by reference, in\\n  ClojureScript). To get around this you'll have to introduce a layer\\n  of indirection, for example by using `(render [#'foo])` instead.\"\n []\n (ratom/flush!)\n (dom/force-update-all)\n (batch/flush-after-render))\n"} {:sym as-element, :meta {:doc "Turns a vector of Hiccup syntax into a React element. Returns form\n  unchanged if it is not a vector.", :arglists ([form])}, :source "(defn\n as-element\n \"Turns a vector of Hiccup syntax into a React element. Returns form\\n  unchanged if it is not a vector.\"\n [form]\n (tmpl/as-element form))\n"} {:sym rswap!, :meta {:doc "Swaps the value of a to be (apply f current-value-of-atom args).\n\n  rswap! works like swap!, except that recursive calls to rswap! on\n  the same atom are allowed – and it always returns nil.", :arglists ([a f & args])}, :source "(defn\n rswap!\n \"Swaps the value of a to be (apply f current-value-of-atom args).\\n\\n  rswap! works like swap!, except that recursive calls to rswap! on\\n  the same atom are allowed – and it always returns nil.\"\n [a f & args]\n {:pre [(satisfies? IAtom a) (ifn? f)]}\n (if\n  a.rswapping\n  (->\n   (or a.rswapfs (set! a.rswapfs (array)))\n   (.push (fn* [p1__18477#] (apply f p1__18477# args))))\n  (do\n   (set! a.rswapping true)\n   (try\n    (swap!\n     a\n     (fn\n      [state]\n      (loop\n       [s (apply f state args)]\n       (if-some [sf (some-> a.rswapfs .shift)] (recur (sf s)) s))))\n    (finally (set! a.rswapping false)))))\n nil)\n"} {:sym next-tick, :meta {:doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just before components are rendered.", :arglists ([f])}, :source "(defn\n next-tick\n \"Run f using requestAnimationFrame or equivalent.\\n\\n  f will be called just before components are rendered.\"\n [f]\n (batch/do-before-flush f))\n"} {:sym track, :meta {:doc "Takes a function and optional arguments, and returns a derefable\n  containing the output of that function. If the function derefs\n  Reagent atoms (or track, etc), the value will be updated whenever\n  the atom changes.\n\n  In other words, @(track foo bar) will produce the same result\n  as (foo bar), but foo will only be called again when the atoms it\n  depends on changes, and will only trigger updates of components when\n  its result changes.\n\n  track is lazy, i.e the function is only evaluated on deref.", :arglists ([f & args])}, :source "(defn\n track\n \"Takes a function and optional arguments, and returns a derefable\\n  containing the output of that function. If the function derefs\\n  Reagent atoms (or track, etc), the value will be updated whenever\\n  the atom changes.\\n\\n  In other words, @(track foo bar) will produce the same result\\n  as (foo bar), but foo will only be called again when the atoms it\\n  depends on changes, and will only trigger updates of components when\\n  its result changes.\\n\\n  track is lazy, i.e the function is only evaluated on deref.\"\n [f & args]\n {:pre [(ifn? f)]}\n (ratom/make-track f args))\n"} {:sym props, :meta {:doc "Returns the props passed to a component.", :arglists ([this])}, :source "(defn\n props\n \"Returns the props passed to a component.\"\n [this]\n (assert-component this)\n (comp/get-props this))\n"} {:sym dispose!, :meta {:doc "Stop the result of track! from updating.", :arglists ([x])}, :source "(defn\n dispose!\n \"Stop the result of track! from updating.\"\n [x]\n (ratom/dispose! x))\n"} {:sym state-atom, :meta {:doc "Returns an atom containing a components state.", :arglists ([this])}, :source "(defn\n state-atom\n \"Returns an atom containing a components state.\"\n [this]\n (assert-component this)\n (comp/state-atom this))\n"} {:sym flush, :meta {:doc "Render dirty components immediately to the DOM.\n\n  Note that this may not work in event handlers, since React.js does\n  batching of updates there.", :arglists ([])}, :source "(defn\n flush\n \"Render dirty components immediately to the DOM.\\n\\n  Note that this may not work in event handlers, since React.js does\\n  batching of updates there.\"\n []\n (batch/flush))\n"} {:sym children, :meta {:doc "Returns the children passed to a component.", :arglists ([this])}, :source "(defn\n children\n \"Returns the children passed to a component.\"\n [this]\n (assert-component this)\n (comp/get-children this))\n"} {:sym wrap, :meta {:doc "Provide a combination of value and callback, that looks like an atom.\n\n  The first argument can be any value, that will be returned when the\n  result is deref'ed.\n\n  The second argument should be a function, that is called with the\n  optional extra arguments provided to wrap, and the new value of the\n  resulting 'atom'.\n\n  Use for example like this:\n\n  (wrap (:foo @state)\n        swap! state assoc :foo)\n\n  Probably useful only for passing to child components.", :arglists ([value reset-fn & args])}, :source "(defn\n wrap\n \"Provide a combination of value and callback, that looks like an atom.\\n\\n  The first argument can be any value, that will be returned when the\\n  result is deref'ed.\\n\\n  The second argument should be a function, that is called with the\\n  optional extra arguments provided to wrap, and the new value of the\\n  resulting 'atom'.\\n\\n  Use for example like this:\\n\\n  (wrap (:foo @state)\\n        swap! state assoc :foo)\\n\\n  Probably useful only for passing to child components.\"\n [value reset-fn & args]\n (assert-callable reset-fn)\n (ratom/make-wrapper value reset-fn args))\n"} {:sym reactify-component, :meta {:doc "Returns an adapter for a Reagent component, that may be used from\n  React, for example in JSX. A single argument, props, is passed to\n  the component, converted to a map.", :arglists ([c])}, :source "(defn\n reactify-component\n \"Returns an adapter for a Reagent component, that may be used from\\n  React, for example in JSX. A single argument, props, is passed to\\n  the component, converted to a map.\"\n [c]\n (assert-some c \"Component\")\n (comp/reactify-component c))\n"} {:sym unmount-component-at-node, :meta {:doc "Remove a component from the given DOM node.", :arglists ([container])}, :source "(defn\n unmount-component-at-node\n \"Remove a component from the given DOM node.\"\n [container]\n (dom/unmount-component-at-node container))\n"} {:sym render-component, :meta {}, :source "(def render-component render)\n"} {:sym component-path, :meta {:doc nil, :arglists ([c])}, :source "(defn component-path [c] (comp/component-path c))\n"} {:sym cursor, :meta {:doc "Provide a cursor into a Reagent atom.\n\n  Behaves like a Reagent atom but focuses updates and derefs to\n  the specified path within the wrapped Reagent atom. e.g.,\n    (let [c (cursor ra [:nested :content])]\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n      )\n\n  The first parameter can also be a function, that should look\n  something like this:\n\n    (defn set-get\n      ([k] (get-in @state k))\n      ([k v] (swap! state assoc-in k v)))\n\n  The function will be called with one argument – the path passed to\n  cursor – when the cursor is deref'ed, and two arguments (path and\n  new value) when the cursor is modified.\n\n  Given that set-get function, (and that state is a Reagent atom, or\n  another cursor) these cursors are equivalent:\n  (cursor state [:foo]) and (cursor set-get [:foo]).\n\n  Note that a cursor is lazy: its value will not change until it is\n  used. This may be noticed with add-watch.", :arglists [[src path]]}, :source "(defn\n cursor\n \"Provide a cursor into a Reagent atom.\\n\\n  Behaves like a Reagent atom but focuses updates and derefs to\\n  the specified path within the wrapped Reagent atom. e.g.,\\n    (let [c (cursor ra [:nested :content])]\\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\\n      )\\n\\n  The first parameter can also be a function, that should look\\n  something like this:\\n\\n    (defn set-get\\n      ([k] (get-in @state k))\\n      ([k v] (swap! state assoc-in k v)))\\n\\n  The function will be called with one argument – the path passed to\\n  cursor – when the cursor is deref'ed, and two arguments (path and\\n  new value) when the cursor is modified.\\n\\n  Given that set-get function, (and that state is a Reagent atom, or\\n  another cursor) these cursors are equivalent:\\n  (cursor state [:foo]) and (cursor set-get [:foo]).\\n\\n  Note that a cursor is lazy: its value will not change until it is\\n  used. This may be noticed with add-watch.\"\n ([src path] (ratom/cursor src path)))\n"} {:sym state, :meta {:doc "Returns the state of a component, as set with replace-state or set-state.\n  Equivalent to (deref (r/state-atom this))", :arglists ([this])}, :source "(defn\n state\n \"Returns the state of a component, as set with replace-state or set-state.\\n  Equivalent to (deref (r/state-atom this))\"\n [this]\n (assert-component this)\n (deref (state-atom this)))\n"} {:sym dom-node, :meta {:doc "Returns the root DOM node of a mounted component.", :arglists ([this])}, :source "(defn\n dom-node\n \"Returns the root DOM node of a mounted component.\"\n [this]\n (dom/dom-node this))\n"} {:sym track!, :meta {:doc "An eager version of track. The function passed is called\n  immediately, and continues to be called when needed, until stopped\n  with dispose!.", :arglists ([f & args])}, :source "(defn\n track!\n \"An eager version of track. The function passed is called\\n  immediately, and continues to be called when needed, until stopped\\n  with dispose!.\"\n [f & args]\n {:pre [(ifn? f)]}\n (ratom/make-track! f args))\n"} {:sym is-client, :meta {}, :source "(def is-client util/is-client)\n"} {:sym replace-state, :meta {:doc "Set state of a component.\n  Equivalent to (reset! (state-atom this) new-state)", :arglists ([this new-state])}, :source "(defn\n replace-state\n \"Set state of a component.\\n  Equivalent to (reset! (state-atom this) new-state)\"\n [this new-state]\n (assert-component this)\n (assert-new-state new-state)\n (reset! (state-atom this) new-state))\n"} {:sym partial, :meta {:doc "Works just like clojure.core/partial, but the result can be compared with =", :arglists ([f & args])}, :source "(defn\n partial\n \"Works just like clojure.core/partial, but the result can be compared with =\"\n [f & args]\n (util/make-partial-fn f args))\n"} {:sym set-state, :meta {:doc "Merge component state with new-state.\n  Equivalent to (swap! (state-atom this) merge new-state)", :arglists ([this new-state])}, :source "(defn\n set-state\n \"Merge component state with new-state.\\n  Equivalent to (swap! (state-atom this) merge new-state)\"\n [this new-state]\n (assert-component this)\n (assert-new-state new-state)\n (swap! (state-atom this) merge new-state))\n"} {:sym argv, :meta {:doc "Returns the entire Hiccup form passed to the component.", :arglists ([this])}, :source "(defn\n argv\n \"Returns the entire Hiccup form passed to the component.\"\n [this]\n (assert-component this)\n (comp/get-argv this))\n"} {:sym render, :meta {:doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element.\n  The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance.", :arglists [[comp container] [comp container callback]]}, :source "(defn\n render\n \"Render a Reagent component into the DOM. The first argument may be\\n  either a vector (using Reagent's Hiccup syntax), or a React element.\\n  The second argument should be a DOM node.\\n\\n  Optionally takes a callback that is called when the component is in place.\\n\\n  Returns the mounted component instance.\"\n ([comp container] (dom/render comp container))\n ([comp container callback] (dom/render comp container callback)))\n"} {:sym force-update, :meta {:doc "Force a component to re-render immediately.\n\n  If the second argument is true, child components will also be\n  re-rendered, even is their arguments have not changed.", :arglists [[this] [this deep]]}, :source "(defn\n force-update\n \"Force a component to re-render immediately.\\n\\n  If the second argument is true, child components will also be\\n  re-rendered, even is their arguments have not changed.\"\n ([this] (force-update this false))\n ([this deep]\n  (ratom/flush!)\n  (util/force-update this deep)\n  (batch/flush-after-render)))\n"} {:sym create-class, :meta {:doc "Create a component, React style. Should be called with a map,\n  looking like this:\n\n    {:get-initial-state (fn [this])\n     :component-will-receive-props (fn [this new-argv])\n     :should-component-update (fn [this old-argv new-argv])\n     :component-will-mount (fn [this])\n     :component-did-mount (fn [this])\n     :component-will-update (fn [this new-argv])\n     :component-did-update (fn [this old-argv])\n     :component-will-unmount (fn [this])\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\n\n  Everything is optional, except either :reagent-render or :render.", :arglists ([spec])}, :source "(defn\n create-class\n \"Create a component, React style. Should be called with a map,\\n  looking like this:\\n\\n    {:get-initial-state (fn [this])\\n     :component-will-receive-props (fn [this new-argv])\\n     :should-component-update (fn [this old-argv new-argv])\\n     :component-will-mount (fn [this])\\n     :component-did-mount (fn [this])\\n     :component-will-update (fn [this new-argv])\\n     :component-did-update (fn [this old-argv])\\n     :component-will-unmount (fn [this])\\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\\n\\n  Everything is optional, except either :reagent-render or :render.\"\n [spec]\n (comp/create-class spec))\n"} {:sym create-element, :meta {:doc "Create a native React element, by calling React.createElement directly.\n\n  That means the second argument must be a javascript object (or nil), and\n  that any Reagent hiccup forms must be processed with as-element. For example\n  like this:\n\n    (r/create-element \"div\" #js{:className \"foo\"}\n       \"Hi \" (r/as-element [:strong \"world!\"])\n\n  which is equivalent to\n\n    [:div.foo \"Hi\" [:strong \"world!\"]]", :arglists [[type] [type props] [type props child] [type props child & children]]}, :source "(defn\n create-element\n \"Create a native React element, by calling React.createElement directly.\\n\\n  That means the second argument must be a javascript object (or nil), and\\n  that any Reagent hiccup forms must be processed with as-element. For example\\n  like this:\\n\\n    (r/create-element \\\"div\\\" #js{:className \\\"foo\\\"}\\n       \\\"Hi \\\" (r/as-element [:strong \\\"world!\\\"])\\n\\n  which is equivalent to\\n\\n    [:div.foo \\\"Hi\\\" [:strong \\\"world!\\\"]]\"\n ([type] (create-element type nil))\n ([type props]\n  (assert-js-object props)\n  (react/createElement type props))\n ([type props child]\n  (assert-js-object props)\n  (react/createElement type props child))\n ([type props child & children]\n  (assert-js-object props)\n  (apply react/createElement type props child children)))\n"}), dynadoc.core ({:sym add-focus, :meta {:doc nil, :arglists ([form with-focus body])}, :source "(defn\n add-focus\n [form with-focus body]\n (if-let\n  [binding (with-focus->binding with-focus)]\n  (postwalk (fn [x] (if (= x binding) form x)) body)\n  form))\n"} {:sym clj-compiler-fn, :meta {:doc nil, :arglists ([example forms cb])}, :source "(defn\n clj-compiler-fn\n [example forms cb]\n (try\n  (.send\n   XhrIo\n   \"/eval\"\n   (fn\n    [e]\n    (if\n     (.isSuccess (.-target e))\n     (->>\n      (.. e -target getResponseText)\n      read-string\n      rest\n      (mapv\n       (fn*\n        [p1__18666#]\n        (if (vector? p1__18666#) (into-array p1__18666#) p1__18666#)))\n      cb)\n     (cb [])))\n   \"POST\"\n   (pr-str\n    (into\n     [(str \"(in-ns '\" (:ns-sym @*state) \")\")]\n     (mapv (partial transform (dissoc example :with-card)) forms))))\n  (catch js/Error _ (cb []))))\n"} {:sym version, :meta {}, :source "(def version \"1.4.0\")\n"} {:sym form->serializable, :meta {:doc "Converts the input to either a string or (if an error object) an array of data", :arglists ([form])}, :source "(defn\n form->serializable\n \"Converts the input to either a string or (if an error object) an array of data\"\n [form]\n (if\n  (instance? js/Error form)\n  (array\n   (or (some-> form .-cause .-message) (.-message form))\n   (.-fileName form)\n   (.-lineNumber form))\n  (pr-str form)))\n"} {:sym init-editor, :meta {:doc nil, :arglists ([elem])}, :source "(defn\n init-editor\n [elem]\n (when-let\n  [paren-soup (or (.querySelector elem \".paren-soup\") elem)]\n  (ps/init paren-soup (js->clj {:compiler-fn (fn [])}))))\n"} {:sym add-callback, :meta {:doc nil, :arglists ([form with-callback])}, :source "(defn\n add-callback\n [form with-callback]\n (list\n  'let\n  ['es-channel\n   '(dynadoc.aliases/chan)\n   with-callback\n   '(fn [data] (dynadoc.aliases/put! es-channel data))]\n  form\n  '(dynadoc.aliases/<!! es-channel)))\n"} {:sym *state, :meta {}, :source "(defonce *state (atom {}))\n"} {:sym cljs-compiler-fn, :meta {:doc nil, :arglists ([example forms cb])}, :source "(defn\n cljs-compiler-fn\n [example forms cb]\n (es/code->results\n  (into\n   [(str \"(ns \" (:ns-sym @*state) \")\")]\n   (mapv (partial transform example) forms))\n  (fn [results] (->> results rest (mapv form->serializable) cb))\n  {:custom-load (fn [opts cb] (cb {:lang :clj, :source \"\"}))}))\n"} {:sym transform, :meta {:doc nil, :arglists ([{:keys [body id with-focus with-card with-callback]} form-str])}, :source "(defn\n transform\n [{:keys [body id with-focus with-card with-callback]} form-str]\n (if\n  (or with-focus with-card with-callback)\n  (pr-str\n   (cond->\n    (read-string form-str)\n    (some? with-focus)\n    (add-focus with-focus body)\n    (some? with-card)\n    (add-card with-card id)\n    (some? with-callback)\n    (add-callback with-callback)))\n  form-str))\n"} {:sym init, :meta {:doc nil, :arglists ([])}, :source "(defn\n init\n []\n (swap!\n  *state\n  merge\n  (->\n   (.querySelector js/document \"#initial-state\")\n   .-textContent\n   read-string))\n (rum/mount (common/app *state) (.querySelector js/document \"#app\"))\n (let\n  [{:keys [static? dev? watcher]} @*state]\n  (when (and (not static?) (not dev?)) (check-version))\n  (swap!\n   *state\n   assoc\n   :cljs-started?\n   true\n   :exportable?\n   js/COMPILED\n   :init-editor\n   init-editor\n   :init-example-editor\n   init-example-editor\n   :watcher\n   (when-not js/COMPILED (or watcher (init-watcher!)))))\n (when\n  (:var-sym @*state)\n  (doseq\n   [button (-> js/document (.querySelectorAll \".button\") array-seq)]\n   (set! (.-display (.-style button)) \"inline-block\"))))\n"} {:sym add-card, :meta {:doc nil, :arglists ([form with-card id])}, :source "(defn\n add-card\n [form with-card id]\n (list 'let [with-card (list '.getElementById 'js/document id)] form))\n"} {:sym prod, :meta {:doc nil, :arglists ([])}, :source "(defn prod [] (swap! *state assoc :prod? true))\n"} {:sym check-version, :meta {:doc nil, :arglists ([])}, :source "(defn\n check-version\n []\n (.send\n  XhrIo\n  api-url\n  (fn\n   [e]\n   (when\n    (and\n     (.isSuccess (.-target e))\n     (->>\n      (.. e -target getResponseText)\n      (.parse js/JSON)\n      ((fn* [p1__18667#] (gobj/get p1__18667# \"latest_release\")))\n      (not= version)))\n    (swap! *state assoc :update? true)))\n  \"GET\"))\n"} {:sym api-url, :meta {}, :source "(def api-url \"https://clojars.org/api/artifacts/dynadoc\")\n"} {:sym with-focus->binding, :meta {:doc nil, :arglists ([with-focus])}, :source "(defn\n with-focus->binding\n [with-focus]\n (let\n  [{:keys [binding]} with-focus [binding-type binding-val] binding]\n  (when (= :sym binding-type) binding-val)))\n"} {:sym init-example-editor, :meta {:doc nil, :arglists ([elem example])}, :source "(defn\n init-example-editor\n [elem example]\n (when-let\n  [paren-soup (or (.querySelector elem \".paren-soup\") elem)]\n  (when-let\n   [content (.querySelector paren-soup \".content\")]\n   (set! (.-contentEditable content) true))\n  (ps/init\n   paren-soup\n   (js->clj\n    {:compiler-fn\n     (if\n      (= :clj (:type @*state))\n      (partial clj-compiler-fn example)\n      (partial cljs-compiler-fn example))}))))\n"} {:sym init-watcher!, :meta {:doc nil, :arglists ([])}, :source "(defn\n init-watcher!\n []\n (let\n  [protocol\n   (if (= (.-protocol js/location) \"https:\") \"wss:\" \"ws:\")\n   host\n   (-> js/window .-location .-host)\n   sock\n   (js/WebSocket. (str protocol \"//\" host \"/watch\"))]\n  (set!\n   (.-onopen sock)\n   (fn [event] (.send sock js/window.location.pathname)))\n  (set!\n   (.-onmessage sock)\n   (fn [event] (->> (.-data event) read-string (swap! *state merge))))\n  sock))\n"}), cljs.tools.reader.impl.errors ({:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-dispatch\n [rdr ch]\n (reader-error rdr \"No dispatch macro for \" ch \".\"))\n"} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-escape\n [rdr ch]\n (reader-error rdr \"Invalid unicode escape: \\\\u\" ch \".\"))\n"} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :source "(defn\n throw-dup-keys\n [rdr kind ks]\n (reader-error\n  rdr\n  (duplicate-keys-error\n   (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n   ks)))\n"} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-bad-ns\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Invalid value used as namespace in namespaced map: \"\n  ns-name\n  \".\"))\n"} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-unknown-reader-tag\n [rdr tag]\n (reader-error rdr \"No reader function for tag \" (i/inspect tag) \".\"))\n"} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-at-dispatch\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n"} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :source "(defn\n throw-bad-metadata-target\n [rdr target]\n (reader-error\n  rdr\n  \"Metadata can not be applied to \"\n  (i/inspect target)\n  \". \"\n  \"Metadata can only be applied to IMetas.\"))\n"} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-number\n [rdr token]\n (reader-error rdr \"Invalid number: \" token \".\"))\n"} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n reader-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :reader-error (apply str msgs)))\n"} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-literal\n [rdr token]\n (throw\n  (illegal-arg-error rdr \"Invalid unicode literal: \\\\\" token \".\")))\n"} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-ns-map-no-map\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Namespaced map with namespace \"\n  ns-name\n  \" does not specify a map.\"))\n"} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-unsupported-character\n [rdr token]\n (reader-error rdr \"Unsupported character: \" token \".\"))\n"} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :source "(defn\n throw-feature-not-keyword\n [rdr feature]\n (reader-error\n  rdr\n  \"Feature cannot be \"\n  (i/inspect feature)\n  \" Features must be keywords.\"))\n"} {:sym throw-eof-delimited, :meta {:doc nil, :arglists [[rdr kind column line] [rdr kind line column n]]}, :source "(defn\n throw-eof-delimited\n ([rdr kind column line]\n  (throw-eof-delimited rdr kind line column nil))\n ([rdr kind line column n]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading \"\n   (if n (str \"item \" n \" of \"))\n   (name kind)\n   (if line (str \", starting at line \" line \" and column \" column))\n   \".\")))\n"} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-in-character\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading character.\"))\n"} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :source "(defn\n throw-bad-char\n [rdr kind ch]\n (reader-error\n  rdr\n  \"Invalid character: \"\n  ch\n  \" found while reading \"\n  (name kind)\n  \".\"))\n"} {:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n eof-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :eof (apply str msgs)))\n"} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :source "(defn\n throw-bad-metadata\n [rdr x]\n (reader-error\n  rdr\n  \"Metadata cannot be \"\n  (i/inspect x)\n  \". Metadata must be a Symbol, Keyword, String or Map.\"))\n"} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :source "(defn\n throw-eof-reading\n [rdr kind & start]\n (let\n  [init (case kind :regex \"#\\\"\" :string \\\")]\n  (eof-error\n   rdr\n   \"Unexpected EOF reading \"\n   (name kind)\n   \" starting \"\n   (apply str init start)\n   \".\")))\n"} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :source "(defn\n throw-eof-error\n [rdr line]\n (if\n  line\n  (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n  (eof-error rdr \"EOF while reading.\")))\n"} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n illegal-arg-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :illegal-argument (apply str msgs)))\n"} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-octal-len\n [rdr token]\n (reader-error\n  rdr\n  \"Invalid octal escape sequence in a character literal:\"\n  token\n  \". Octal escape sequences must be 3 or fewer digits.\"))\n"} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-digit\n [rdr ch]\n (illegal-arg-error rdr \"Invalid digit \" ch \" in unicode character.\"))\n"} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :source "(defn\n throw-invalid-unicode-digit-in-token\n [rdr ch token]\n (illegal-arg-error\n  rdr\n  \"Invalid digit \"\n  ch\n  \" in unicode character \\\\\"\n  token\n  \".\"))\n"} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :source "(defn\n throw-invalid-unicode-len\n [rdr actual expected]\n (illegal-arg-error\n  rdr\n  \"Invalid unicode literal. Unicode literals should be \"\n  expected\n  \"characters long.  \"\n  \"value suppled is \"\n  actual\n  \"characters long.\"))\n"} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-single-colon\n [rdr]\n (reader-error rdr \"A single colon is not a valid keyword.\"))\n"} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :source "(defn\n throw-odd-map\n [rdr line col elements]\n (reader-error\n  rdr\n  \"The map literal starting with \"\n  (i/inspect (first elements))\n  (if line (str \" on line \" line \" column \" col))\n  \" contains \"\n  (count elements)\n  \" form(s). Map literals must contain an even number of forms.\"))\n"} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-bad-octal-number\n [rdr]\n (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n"} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-bad-reader-tag\n [rdr tag]\n (reader-error\n  rdr\n  \"Invalid reader tag: \"\n  (i/inspect tag)\n  \". Reader tags must be symbols.\"))\n"} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-unmatch-delimiter\n [rdr ch]\n (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n"} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-character-literal\n [rdr token]\n (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n"} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-char\n [rdr token]\n (reader-error rdr \"Invalid unicode character \\\\\" token \".\"))\n"} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-escape-char\n [rdr ch]\n (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n"} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn throw-no-dispatch [rdr ch] (throw-bad-dispatch rdr ch))\n"} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :source "(defn\n throw-eof-at-start\n [rdr kind]\n (eof-error\n  rdr\n  \"Unexpected EOF while reading start of \"\n  (name kind)\n  \".\"))\n"} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :source "(defn\n throw-invalid\n [rdr kind token]\n (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n"}), cljs.js ({:sym *load-fn*, :meta {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil."}, :source "(defonce *load-fn* (fn [m cb] (throw (js/Error. \"No *load-fn* set\"))))\n"} {:sym eval, :meta {:doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :arglists [[state form cb] [state form opts cb]]}, :source "(defn\n eval\n \"Evaluate a single ClojureScript form. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   form (s-expr)\\n     the ClojureScript source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the result of evalution. If unsuccessful the map will\\n     contain a key :error with an ex-info instance describing the cause of\\n     failure.\"\n ([state form cb] (eval state form nil cb))\n ([state form opts cb]\n  (eval*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   form\n   opts\n   cb)))\n"} {:sym compile-str, :meta {:doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n compile-str\n \"Compile ClojureScript source into JavaScript. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the compilation result (string). If unsuccessful the map\\n     will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (compile-str state source nil cb))\n ([state source name cb] (compile-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (compile-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*),\n    :*sm-data* (when (:source-map opts) (sm-data))}\n   source\n   name\n   opts\n   cb)))\n"} {:sym ns->relpath, :meta {:doc "Given a namespace as a symbol return the relative path sans extension", :arglists ([ns-sym])}, :source "(defn\n ns->relpath\n \"Given a namespace as a symbol return the relative path sans extension\"\n [ns-sym]\n (string/replace (ana/munge-path ns-sym) \\. \\/))\n"} {:sym *loaded*, :meta {}, :source "(def *loaded* (atom #{}))\n"} {:sym require, :meta {:doc nil, :arglists [[name cb] [name opts cb] [bound-vars name opts cb] [bound-vars name reload opts cb]]}, :source "(defn\n require\n ([name cb] (require name nil cb))\n ([name opts cb] (require nil name opts cb))\n ([bound-vars name opts cb] (require bound-vars name nil opts cb))\n ([bound-vars name reload opts cb]\n  (let\n   [bound-vars\n    (merge\n     {:*compiler* (env/default-compiler-env),\n      :*data-readers* tags/*cljs-data-readers*,\n      :*load-macros* (:load-macros opts true),\n      :*analyze-deps* (:analyze-deps opts true),\n      :*load-fn* (or (:load opts) *load-fn*),\n      :*eval-fn* (or (:eval opts) *eval-fn*)}\n     bound-vars)\n    aname\n    (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n   (when (= :reload reload) (swap! *loaded* disj aname))\n   (when (= :reload-all reload) (reset! *loaded* #{}))\n   (when\n    (:verbose opts)\n    (debug-prn\n     (str\n      \"Loading \"\n      name\n      (when (:macros-ns opts) \" macros\")\n      \" namespace\")))\n   (if-not\n    (contains? @*loaded* aname)\n    (let\n     [env (:*env* bound-vars)]\n     (try\n      ((:*load-fn* bound-vars)\n       {:name name,\n        :macros (:macros-ns opts),\n        :path (ns->relpath name)}\n       (fn\n        [resource]\n        (assert\n         (or (map? resource) (nil? resource))\n         \"*load-fn* may only return a map or nil\")\n        (if\n         resource\n         (let\n          [{:keys [lang source cache source-map file]} resource]\n          (condp\n           keyword-identical?\n           lang\n           :clj\n           (do\n            (pre-file-side-effects\n             (:*compiler* bound-vars)\n             aname\n             file\n             opts)\n            (eval-str*\n             bound-vars\n             source\n             name\n             (assoc opts :cljs-file file)\n             (fn\n              [res]\n              (post-file-side-effects file opts)\n              (if\n               (:error res)\n               (cb res)\n               (do (swap! *loaded* conj aname) (cb {:value true}))))))\n           :js\n           (process-macros-deps\n            bound-vars\n            cache\n            opts\n            (fn\n             [res]\n             (if\n              (:error res)\n              (cb res)\n              (process-libs-deps\n               bound-vars\n               cache\n               opts\n               (fn\n                [res]\n                (if\n                 (:error res)\n                 (cb res)\n                 (let\n                  [res\n                   (try\n                    ((:*eval-fn* bound-vars) resource)\n                    (when\n                     cache\n                     (load-analysis-cache!\n                      (:*compiler* bound-vars)\n                      aname\n                      cache)\n                     (ana/register-specs cache))\n                    (when\n                     source-map\n                     (load-source-map!\n                      (:*compiler* bound-vars)\n                      aname\n                      source-map))\n                    (catch\n                     :default\n                     cause\n                     (wrap-error\n                      (ana/error\n                       env\n                       (str \"Could not require \" name)\n                       cause))))]\n                  (if\n                   (:error res)\n                   (cb res)\n                   (do\n                    (swap! *loaded* conj aname)\n                    (cb {:value true}))))))))))\n           (cb\n            (wrap-error\n             (ana/error\n              env\n              (str\n               \"Invalid :lang specified \"\n               lang\n               \", only :clj or :js allowed\"))))))\n         (cb\n          (wrap-error\n           (ana/error\n            env\n            (ana/error-message\n             (if\n              (:macros-ns opts)\n              :undeclared-macros-ns\n              :undeclared-ns)\n             {:ns-sym name, :js-provide (cljs.core/name name)})))))))\n      (catch\n       :default\n       cause\n       (cb\n        (wrap-error\n         (ana/error env (str \"Could not require \" name) cause))))))\n    (cb {:value true})))))\n"} {:sym file->ns, :meta {:doc nil, :arglists ([file])}, :source "(defn\n file->ns\n [file]\n (let\n  [lib-name (subs (string/replace file \"/\" \".\") 0 (- (count file) 5))]\n  (symbol (demunge lib-name))))\n"} {:sym eval-str, :meta {:doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n eval-str\n \"Evalute ClojureScript source given as a string. The parameters:\\n\\n  state (atom)\\n    the compiler state\\n\\n  source (string)\\n    the ClojureScript source\\n\\n  name (symbol or string)\\n    optional, the name of the source\\n\\n  opts (map)\\n    compilation options.\\n\\n    :eval             - eval function to invoke, see *eval-fn*\\n    :load             - library resolution function, see *load-fn*\\n    :source-map       - set to true to generate inline source map information\\n    :cache-source     - optional, a function to run side-effects with the\\n                        compilation result prior to actual evalution. This function\\n                        takes two arguments, the first is the eval map, the source\\n                        will be under :source. The second argument is a callback of\\n                        one argument. If an error occurs an :error key should be\\n                        supplied.\\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                        (if set to true) or the def init value (if false). Default\\n                        is false.\\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                        to aget/aset. Logs for incorrect values if :warn, throws if\\n                        :error. Defaults to false.\\n    :static-fns       - employ static dispatch to specific function arities in\\n                        emitted JavaScript, as opposed to making use of the\\n                        `call` construct. Defaults to false.\\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                        unknown functions, but instead direct invokes via\\n                        `f(a0,a1...)`. Defaults to `false`.\\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                        at the moment.\\n    :ns               - optional, the namespace in which to evaluate the source.\\n    :verbose          - optional, emit details from compiler activity. Defaults to\\n                        false.\\n    :context          - optional, sets the context for the source. Possible values\\n                     are `:expr`, `:statement` and `:return`. Defaults to\\n                      `:expr`.\\n\\n  cb (function)\\n    callback, will be invoked with a map. If succesful the map will contain\\n    a :value key with the result of evaluation and :ns the current namespace.\\n    If unsuccessful will contain a :error key with an ex-info instance describing\\n    the cause of failure.\"\n ([state source cb] (eval-str state source nil cb))\n ([state source name cb] (eval-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (eval-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym js-eval, :meta {:doc "A default JavaScript evaluation function.", :arglists ([{:keys [source], :as resource}])}, :source "(defn\n js-eval\n \"A default JavaScript evaluation function.\"\n [{:keys [source], :as resource}]\n (js/eval source))\n"} {:sym load-source-map!, :meta {:doc nil, :arglists ([state ns sm-json])}, :source "(defn\n load-source-map!\n [state ns sm-json]\n (let\n  [sm (sm/decode (.parse js/JSON sm-json))]\n  (swap! state assoc-in [:source-maps ns] sm)))\n"} {:sym analyze-str, :meta {:doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n analyze-str\n \"Analyze ClojureScript source. The compiler state will be populated with\\n   the results of analyzes. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false).\\n                          Defaults to false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value, the actual value is not meaningful. If unsuccessful the\\n     map will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (analyze-str state source nil cb))\n ([state source name cb] (analyze-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (analyze-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*passes* (or (:passes opts) ana/*passes*),\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym *eval-fn*, :meta {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value."}, :source "(defonce *eval-fn* (fn [m] (throw (js/Error. \"No *eval-fn* set\"))))\n"}), rum.core ({:sym state, :meta {:doc "Given React component, returns Rum state associated with it", :arglists ([comp])}, :source "(defn\n state\n \"Given React component, returns Rum state associated with it\"\n [comp]\n (aget (.-state comp) \":rum/state\"))\n"} {:sym build-defcs, :meta {:doc nil, :arglists ([render-body mixins display-name])}, :source "(defn\n build-defcs\n [render-body mixins display-name]\n (let\n  [render\n   (fn [state] [(apply render-body state (:rum/args state)) state])]\n  (build-ctor render mixins display-name)))\n"} {:sym build-defcc, :meta {:doc nil, :arglists ([render-body mixins display-name])}, :source "(defn\n build-defcc\n [render-body mixins display-name]\n (let\n  [render\n   (fn\n    [state]\n    [(apply render-body (:rum/react-component state) (:rum/args state))\n     state])]\n  (build-ctor render mixins display-name)))\n"} {:sym request-render, :meta {:doc "Schedules react component to be rendered on next animation frame", :arglists ([component])}, :source "(defn\n request-render\n \"Schedules react component to be rendered on next animation frame\"\n [component]\n (when (empty? @render-queue) (schedule render))\n (vswap! render-queue conj component))\n"} {:sym mount, :meta {:doc "Add component to the DOM tree. Idempotent. Subsequent mounts will just update component", :arglists ([component node])}, :source "(defn\n mount\n \"Add component to the DOM tree. Idempotent. Subsequent mounts will just update component\"\n [component node]\n (js/ReactDOM.render component node)\n nil)\n"} {:sym unmount, :meta {:doc "Removes component from the DOM tree", :arglists ([node])}, :source "(defn\n unmount\n \"Removes component from the DOM tree\"\n [node]\n (js/ReactDOM.unmountComponentAtNode node))\n"}), cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n", :examples [{:doc "Sort using a specific keyword", :body (sort-by :year < [{:name "Lisp", :year 1959} {:name "Fortran", :year 1957} {:name "Smalltalk", :year 1972}]), :body-str "(sort-by\n :year\n <\n [{:name \"Lisp\", :year 1959}\n  {:name \"Fortran\", :year 1957}\n  {:name \"Smalltalk\", :year 1972}])\n", :id "cljs.core/sort-by/0"} {:doc "Sort numbers lexicographically", :body (sort-by str [5 18 83 23 40]), :body-str "(sort-by str [5 18 83 23 40])\n", :id "cljs.core/sort-by/1"}]} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__18661#] (apply f p1__18661#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym merge-with, :examples [{:body (do ["Combine all map values that have the same key"] (merge-with concat {:rubble ["Barney"], :flintstone ["Fred"]} {:rubble ["Betty"], :flintstone ["Wilma"]} {:rubble ["Bam-Bam"], :flintstone ["Pebbles"]})), :body-str "(do\n [\"Combine all map values that have the same key\"]\n (merge-with\n  concat\n  {:rubble [\"Barney\"], :flintstone [\"Fred\"]}\n  {:rubble [\"Betty\"], :flintstone [\"Wilma\"]}\n  {:rubble [\"Bam-Bam\"], :flintstone [\"Pebbles\"]}))\n", :id "cljs.core/merge-with/0"}]} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym take-while, :examples [{:body (do ["Get all the negative numbers up to the first non-negative"] (take-while neg? [-2 -1 0 -1 -2 3])), :body-str "(do\n [\"Get all the negative numbers up to the first non-negative\"]\n (take-while neg? [-2 -1 0 -1 -2 3]))\n", :id "cljs.core/take-while/0"}]} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n", :examples [{:doc "Add a name to a vector", :body (conj ["Alice" "Bob"] "Charlie"), :body-str "(conj [\"Alice\" \"Bob\"] \"Charlie\")\n", :id "cljs.core/conj/0"} {:doc "Add a number to a list", :body (conj (quote (2 3)) 1), :body-str "(conj '(2 3) 1)\n", :id "cljs.core/conj/1"} {:doc "Add a key-val pair to a hash map", :body (conj {:name "Alice"} [:age 30]), :body-str "(conj {:name \"Alice\"} [:age 30])\n", :id "cljs.core/conj/2"}]} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n", :examples [{:doc "Combine two seqs of unequal length", :body (interleave (repeat "a") [1 2 3]), :body-str "(interleave (repeat \"a\") [1 2 3])\n", :id "cljs.core/interleave/0"} {:doc "Create a map using two vectors", :body (apply assoc {} (interleave [:fruit :color :temp] ["grape" "red" "hot"])), :body-str "(apply\n assoc\n {}\n (interleave [:fruit :color :temp] [\"grape\" \"red\" \"hot\"]))\n", :id "cljs.core/interleave/1"}]} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__18662#] (not (sequential? p1__18662#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__18649#] (and (p1 p1__18649#) (p2 p1__18649#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__18650#]\n        (and (p1 p1__18650#) (p2 p1__18650#) (p3 p1__18650#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__18651#] (p1__18651# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__18652#] (and (p1__18652# x) (p1__18652# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__18653#]\n       (and (p1__18653# x) (p1__18653# y) (p1__18653# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__18654#] (every? p1__18654# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n", :examples [{:body (do ["Exclude languages with single character names"] (filter (fn* [p1__18668#] (> (count p1__18668#) 1)) ["Java" "Lisp" "Fortran" "C" "D" "C++"])), :body-str "(do\n [\"Exclude languages with single character names\"]\n (filter\n  (fn* [p1__18668#] (> (count p1__18668#) 1))\n  [\"Java\" \"Lisp\" \"Fortran\" \"C\" \"D\" \"C++\"]))\n", :id "cljs.core/filter/0"}]} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__18655#] (or (p1 p1__18655#) (p2 p1__18655#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__18656#]\n       (or (p1 p1__18656#) (p2 p1__18656#) (p3 p1__18656#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__18657#] (p1__18657# x)) ps))\n    ([x y]\n     (some (fn* [p1__18658#] (or (p1__18658# x) (p1__18658# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__18659#]\n       (or (p1__18659# x) (p1__18659# y) (p1__18659# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__18660#] (some p1__18660# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n", :examples [{:doc "Apply a function to a vector of arguments", :body (apply + [40 2]), :body-str "(apply + [40 2])\n", :id "cljs.core/apply/0"} {:doc "Apply a function to a list of arguments", :body (apply - (quote (50 5 3))), :body-str "(apply - '(50 5 3))\n", :id "cljs.core/apply/1"} {:doc "Apply a function to multiple collections of different types", :body (map (partial apply max) [[1 2 3 4] (quote (-1 0 1 2))]), :body-str "(map (partial apply max) [[1 2 3 4] '(-1 0 1 2)])\n", :id "cljs.core/apply/2"}]} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n", :examples [{:body (do ["Remove all non-vowel characters up to the first vowel"] (drop-while (complement #{\a \e \i \o \u}) "clojure")), :body-str "(do\n [\"Remove all non-vowel characters up to the first vowel\"]\n (drop-while (complement #{\\a \\e \\i \\o \\u}) \"clojure\"))\n", :id "cljs.core/drop-while/0"}]} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), cljs.tools.reader.reader-types ({:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n indexing-push-back-reader\n \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (indexing-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len] (indexing-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (IndexingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name)))\n"} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :source "(defn\n log-source*\n [reader f]\n (let\n  [buffer (:buffer @(.-frames reader))]\n  (try\n   (swap!\n    (.-frames reader)\n    update-in\n    [:offset]\n    conj\n    (.getLength buffer))\n   (let\n    [ret (f)]\n    (if\n     (implements? IMeta ret)\n     (merge-meta ret {:source (peek-source-log @(.-frames reader))})\n     ret))\n   (finally (swap! (.-frames reader) update-in [:offset] rest)))))\n"} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :source "(defn\n merge-meta\n \"Returns an object of the same type and value as `obj`, with its\\nmetadata merged over `m`.\"\n [obj m]\n (let\n  [orig-meta (meta obj)]\n  (with-meta obj (merge m (dissoc orig-meta :source)))))\n"} {:sym Reader, :meta {:doc nil}, :methods (peek-char read-char)} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n source-logging-push-back-reader\n \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (source-logging-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len]\n  (source-logging-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (SourceLoggingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name\n   (atom {:buffer (StringBuffer.), :offset '(0)}))))\n"} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :protocol IPushbackReader} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :protocol Reader} {:sym IPushbackReader, :meta {:doc nil}, :methods (unread)} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :source "(defn\n indexing-reader?\n \"Returns true if the reader satisfies IndexingReader\"\n [rdr]\n (implements? IndexingReader rdr))\n"} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists [[s]]}, :source "(defn\n string-reader\n \"Creates a StringReader from a given string\"\n ([s] (StringReader. s (count s) 0)))\n"} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :protocol Reader} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :protocol IndexingReader} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists [[rdr]]}, :source "(defn\n read-line\n \"Reads a line from the reader or from *in* if no reader is specified\"\n ([rdr]\n  (loop\n   [c (read-char rdr) s (StringBuffer.)]\n   (if (newline? c) (str s) (recur (read-char rdr) (.append s c))))))\n"} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists [[s] [s buf-len]]}, :source "(defn\n string-push-back-reader\n \"Creates a PushbackReader from a given string\"\n ([s] (string-push-back-reader s 1))\n ([s buf-len]\n  (PushbackReader.\n   (string-reader s)\n   (object-array buf-len)\n   buf-len\n   buf-len)))\n"} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :source "(defn\n line-start?\n \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n [rdr]\n (when (indexing-reader? rdr) (== 1 (get-column-number rdr))))\n"} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n source-logging-reader?\n [rdr]\n (instance? SourceLoggingPushbackReader rdr))\n"} {:sym IndexingReader, :meta {:doc nil}, :methods (get-column-number get-file-name get-line-number)} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :source "(defn\n node-readable-push-back-reader\n [readable]\n (PushbackReader.\n  (NodeReadableReader. readable nil)\n  (object-array 1)\n  1\n  1))\n"} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader}), paren-soup.console ({:sym create-console-history, :meta {:doc nil, :arglists ([])}, :source "(defn\n create-console-history\n []\n (atom {:current-line 0, :lines [], :start 0}))\n"} {:sym get-console-start, :meta {:doc nil, :arglists ([console-history])}, :source "(defn\n get-console-start\n [console-history]\n (-> console-history deref :start))\n"} {:sym update-console-start!, :meta {:doc nil, :arglists ([console-history start])}, :source "(defn\n update-console-start!\n [console-history start]\n (swap! console-history assoc :start start))\n"} {:sym update-console-history!, :meta {:doc "Updates the console history atom.", :arglists ([console-history line])}, :source "(defn\n update-console-history!\n \"Updates the console history atom.\"\n [console-history line]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (swap!\n   console-history\n   (fn\n    [console-history-map]\n    (let\n     [lines\n      (if\n       (and (seq line) (not= line (last lines)))\n       (conj lines line)\n       lines)]\n     (assoc\n      console-history-map\n      :current-line\n      (count lines)\n      :lines\n      lines))))))\n"} {:sym get-previous-line, :meta {:doc "Returns the previous line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n get-previous-line\n \"Returns the previous line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (get lines (dec current-line))))\n"} {:sym get-next-line, :meta {:doc "Returns the next line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n get-next-line\n \"Returns the next line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (get lines (inc current-line))))\n"} {:sym up!, :meta {:doc "Changes the current line and returns the previous line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n up!\n \"Changes the current line and returns the previous line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [line (get-previous-line console-history)]\n  (if\n   line\n   (swap! console-history update :current-line dec)\n   (swap! console-history assoc :current-line -1))\n  line))\n"} {:sym down!, :meta {:doc "Changes the current line and returns the next line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n down!\n \"Changes the current line and returns the next line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [line (get-next-line console-history)]\n  (if\n   line\n   (swap! console-history update :current-line inc)\n   (swap!\n    console-history\n    assoc\n    :current-line\n    (-> @console-history :lines count)))\n  line))\n"}), cljs.core.async ({:sym Pub, :meta {:doc nil}, :methods (sub* unsub* unsub-all*)} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :arglists ([f init ch])}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. Returns a channel containing\\n  the single result of applying f to init and the first item from the\\n  channel, then applying f to that result and the 2nd item, etc. If\\n  the channel closes without yielding items, returns init and f is not\\n  called. ch must close before reduce produces a result.\"\n [f init ch]\n (go-loop\n  [ret init]\n  (let\n   [v (<! ch)]\n   (if\n    (nil? v)\n    ret\n    (let [ret' (f ret v)] (if (reduced? ret') @ret' (recur ret')))))))\n"} {:sym remove>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n remove>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (filter> (complement p) ch))\n"} {:sym timeout, :meta {:doc "Returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"Returns a channel that will close after msecs\"\n [msecs]\n (timers/timeout msecs))\n"} {:sym unsub*, :meta {:doc nil, :arglists ([p v ch])}, :protocol Pub} {:sym admix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym unmix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym mix, :meta {:doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :arglists ([out])}, :source "(defn\n mix\n \"Creates and returns a mix of one or more input channels which will\\n  be put on the supplied out channel. Input sources can be added to\\n  the mix with 'admix', and removed with 'unmix'. A mix supports\\n  soloing, muting and pausing multiple inputs atomically using\\n  'toggle', and can solo using either muting or pausing as determined\\n  by 'solo-mode'.\\n\\n  Each channel can have zero or more boolean modes set via 'toggle':\\n\\n  :solo - when true, only this (ond other soloed) channel(s) will appear\\n          in the mix output channel. :mute and :pause states of soloed\\n          channels are ignored. If solo-mode is :mute, non-soloed\\n          channels are muted, if :pause, non-soloed channels are\\n          paused.\\n\\n  :mute - muted channels will have their contents consumed but not included in the mix\\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\\n\"\n [out]\n (let\n  [cs\n   (atom {})\n   solo-modes\n   #{:pause :mute}\n   attrs\n   (conj solo-modes :solo)\n   solo-mode\n   (atom :mute)\n   change\n   (chan)\n   changed\n   (fn* [] (put! change true))\n   pick\n   (fn\n    [attr chs]\n    (reduce-kv (fn [ret c v] (if (attr v) (conj ret c) ret)) #{} chs))\n   calc-state\n   (fn\n    []\n    (let\n     [chs\n      @cs\n      mode\n      @solo-mode\n      solos\n      (pick :solo chs)\n      pauses\n      (pick :pause chs)]\n     {:solos solos,\n      :mutes (pick :mute chs),\n      :reads\n      (conj\n       (if\n        (and (= mode :pause) (not (empty? solos)))\n        (vec solos)\n        (vec (remove pauses (keys chs))))\n       change)}))\n   m\n   (reify\n    Mux\n    (muxch* [_] out)\n    Mix\n    (admix* [_ ch] (swap! cs assoc ch {}) (changed))\n    (unmix* [_ ch] (swap! cs dissoc ch) (changed))\n    (unmix-all* [_] (reset! cs {}) (changed))\n    (toggle*\n     [_ state-map]\n     (swap! cs (partial merge-with cljs.core/merge) state-map)\n     (changed))\n    (solo-mode*\n     [_ mode]\n     (assert\n      (solo-modes mode)\n      (str \"mode must be one of: \" solo-modes))\n     (reset! solo-mode mode)\n     (changed)))]\n  (go-loop\n   [{:keys [solos mutes reads], :as state} (calc-state)]\n   (let\n    [[v c] (alts! reads)]\n    (if\n     (or (nil? v) (= c change))\n     (do (when (nil? v) (swap! cs dissoc c)) (recur (calc-state)))\n     (if\n      (or (solos c) (and (empty? solos) (not (mutes c))))\n      (when (>! out v) (recur state))\n      (recur state)))))\n  m))\n"} {:sym pub, :meta {:doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :arglists [[ch topic-fn] [ch topic-fn buf-fn]]}, :source "(defn\n pub\n \"Creates and returns a pub(lication) of the supplied channel,\\n  partitioned into topics by the topic-fn. topic-fn will be applied to\\n  each value on the channel and the result will determine the 'topic'\\n  on which that value will be put. Channels can be subscribed to\\n  receive copies of topics using 'sub', and unsubscribed using\\n  'unsub'. Each topic will be handled by an internal mult on a\\n  dedicated channel. By default these internal channels are\\n  unbuffered, but a buf-fn can be supplied which, given a topic,\\n  creates a buffer with desired properties.\\n\\n  Each item is distributed to all subs in parallel and synchronously,\\n  i.e. each sub must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow subs from holding up the pub.\\n\\n  Items received when there are no matching subs get dropped.\\n\\n  Note that if buf-fns are used then each topic is handled\\n  asynchronously, i.e. if a channel is subscribed to more than one\\n  topic it should not expect them to be interleaved identically with\\n  the source.\"\n ([ch topic-fn] (pub ch topic-fn (constantly nil)))\n ([ch topic-fn buf-fn]\n  (let\n   [mults\n    (atom {})\n    ensure-mult\n    (fn\n     [topic]\n     (or\n      (get @mults topic)\n      (get\n       (swap!\n        mults\n        (fn*\n         [p1__18543#]\n         (if\n          (p1__18543# topic)\n          p1__18543#\n          (assoc p1__18543# topic (mult (chan (buf-fn topic)))))))\n       topic)))\n    p\n    (reify\n     Mux\n     (muxch* [_] ch)\n     Pub\n     (sub*\n      [p topic ch close?]\n      (let [m (ensure-mult topic)] (tap m ch close?)))\n     (unsub*\n      [p topic ch]\n      (when-let [m (get @mults topic)] (untap m ch)))\n     (unsub-all* [_] (reset! mults {}))\n     (unsub-all* [_ topic] (swap! mults dissoc topic)))]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (doseq [m (vals @mults)] (close! (muxch* m)))\n      (let\n       [topic (topic-fn val) m (get @mults topic)]\n       (when\n        m\n        (when-not (>! (muxch* m) val) (swap! mults dissoc topic)))\n       (recur)))))\n   p)))\n"} {:sym take, :meta {:doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return chanel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n take\n \"Returns a channel that will return, at most, n items from ch. After n items\\n   have been returned, or ch has been closed, the return chanel will close.\\n\\n  The output channel is unbuffered by default, unless buf-or-n is given.\"\n ([n ch] (take n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [x 0]\n     (when\n      (< x n)\n      (let\n       [v (<! ch)]\n       (when (not (nil? v)) (>! out v) (recur (inc x))))))\n    (close! out))\n   out)))\n"} {:sym unsub-all*, :meta {:doc nil, :arglists ([p] [p v])}, :protocol Pub} {:sym <!, :meta {:doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.\n  Returns true unless port is already closed", :arglists ([port])}, :source "(defn\n <!\n \"takes a val from port. Must be called inside a (go ...) block. Will\\n  return nil if closed. Will park if nothing is available.\\n  Returns true unless port is already closed\"\n [port]\n (throw (js/Error. \"<! used not in (go ...) block\")))\n"} {:sym map, :meta {:doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :arglists [[f chs] [f chs buf-or-n]]}, :source "(defn\n map\n \"Takes a function and a collection of source channels, and returns a\\n  channel which contains the values produced by applying f to the set\\n  of first items taken from each source channel, followed by applying\\n  f to the set of second items from each channel, until any one of the\\n  channels is closed, at which point the output channel will be\\n  closed. The returned channel will be unbuffered by default, or a\\n  buf-or-n can be supplied\"\n ([f chs] (map f chs nil))\n ([f chs buf-or-n]\n  (let\n   [chs\n    (vec chs)\n    out\n    (chan buf-or-n)\n    cnt\n    (count chs)\n    rets\n    (object-array cnt)\n    dchan\n    (chan 1)\n    dctr\n    (atom nil)\n    done\n    (mapv\n     (fn\n      [i]\n      (fn\n       [ret]\n       (aset rets i ret)\n       (when (zero? (swap! dctr dec)) (put! dchan (.slice rets 0)))))\n     (range cnt))]\n   (go-loop\n    []\n    (reset! dctr cnt)\n    (dotimes\n     [i cnt]\n     (try\n      (take! (chs i) (done i))\n      (catch js/Object e (swap! dctr dec))))\n    (let\n     [rets (<! dchan)]\n     (if\n      (some nil? rets)\n      (close! out)\n      (do (>! out (apply f rets)) (recur)))))\n   out)))\n"} {:sym Mux, :meta {:doc nil}, :methods (muxch*)} {:sym mapcat>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f out] [f out buf-or-n]]}, :source "(defn\n mapcat>\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f out] (mapcat> f out nil))\n ([f out buf-or-n] (let [in (chan buf-or-n)] (mapcat* f in out) in)))\n"} {:sym buffer, :meta {:doc "Returns a fixed buffer of size n. When full, puts will block/park.", :arglists ([n])}, :source "(defn\n buffer\n \"Returns a fixed buffer of size n. When full, puts will block/park.\"\n [n]\n (buffers/fixed-buffer n))\n"} {:sym close!, :meta {:doc nil, :arglists [[port]]}, :source "(defn close! ([port] (impl/close! port)))\n"} {:sym offer!, :meta {:doc "Puts a val into port if it's possible to do so immediately.\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.", :arglists ([port val])}, :source "(defn\n offer!\n \"Puts a val into port if it's possible to do so immediately.\\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.\"\n [port val]\n (let\n  [ret (impl/put! port val (fn-handler nop false))]\n  (when ret @ret)))\n"} {:sym chan, :meta {:doc "Creates a channel with an optional buffer, an optional transducer (like (map f),\n  (filter p) etc or a composition thereof), and an optional exception handler.\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\n  transducer is supplied a buffer must be specified. ex-handler must be a\n  fn of one argument - if an exception occurs during transformation it will be called\n  with the thrown value as an argument, and any non-nil return value will be placed\n  in the channel.", :arglists [[] [buf-or-n] [buf-or-n xform] [buf-or-n xform ex-handler]]}, :source "(defn\n chan\n \"Creates a channel with an optional buffer, an optional transducer (like (map f),\\n  (filter p) etc or a composition thereof), and an optional exception handler.\\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\\n  transducer is supplied a buffer must be specified. ex-handler must be a\\n  fn of one argument - if an exception occurs during transformation it will be called\\n  with the thrown value as an argument, and any non-nil return value will be placed\\n  in the channel.\"\n ([] (chan nil))\n ([buf-or-n] (chan buf-or-n nil nil))\n ([buf-or-n xform] (chan buf-or-n xform nil))\n ([buf-or-n xform ex-handler]\n  (let\n   [buf-or-n (if (= buf-or-n 0) nil buf-or-n)]\n   (when\n    xform\n    (assert buf-or-n \"buffer must be supplied when transducer is\"))\n   (channels/chan\n    (if (number? buf-or-n) (buffer buf-or-n) buf-or-n)\n    xform\n    ex-handler))))\n"} {:sym solo-mode*, :meta {:doc nil, :arglists ([m mode])}, :protocol Mix} {:sym tap, :meta {:doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[mult ch] [mult ch close?]]}, :source "(defn\n tap\n \"Copies the mult source onto the supplied channel.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([mult ch] (tap mult ch true))\n ([mult ch close?] (tap* mult ch close?) ch))\n"} {:sym admix, :meta {:doc "Adds ch as an input to the mix", :arglists ([mix ch])}, :source "(defn admix \"Adds ch as an input to the mix\" [mix ch] (admix* mix ch))\n"} {:sym promise-chan, :meta {:doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :arglists [[] [xform] [xform ex-handler]]}, :source "(defn\n promise-chan\n \"Creates a promise channel with an optional transducer, and an optional\\n  exception-handler. A promise channel can take exactly one value that consumers\\n  will receive. Once full, puts complete but val is dropped (no transfer).\\n  Consumers will block until either a value is placed in the channel or the\\n  channel is closed. See chan for the semantics of xform and ex-handler.\"\n ([] (promise-chan nil))\n ([xform] (promise-chan xform nil))\n ([xform ex-handler] (chan (buffers/promise-buffer) xform ex-handler)))\n"} {:sym unique, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[ch] [ch buf-or-n]]}, :source "(defn\n unique\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([ch] (unique ch nil))\n ([ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [last nil]\n     (let\n      [v (<! ch)]\n      (when\n       (not (nil? v))\n       (if (= v last) (recur last) (do (>! out v) (recur v))))))\n    (close! out))\n   out)))\n"} {:sym muxch*, :meta {:doc nil, :arglists ([_])}, :protocol Mux} {:sym solo-mode, :meta {:doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :arglists ([mix mode])}, :source "(defn\n solo-mode\n \"Sets the solo mode of the mix. mode must be one of :mute or :pause\"\n [mix mode]\n (solo-mode* mix mode))\n"} {:sym transduce, :meta {:doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :arglists ([xform f init ch])}, :source "(defn\n transduce\n \"async/reduces a channel with a transformation (xform f).\\n  Returns a channel containing the result.  ch must close before\\n  transduce produces a result.\"\n [xform f init ch]\n (let [f (xform f)] (go (let [ret (<! (reduce f init ch))] (f ret)))))\n"} {:sym onto-chan, :meta {:doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :arglists [[ch coll] [ch coll close?]]}, :source "(defn\n onto-chan\n \"Puts the contents of coll into the supplied channel.\\n\\n  By default the channel will be closed after the items are copied,\\n  but can be determined by the close? parameter.\\n\\n  Returns a channel which will close after the items are copied.\"\n ([ch coll] (onto-chan ch coll true))\n ([ch coll close?]\n  (go-loop\n   [vs (seq coll)]\n   (if\n    (and vs (>! ch (first vs)))\n    (recur (next vs))\n    (when close? (close! ch))))))\n"} {:sym to-chan, :meta {:doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :arglists ([coll])}, :source "(defn\n to-chan\n \"Creates and returns a channel which contains the contents of coll,\\n  closing when exhausted.\"\n [coll]\n (let [ch (chan (bounded-count 100 coll))] (onto-chan ch coll) ch))\n"} {:sym dropping-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :arglists ([n])}, :source "(defn\n dropping-buffer\n \"Returns a buffer of size n. When full, puts will complete but\\n  val will be dropped (no transfer).\"\n [n]\n (buffers/dropping-buffer n))\n"} {:sym untap-all, :meta {:doc "Disconnects all target channels from a mult", :arglists ([mult])}, :source "(defn\n untap-all\n \"Disconnects all target channels from a mult\"\n [mult]\n (untap-all* mult))\n"} {:sym into, :meta {:doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :arglists ([coll ch])}, :source "(defn\n into\n \"Returns a channel containing the single (collection) result of the\\n  items taken from the channel conjoined to the supplied\\n  collection. ch must close before into produces a result.\"\n [coll ch]\n (reduce conj coll ch))\n"} {:sym pipeline, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes.\n\n  Note this is supplied for API compatibility with the Clojure version.\n  Values of N > 1 will not result in actual concurrency in a\n  single-threaded runtime.", :arglists [[n to xf from] [n to xf from close?] [n to xf from close? ex-handler]]}, :source "(defn\n pipeline\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the transducer xf, with parallelism n. Because\\n  it is parallel, the transducer will be applied independently to each\\n  element, not across elements, and may produce zero or more outputs\\n  per input.  Outputs will be returned in order relative to the\\n  inputs. By default, the to channel will be closed when the from\\n  channel closes, but can be determined by the close?  parameter. Will\\n  stop consuming the from channel if the to channel closes.\\n\\n  Note this is supplied for API compatibility with the Clojure version.\\n  Values of N > 1 will not result in actual concurrency in a\\n  single-threaded runtime.\"\n ([n to xf from] (pipeline n to xf from true))\n ([n to xf from close?] (pipeline n to xf from close? nil))\n ([n to xf from close? ex-handler]\n  (pipeline* n to xf from close? ex-handler :compute)))\n"} {:sym sub, :meta {:doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[p topic ch] [p topic ch close?]]}, :source "(defn\n sub\n \"Subscribes a channel to a topic of a pub.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([p topic ch] (sub p topic ch true))\n ([p topic ch close?] (sub* p topic ch close?)))\n"} {:sym map>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch (f val) fn1))))\n"} {:sym pipe, :meta {:doc "Takes elements from the from channel and supplies them to the to\n   channel. By default, the to channel will be closed when the from\n   channel closes, but can be determined by the close?  parameter. Will\n   stop consuming the from channel if the to channel closes", :arglists [[from to] [from to close?]]}, :source "(defn\n pipe\n \"Takes elements from the from channel and supplies them to the to\\n   channel. By default, the to channel will be closed when the from\\n   channel closes, but can be determined by the close?  parameter. Will\\n   stop consuming the from channel if the to channel closes\"\n ([from to] (pipe from to true))\n ([from to close?]\n  (go-loop\n   []\n   (let\n    [v (<! from)]\n    (if (nil? v) (when close? (close! to)) (when (>! to v) (recur)))))\n  to))\n"} {:sym unmix, :meta {:doc "Removes ch as an input to the mix", :arglists ([mix ch])}, :source "(defn\n unmix\n \"Removes ch as an input to the mix\"\n [mix ch]\n (unmix* mix ch))\n"} {:sym filter<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n filter<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (filter< p ch nil))\n ([p ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (close! out)\n      (do (when (p val) (>! out val)) (recur)))))\n   out)))\n"} {:sym sub*, :meta {:doc nil, :arglists ([p v ch close?])}, :protocol Pub} {:sym remove<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n remove<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (remove< p ch nil))\n ([p ch buf-or-n] (filter< (complement p) ch buf-or-n)))\n"} {:sym untap*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mult} {:sym toggle, :meta {:doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :arglists ([mix state-map])}, :source "(defn\n toggle\n \"Atomically sets the state(s) of one or more channels in a mix. The\\n  state map is a map of channels -> channel-state-map. A\\n  channel-state-map is a map of attrs -> boolean, where attr is one or\\n  more of :mute, :pause or :solo. Any states supplied are merged with\\n  the current state.\\n\\n  Note that channels can be added to a mix via toggle, which can be\\n  used to add channels in a particular (e.g. paused) state.\"\n [mix state-map]\n (toggle* mix state-map))\n"} {:sym untap-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mult} {:sym sliding-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :arglists ([n])}, :source "(defn\n sliding-buffer\n \"Returns a buffer of size n. When full, puts will complete, and be\\n  buffered, but oldest elements in buffer will be dropped (not\\n  transferred).\"\n [n]\n (buffers/sliding-buffer n))\n"} {:sym partition, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n partition\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([n ch] (partition n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [arr (make-array n) idx 0]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (do\n        (aset arr idx v)\n        (let\n         [new-idx (inc idx)]\n         (if\n          (< new-idx n)\n          (recur arr new-idx)\n          (do (>! out (vec arr)) (recur (make-array n) 0)))))\n       (do (when (> idx 0) (>! out (vec arr))) (close! out))))))\n   out)))\n"} {:sym Mult, :meta {:doc nil}, :methods (tap* untap* untap-all*)} {:sym merge, :meta {:doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :arglists [[chs] [chs buf-or-n]]}, :source "(defn\n merge\n \"Takes a collection of source channels and returns a channel which\\n  contains all values taken from them. The returned channel will be\\n  unbuffered by default, or a buf-or-n can be supplied. The channel\\n  will close after all the source channels have closed.\"\n ([chs] (merge chs nil))\n ([chs buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    [cs (vec chs)]\n    (if\n     (pos? (count cs))\n     (let\n      [[v c] (alts! cs)]\n      (if\n       (nil? v)\n       (recur (filterv (fn* [p1__18544#] (not= c p1__18544#)) cs))\n       (do (>! out v) (recur cs))))\n     (close! out)))\n   out)))\n"} {:sym partition-by, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f ch] [f ch buf-or-n]]}, :source "(defn\n partition-by\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f ch] (partition-by f ch nil))\n ([f ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [lst (make-array 0) last :clojure.core/nothing]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (let\n        [new-itm (f v)]\n        (if\n         (or\n          (= new-itm last)\n          (keyword-identical? last :clojure.core/nothing))\n         (do (.push lst v) (recur lst new-itm))\n         (do\n          (>! out (vec lst))\n          (let\n           [new-lst (make-array 0)]\n           (.push new-lst v)\n           (recur new-lst new-itm)))))\n       (do\n        (when (> (alength lst) 0) (>! out (vec lst)))\n        (close! out))))))\n   out)))\n"} {:sym unsub-all, :meta {:doc "Unsubscribes all channels from a pub, or a topic of a pub", :arglists [[p] [p topic]]}, :source "(defn\n unsub-all\n \"Unsubscribes all channels from a pub, or a topic of a pub\"\n ([p] (unsub-all* p))\n ([p topic] (unsub-all* p topic)))\n"} {:sym >!, :meta {:doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :arglists ([port val])}, :source "(defn\n >!\n \"puts a val into port. nil values are not allowed. Must be called\\n  inside a (go ...) block. Will park if no buffer space is available.\\n  Returns true unless port is already closed.\"\n [port val]\n (throw (js/Error. \">! used not in (go ...) block\")))\n"} {:sym unmix-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mix} {:sym split, :meta {:doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :arglists [[p ch] [p ch t-buf-or-n f-buf-or-n]]}, :source "(defn\n split\n \"Takes a predicate and a source channel and returns a vector of two\\n  channels, the first of which will contain the values for which the\\n  predicate returned true, the second those for which it returned\\n  false.\\n\\n  The out channels will be unbuffered by default, or two buf-or-ns can\\n  be supplied. The channels will close after the source channel has\\n  closed.\"\n ([p ch] (split p ch nil nil))\n ([p ch t-buf-or-n f-buf-or-n]\n  (let\n   [tc (chan t-buf-or-n) fc (chan f-buf-or-n)]\n   (go-loop\n    []\n    (let\n     [v (<! ch)]\n     (if\n      (nil? v)\n      (do (close! tc) (close! fc))\n      (when (>! (if (p v) tc fc) v) (recur)))))\n   [tc fc])))\n"} {:sym unmix-all, :meta {:doc "removes all inputs from the mix", :arglists ([mix])}, :source "(defn\n unmix-all\n \"removes all inputs from the mix\"\n [mix]\n (unmix-all* mix))\n"} {:sym filter>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n filter>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put!\n   [_ val fn1]\n   (if\n    (p val)\n    (impl/put! ch val fn1)\n    (channels/box (not (impl/closed? ch)))))))\n"} {:sym tap*, :meta {:doc nil, :arglists ([m ch close?])}, :protocol Mult} {:sym untap, :meta {:doc "Disconnects a target channel from a mult", :arglists ([mult ch])}, :source "(defn\n untap\n \"Disconnects a target channel from a mult\"\n [mult ch]\n (untap* mult ch))\n"} {:sym alts!, :meta {:doc "Completes at most one of several channel operations. Must be called\n   inside a (go ...) block. ports is a vector of channel endpoints,\n   which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :arglists ([ports & {:as opts}])}, :source "(defn\n alts!\n \"Completes at most one of several channel operations. Must be called\\n   inside a (go ...) block. ports is a vector of channel endpoints,\\n   which can be either a channel to take from or a vector of\\n  [channel-to-put-to val-to-put], in any combination. Takes will be\\n  made as if by <!, and puts will be made as if by >!. Unless\\n  the :priority option is true, if more than one port operation is\\n  ready a non-deterministic choice will be made. If no operation is\\n  ready and a :default value is supplied, [default-val :default] will\\n  be returned, otherwise alts! will park until the first operation to\\n  become ready completes. Returns [val port] of the completed\\n  operation, where val is the value taken for takes, and a\\n  boolean (true unless already closed, as per put!) for puts.\\n\\n  opts are passed as :key val ... Supported options:\\n\\n  :default val - the value to use if none of the operations are immediately ready\\n  :priority true - (default nil) when true, the operations will be tried in order.\\n\\n  Note: there is no guarantee that the port exps or val exprs will be\\n  used, nor in what order should they be, so they should not be\\n  depended upon for side effects.\"\n [ports & {:as opts}]\n (throw (js/Error. \"alts! used not in (go ...) block\")))\n"} {:sym unsub, :meta {:doc "Unsubscribes a channel from a topic of a pub", :arglists ([p topic ch])}, :source "(defn\n unsub\n \"Unsubscribes a channel from a topic of a pub\"\n [p topic ch]\n (unsub* p topic ch))\n"} {:sym poll!, :meta {:doc "Takes a val from port if it's possible to do so immediately.\n  Never blocks. Returns value if successful, nil otherwise.", :arglists ([port])}, :source "(defn\n poll!\n \"Takes a val from port if it's possible to do so immediately.\\n  Never blocks. Returns value if successful, nil otherwise.\"\n [port]\n (let [ret (impl/take! port (fn-handler nop false))] (when ret @ret)))\n"} {:sym map<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map<\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take!\n   [_ fn1]\n   (let\n    [ret\n     (impl/take!\n      ch\n      (reify\n       impl/Handler\n       (active? [_] (impl/active? fn1))\n       (blockable? [_] true)\n       (commit\n        [_]\n        (let\n         [f1 (impl/commit fn1)]\n         (fn*\n          [p1__18545#]\n          (f1 (if (nil? p1__18545#) nil (f p1__18545#))))))))]\n    (if (and ret (not (nil? @ret))) (channels/box (f @ret)) ret)))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch val fn1))))\n"} {:sym do-alts, :meta {:doc "returns derefable [val port] if immediate, nil if enqueued", :arglists ([fret ports opts])}, :source "(defn\n do-alts\n \"returns derefable [val port] if immediate, nil if enqueued\"\n [fret ports opts]\n (let\n  [flag\n   (alt-flag)\n   n\n   (count ports)\n   idxs\n   (random-array n)\n   priority\n   (:priority opts)\n   ret\n   (loop\n    [i 0]\n    (when\n     (< i n)\n     (let\n      [idx\n       (if priority i (aget idxs i))\n       port\n       (nth ports idx)\n       wport\n       (when (vector? port) (port 0))\n       vbox\n       (if\n        wport\n        (let\n         [val (port 1)]\n         (impl/put!\n          wport\n          val\n          (alt-handler\n           flag\n           (fn* [p1__18541#] (fret [p1__18541# wport])))))\n        (impl/take!\n         port\n         (alt-handler\n          flag\n          (fn* [p1__18542#] (fret [p1__18542# port])))))]\n      (if\n       vbox\n       (channels/box [@vbox (or wport port)])\n       (recur (inc i))))))]\n  (or\n   ret\n   (when\n    (contains? opts :default)\n    (when-let\n     [got (and (impl/active? flag) (impl/commit flag))]\n     (channels/box [(:default opts) :default]))))))\n"} {:sym pipeline-async, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  whose completion/callback will manipulate the result channel. Outputs\n  will be returned in order relative to  the inputs. By default, the to\n  channel will be closed when the from channel closes, but can be\n  determined by the close?  parameter. Will stop consuming the from\n  channel if the to channel closes.", :arglists [[n to af from] [n to af from close?]]}, :source "(defn\n pipeline-async\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the async function af, with parallelism n. af\\n  must be a function of two arguments, the first an input value and\\n  the second a channel on which to place the result(s). af must close!\\n  the channel before returning.  The presumption is that af will\\n  return immediately, having launched some asynchronous operation\\n  whose completion/callback will manipulate the result channel. Outputs\\n  will be returned in order relative to  the inputs. By default, the to\\n  channel will be closed when the from channel closes, but can be\\n  determined by the close?  parameter. Will stop consuming the from\\n  channel if the to channel closes.\"\n ([n to af from] (pipeline-async n to af from true))\n ([n to af from close?] (pipeline* n to af from close? nil :async)))\n"} {:sym Mix, :meta {:doc nil}, :methods (admix* solo-mode* toggle* unmix* unmix-all*)} {:sym toggle*, :meta {:doc nil, :arglists ([m state-map])}, :protocol Mix} {:sym mult, :meta {:doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :arglists ([ch])}, :source "(defn\n mult\n \"Creates and returns a mult(iple) of the supplied channel. Channels\\n  containing copies of the channel can be created with 'tap', and\\n  detached with 'untap'.\\n\\n  Each item is distributed to all taps in parallel and synchronously,\\n  i.e. each tap must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow taps from holding up the mult.\\n\\n  Items received when there are no taps get dropped.\\n\\n  If a tap puts to a closed channel, it will be removed from the mult.\"\n [ch]\n (let\n  [cs\n   (atom {})\n   m\n   (reify\n    Mux\n    (muxch* [_] ch)\n    Mult\n    (tap* [_ ch close?] (swap! cs assoc ch close?) nil)\n    (untap* [_ ch] (swap! cs dissoc ch) nil)\n    (untap-all* [_] (reset! cs {}) nil))\n   dchan\n   (chan 1)\n   dctr\n   (atom nil)\n   done\n   (fn [_] (when (zero? (swap! dctr dec)) (put! dchan true)))]\n  (go-loop\n   []\n   (let\n    [val (<! ch)]\n    (if\n     (nil? val)\n     (doseq [[c close?] @cs] (when close? (close! c)))\n     (let\n      [chs (keys @cs)]\n      (reset! dctr (count chs))\n      (doseq\n       [c chs]\n       (when-not (put! c val done) (done nil) (untap* m c)))\n      (when (seq chs) (<! dchan))\n      (recur)))))\n  m))\n"} {:sym mapcat<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f in] [f in buf-or-n]]}, :source "(defn\n mapcat<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f in] (mapcat< f in nil))\n ([f in buf-or-n] (let [out (chan buf-or-n)] (mapcat* f in out) out)))\n"} {:sym ioc-alts!, :meta {:doc nil, :arglists ([state cont-block ports & {:as opts}])}, :source "(defn\n ioc-alts!\n [state cont-block ports & {:as opts}]\n (ioc/aset-all! state helpers/STATE-IDX cont-block)\n (when-let\n  [cb\n   (cljs.core.async/do-alts\n    (fn\n     [val]\n     (ioc/aset-all! state helpers/VALUE-IDX val)\n     (helpers/run-state-machine-wrapped state))\n    ports\n    opts)]\n  (ioc/aset-all! state helpers/VALUE-IDX @cb)\n  :recur))\n"} {:sym unblocking-buffer?, :meta {:doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :arglists ([buff])}, :source "(defn\n unblocking-buffer?\n \"Returns true if a channel created with buff will never block. That is to say,\\n   puts into this buffer will never cause the buffer to be full. \"\n [buff]\n (satisfies? impl/UnblockingBuffer buff))\n"} {:sym put!, :meta {:doc "Asynchronously puts a val into port, calling fn0 (if supplied) when\n   complete. nil values are not allowed. Will throw if closed. If\n   on-caller? (default true) is true, and the put is immediately\n   accepted, will call fn0 on calling thread.  Returns nil.", :arglists [[port val] [port val fn1] [port val fn1 on-caller?]]}, :source "(defn\n put!\n \"Asynchronously puts a val into port, calling fn0 (if supplied) when\\n   complete. nil values are not allowed. Will throw if closed. If\\n   on-caller? (default true) is true, and the put is immediately\\n   accepted, will call fn0 on calling thread.  Returns nil.\"\n ([port val] (if-let [ret (impl/put! port val fhnop)] @ret true))\n ([port val fn1] (put! port val fn1 true))\n ([port val fn1 on-caller?]\n  (if-let\n   [retb (impl/put! port val (fn-handler fn1))]\n   (let\n    [ret @retb]\n    (if on-caller? (fn1 ret) (dispatch/run (fn* [] (fn1 ret))))\n    ret)\n   true)))\n"} {:sym take!, :meta {:doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :arglists [[port fn1] [port fn1 on-caller?]]}, :source "(defn\n take!\n \"Asynchronously takes a val from port, passing to fn1. Will pass nil\\n   if closed. If on-caller? (default true) is true, and value is\\n   immediately available, will call fn1 on calling thread.\\n   Returns nil.\"\n ([port fn1] (take! port fn1 true))\n ([port fn1 on-caller?]\n  (let\n   [ret (impl/take! port (fn-handler fn1))]\n   (when\n    ret\n    (let\n     [val @ret]\n     (if on-caller? (fn1 val) (dispatch/run (fn* [] (fn1 val))))))\n   nil)))\n"}), reagent.impl.template ({:sym valid-tag?, :meta {:doc nil, :arglists ([x])}, :source "(defn\n valid-tag?\n [x]\n (or (hiccup-tag? x) (ifn? x) (instance? NativeWrapper x)))\n"} {:sym adapt-react-class, :meta {:doc nil, :arglists [[c {:keys [synthetic-input]}] [c]]}, :source "(defn\n adapt-react-class\n ([c {:keys [synthetic-input]}]\n  (let\n   [on-update\n    (:on-update synthetic-input)\n    on-change\n    (:on-change synthetic-input)]\n   (when\n    synthetic-input\n    (assert (fn? on-update))\n    (assert (fn? on-change)))\n   (let\n    [wrapped\n     (doto (->NativeWrapper) ($! :name c) ($! :id nil) ($! :class nil))\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticInput true))\n      wrapped)\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticOnChange on-change))\n      wrapped)\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticOnUpdate on-update))\n      wrapped)]\n    wrapped)))\n ([c] (adapt-react-class c {})))\n"} {:sym synthetic-input-spec, :meta {}, :source "(def\n synthetic-input-spec\n {:display-name \"ReagentSyntheticInput\",\n  :component-did-update input-component-set-value,\n  :component-will-unmount input-unmount,\n  :reagent-render\n  (fn\n   [on-update on-change argv comp jsprops first-child]\n   (let\n    [this comp/*current-component*]\n    (input-render-setup\n     this\n     jsprops\n     {:synthetic-on-update on-update, :synthetic-on-change on-change})\n    (make-element argv comp jsprops first-child)))})\n"} {:sym has-selection-api?, :meta {:doc nil, :arglists ([input-type])}, :source "(defn\n has-selection-api?\n [input-type]\n (contains? these-inputs-have-selection-api input-type))\n"} {:sym str-coll, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n str-coll\n [coll]\n (if\n  (dev?)\n  (str\n   (prewalk\n    (fn\n     [x]\n     (if\n      (fn? x)\n      (let [n (util/fun-name x)] (case n \"\" x (symbol n)))\n      x))\n    coll))\n  (str coll)))\n"} {:sym get-key, :meta {:doc nil, :arglists ([x])}, :source "(defn get-key [x] (when (map? x) (try-get-key x)))\n"} {:sym re-tag, :meta {:doc "Regular expression that parses a CSS-style id and class\n             from a tag name."}, :source "(def re-tag #\"([^\\s\\.#]+)(?:#([^\\s\\.#]+))?(?:\\.([^\\s#]+))?\")\n"} {:sym as-element, :meta {:doc nil, :arglists ([x])}, :source "(defn\n as-element\n [x]\n (cond\n  (js-val? x)\n  x\n  (vector? x)\n  (vec-to-elem x)\n  (seq? x)\n  (if (dev?) (expand-seq-check x) (expand-seq x))\n  (named? x)\n  (name x)\n  (satisfies? IPrintWithWriter x)\n  (pr-str x)\n  :else\n  x))\n"} {:sym input-component?, :meta {:doc nil, :arglists ([x])}, :source "(defn input-component? [x] (case x (\"input\" \"textarea\") true false))\n"} {:sym input-render-setup, :meta {:doc nil, :arglists [[this jsprops {:keys [synthetic-on-update synthetic-on-change]}] [this jsprops]]}, :source "(defn\n input-render-setup\n ([this jsprops {:keys [synthetic-on-update synthetic-on-change]}]\n  (when\n   (and\n    (some? jsprops)\n    (.hasOwnProperty jsprops \"onChange\")\n    (.hasOwnProperty jsprops \"value\"))\n   (assert\n    find-dom-node\n    \"reagent.dom needs to be loaded for controlled input to work\")\n   (when\n    synthetic-on-update\n    ($! this :cljsSyntheticOnUpdate synthetic-on-update))\n   (let\n    [v\n     ($ jsprops :value)\n     value\n     (if (nil? v) \"\" v)\n     on-change\n     ($ jsprops :onChange)\n     on-change\n     (if\n      synthetic-on-change\n      (partial synthetic-on-change on-change)\n      on-change)]\n    (when-not\n     ($ this :cljsInputLive)\n     ($! this :cljsInputLive true)\n     ($! this :cljsDOMValue value))\n    ($! this :cljsRenderedValue value)\n    (js-delete jsprops \"value\")\n    (doto\n     jsprops\n     ($! :defaultValue value)\n     ($!\n      :onChange\n      (fn*\n       [p1__18473#]\n       (input-handle-change this on-change p1__18473#)))))))\n ([this jsprops] (input-render-setup this jsprops {})))\n"} {:sym input-component-set-value, :meta {:doc nil, :arglists ([this])}, :source "(defn\n input-component-set-value\n [this]\n (when\n  ($ this :cljsInputLive)\n  ($! this :cljsInputDirty false)\n  (let\n   [rendered-value\n    ($ this :cljsRenderedValue)\n    dom-value\n    ($ this :cljsDOMValue)\n    node\n    (find-dom-node this)\n    synthetic-on-update\n    ($ this :cljsSyntheticOnUpdate)]\n   (when\n    (not= rendered-value dom-value)\n    (if\n     (fn? synthetic-on-update)\n     (synthetic-on-update\n      input-node-set-value\n      node\n      rendered-value\n      dom-value\n      this)\n     (input-node-set-value node rendered-value dom-value this {}))))))\n"} {:sym stringify-class, :meta {:doc nil, :arglists ([{:keys [class], :as props}])}, :source "(defn\n stringify-class\n [{:keys [class], :as props}]\n (if\n  (coll? class)\n  (->> class (filter identity) (string/join \" \") (assoc props :class))\n  props))\n"} {:sym oget, :meta {:doc nil, :arglists ([o k])}, :source "(defn oget [o k] (if (nil? o) nil (aget o k)))\n"} {:sym hiccup-tag?, :meta {:doc nil, :arglists ([x])}, :source "(defn hiccup-tag? [x] (or (named? x) (string? x)))\n"} {:sym set-id-class, :meta {:doc nil, :arglists ([p id-class])}, :source "(defn\n set-id-class\n [p id-class]\n (let\n  [id\n   ($ id-class :id)\n   p\n   (if (and (some? id) (nil? (oget p \"id\"))) (oset p \"id\" id) p)]\n  (if-some\n   [class ($ id-class :className)]\n   (let\n    [old (oget p \"className\")]\n    (oset p \"className\" (if (nil? old) class (str class \" \" old))))\n   p)))\n"} {:sym reagent-synthetic-input, :meta {:doc nil, :arglists ([])}, :source "(defn\n reagent-synthetic-input\n []\n (when\n  (nil? reagent-synthetic-input-class)\n  (set!\n   reagent-synthetic-input-class\n   (comp/create-class synthetic-input-spec)))\n reagent-synthetic-input-class)\n"} {:sym input-node-set-value, :meta {:doc nil, :arglists ([node rendered-value dom-value component {:keys [on-write]}])}, :source "(defn\n input-node-set-value\n [node rendered-value dom-value component {:keys [on-write]}]\n (if-not\n  (and\n   (identical? node ($ js/document :activeElement))\n   (has-selection-api? ($ node :type))\n   (string? rendered-value)\n   (string? dom-value))\n  (do\n   ($! component :cljsDOMValue rendered-value)\n   ($! node :value rendered-value)\n   (when (fn? on-write) (on-write rendered-value)))\n  (let\n   [node-value ($ node :value)]\n   (if\n    (not= node-value dom-value)\n    (batch/do-after-render\n     (fn* [] (input-component-set-value component)))\n    (let\n     [existing-offset-from-end\n      (- (count node-value) ($ node :selectionStart))\n      new-cursor-offset\n      (- (count rendered-value) existing-offset-from-end)]\n     ($! component :cljsDOMValue rendered-value)\n     ($! node :value rendered-value)\n     (when (fn? on-write) (on-write rendered-value))\n     ($! node :selectionStart new-cursor-offset)\n     ($! node :selectionEnd new-cursor-offset))))))\n"} {:sym convert-props, :meta {:doc nil, :arglists ([props id-class])}, :source "(defn\n convert-props\n [props id-class]\n (-> props stringify-class convert-prop-value (set-id-class id-class)))\n"} {:sym hiccup-err, :meta {:doc nil, :arglists ([v & msg])}, :source "(defn\n hiccup-err\n [v & msg]\n (str (apply str msg) \": \" (str-coll v) \"\\n\" (comp/comp-name)))\n"} {:sym named?, :meta {:doc nil, :arglists ([x])}, :source "(defn named? [x] (or (keyword? x) (symbol? x)))\n"} {:sym kv-conv, :meta {:doc nil, :arglists ([o k v])}, :source "(defn\n kv-conv\n [o k v]\n (doto o (aset (cached-prop-name k) (convert-prop-value v))))\n"} {:sym key-from-vec, :meta {:doc nil, :arglists ([v])}, :source "(defn\n key-from-vec\n [v]\n (if-some [k (-> (meta v) get-key)] k (-> v (nth 1 nil) get-key)))\n"} {:sym js-val?, :meta {:doc nil, :arglists ([x])}, :source "(defn js-val? [x] (not (identical? \"object\" (goog/typeOf x))))\n"} {:sym input-unmount, :meta {:doc nil, :arglists ([this])}, :source "(defn input-unmount [this] ($! this :cljsInputLive nil))\n"} {:sym reagent-input-class, :meta {}, :source "(def reagent-input-class nil)\n"} {:sym native-element, :meta {:doc nil, :arglists ([parsed argv first])}, :source "(defn\n native-element\n [parsed argv first]\n (let\n  [comp ($ parsed :name) synthetic-input ($ parsed :syntheticInput)]\n  (let\n   [props\n    (nth argv first nil)\n    hasprops\n    (or (nil? props) (map? props))\n    jsprops\n    (convert-props (if hasprops props) parsed)\n    first-child\n    (+ first (if hasprops 1 0))]\n   (if\n    (or synthetic-input (input-component? comp))\n    (->\n     (if\n      synthetic-input\n      [(reagent-synthetic-input)\n       ($ parsed :syntheticOnUpdate)\n       ($ parsed :syntheticOnChange)\n       argv\n       comp\n       jsprops\n       first-child]\n      [(reagent-input) argv comp jsprops first-child])\n     (with-meta (meta argv))\n     as-element)\n    (let\n     [key\n      (-> (meta argv) get-key)\n      p\n      (if (nil? key) jsprops (oset jsprops \"key\" key))]\n     (make-element argv comp p first-child))))))\n"} {:sym reagent-input, :meta {:doc nil, :arglists ([])}, :source "(defn\n reagent-input\n []\n (when\n  (nil? reagent-input-class)\n  (set! reagent-input-class (comp/create-class input-spec)))\n reagent-input-class)\n"} {:sym cache-get, :meta {:doc nil, :arglists ([o k])}, :source "(defn cache-get [o k] (when (.hasOwnProperty o k) (aget o k)))\n"} {:sym input-handle-change, :meta {:doc nil, :arglists ([this on-change e])}, :source "(defn\n input-handle-change\n [this on-change e]\n ($! this :cljsDOMValue (-> e .-target .-value))\n (when-not\n  ($ this :cljsInputDirty)\n  ($! this :cljsInputDirty true)\n  (batch/do-after-render (fn* [] (input-component-set-value this))))\n (on-change e))\n"} {:sym input-spec, :meta {}, :source "(def\n input-spec\n {:display-name \"ReagentInput\",\n  :component-did-update input-component-set-value,\n  :component-will-unmount input-unmount,\n  :reagent-render\n  (fn\n   [argv comp jsprops first-child]\n   (let\n    [this comp/*current-component*]\n    (input-render-setup this jsprops)\n    (make-element argv comp jsprops first-child)))})\n"} {:sym expand-seq-dev, :meta {:doc nil, :arglists ([s o])}, :source "(defn\n expand-seq-dev\n [s o]\n (let\n  [a (into-array s)]\n  (dotimes\n   [i (alength a)]\n   (let\n    [val (aget a i)]\n    (when\n     (and (vector? val) (nil? (key-from-vec val)))\n     ($! o :no-key true))\n    (aset a i (as-element val))))\n  a))\n"} {:sym cached-prop-name, :meta {:doc nil, :arglists ([k])}, :source "(defn\n cached-prop-name\n [k]\n (if\n  (named? k)\n  (if-some\n   [k' (cache-get prop-name-cache (name k))]\n   k'\n   (aset prop-name-cache (name k) (util/dash-to-camel k)))\n  k))\n"} {:sym these-inputs-have-selection-api, :meta {}, :source "(def\n these-inputs-have-selection-api\n #{\"url\" \"tel\" \"text\" \"textarea\" \"password\" \"search\"})\n"} {:sym expand-seq, :meta {:doc nil, :arglists ([s])}, :source "(defn\n expand-seq\n [s]\n (let\n  [a (into-array s)]\n  (dotimes [i (alength a)] (aset a i (as-element (aget a i))))\n  a))\n"} {:sym reagent-synthetic-input-class, :meta {}, :source "(def reagent-synthetic-input-class nil)\n"} {:sym find-dom-node, :meta {}, :source "(defonce find-dom-node nil)\n"} {:sym cached-parse, :meta {:doc nil, :arglists ([x])}, :source "(defn\n cached-parse\n [x]\n (if-some\n  [s (cache-get tag-name-cache x)]\n  s\n  (aset tag-name-cache x (parse-tag x))))\n"} {:sym try-get-key, :meta {:doc nil, :arglists ([x])}, :source "(defn try-get-key [x] (try (get x :key) (catch :default e)))\n"}), reagent.impl.batching ({:sym fake-raf, :meta {:doc nil, :arglists ([f])}, :source "(defn fake-raf [f] (js/setTimeout f 16))\n"} {:sym do-before-flush, :meta {:doc nil, :arglists ([f])}, :source "(defn do-before-flush [f] (.add-before-flush render-queue f))\n"} {:sym flush-after-render, :meta {:doc nil, :arglists ([])}, :source "(defn flush-after-render [] (.flush-after-render render-queue))\n"} {:sym queue-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n queue-render\n [c]\n (when-not\n  ($ c :cljsIsDirty)\n  ($! c :cljsIsDirty true)\n  (.queue-render render-queue c)))\n"} {:sym next-tick, :meta {}, :source "(def\n next-tick\n (if-not\n  is-client\n  fake-raf\n  (let\n   [w js/window]\n   (or\n    ($ w :requestAnimationFrame)\n    ($ w :webkitRequestAnimationFrame)\n    ($ w :mozRequestAnimationFrame)\n    ($ w :msRequestAnimationFrame)\n    fake-raf))))\n"} {:sym flush, :meta {:doc nil, :arglists ([])}, :source "(defn flush [] (.flush-queues render-queue))\n"} {:sym mark-rendered, :meta {:doc nil, :arglists ([c])}, :source "(defn mark-rendered [c] ($! c :cljsIsDirty false))\n"} {:sym schedule, :meta {:doc nil, :arglists ([])}, :source "(defn\n schedule\n []\n (when (false? (.-scheduled? render-queue)) (.schedule render-queue)))\n"} {:sym render-queue, :meta {}, :source "(defonce render-queue (->RenderQueue false))\n"} {:sym compare-mount-order, :meta {:doc nil, :arglists ([c1 c2])}, :source "(defn\n compare-mount-order\n [c1 c2]\n (- ($ c1 :cljsMountOrder) ($ c2 :cljsMountOrder)))\n"} {:sym mount-count, :meta {}, :source "(defonce mount-count 0)\n"} {:sym next-mount-count, :meta {:doc nil, :arglists ([])}, :source "(defn next-mount-count [] (set! mount-count (inc mount-count)))\n"} {:sym do-after-render, :meta {:doc nil, :arglists ([f])}, :source "(defn do-after-render [f] (.add-after-render render-queue f))\n"} {:sym run-queue, :meta {:doc nil, :arglists ([a])}, :source "(defn\n run-queue\n [a]\n (.sort a compare-mount-order)\n (dotimes\n  [i (alength a)]\n  (let\n   [c (aget a i)]\n   (when (true? ($ c :cljsIsDirty)) ($ c forceUpdate)))))\n"} {:sym ratom-flush, :meta {}, :source "(defonce ratom-flush (fn []))\n"}), cljs.core.async.impl.buffers ({:sym acopy, :meta {:doc nil, :arglists ([src src-start dest dest-start len])}, :source "(defn\n acopy\n [src src-start dest dest-start len]\n (loop\n  [cnt 0]\n  (when\n   (< cnt len)\n   (aset dest (+ dest-start cnt) (aget src (+ src-start cnt)))\n   (recur (inc cnt)))))\n"} {:sym ring-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn\n ring-buffer\n [n]\n (assert (> n 0) \"Can't create a ring buffer of size 0\")\n (RingBuffer. 0 0 0 (make-array n)))\n"} {:sym fixed-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn fixed-buffer [n] (FixedBuffer. (ring-buffer n) n))\n"} {:sym dropping-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn dropping-buffer [n] (DroppingBuffer. (ring-buffer n) n))\n"} {:sym sliding-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn sliding-buffer [n] (SlidingBuffer. (ring-buffer n) n))\n"} {:sym promise-buffer, :meta {:doc nil, :arglists ([])}, :source "(defn promise-buffer [] (PromiseBuffer. NO-VAL))\n"}), cljs.core.async.impl.protocols ({:sym remove!, :meta {:doc "remove and return next item from buffer, called under chan mutex", :arglists ([b])}, :protocol Buffer} {:sym close-buf!, :meta {:doc "called on chan closed under chan mutex, return ignored", :arglists ([b])}, :protocol Buffer} {:sym close!, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym Handler, :meta {:doc nil}, :methods (active? blockable? commit)} {:sym blockable?, :meta {:doc "returns true if this handler may be blocked, otherwise it must not block", :arglists ([h])}, :protocol Handler} {:sym active?, :meta {:doc "returns true if has callback. Must work w/o lock", :arglists ([h])}, :protocol Handler} {:sym Buffer, :meta {:doc nil}, :methods (add!* close-buf! full? remove!)} {:sym full?, :meta {:doc "returns true if buffer cannot accept put", :arglists ([b])}, :protocol Buffer} {:sym add!, :meta {:doc nil, :arglists [[b] [b itm]]}, :source "(defn add! ([b] b) ([b itm] (assert (not (nil? itm))) (add!* b itm)))\n"} {:sym add!*, :meta {:doc "if room, add item to the buffer, returns b, called under chan mutex", :arglists ([b itm])}, :protocol Buffer} {:sym ReadPort, :meta {:doc nil}, :methods (take!)} {:sym Channel, :meta {:doc nil}, :methods (close! closed?)} {:sym closed?, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym UnblockingBuffer, :meta {:doc nil}, :methods ()} {:sym MAX-QUEUE-SIZE, :meta {}, :source "(def MAX-QUEUE-SIZE 1024)\n"} {:sym commit, :meta {:doc "commit to fulfilling its end of the transfer, returns cb. Must be called within lock", :arglists ([h])}, :protocol Handler} {:sym put!, :meta {:doc "derefable boolean (false if already closed) if handled, nil if put was enqueued.\n                               Must throw on nil val.", :arglists ([port val fn1-handler])}, :protocol WritePort} {:sym take!, :meta {:doc "derefable val if taken, nil if take was enqueued", :arglists ([port fn1-handler])}, :protocol ReadPort} {:sym WritePort, :meta {:doc nil}, :methods (put!)}), figwheel.client.file-reloading ({:sym figwheel-require, :meta {:doc nil, :arglists ([src reload])}, :source "(defn\n figwheel-require\n [src reload]\n (set! (.-require js/goog) figwheel-require)\n (when\n  (= reload \"reload-all\")\n  (doseq [ns (get-all-dependencies src)] (unprovide! ns)))\n (when reload (unprovide! src))\n (.require_figwheel_backup_ js/goog src))\n"} {:sym create-node-script-import-fn, :meta {:doc nil, :arglists ([])}, :source "(defn\n create-node-script-import-fn\n []\n (let\n  [node-path-lib\n   (js/require \"path\")\n   util-pattern\n   (str\n    (.-sep node-path-lib)\n    (.join node-path-lib \"goog\" \"bootstrap\" \"nodejs.js\"))\n   util-path\n   (gobj/findKey\n    js/require.cache\n    (fn [v k o] (gstring/endsWith k util-pattern)))\n   parts\n   (-> (string/split util-path #\"[/\\\\]\") pop pop)\n   root-path\n   (string/join (.-sep node-path-lib) parts)]\n  (fn\n   [request-url callback]\n   (dev-assert (string? request-url) (not (nil? callback)))\n   (let\n    [cache-path (.resolve node-path-lib root-path request-url)]\n    (gobj/remove (.-cache js/require) cache-path)\n    (callback\n     (try\n      (js/require cache-path)\n      (catch\n       js/Error\n       e\n       (utils/log\n        :error\n        (str \"Figwheel: Error loading file \" cache-path))\n       (utils/log :error (.-stack e))\n       false)))))))\n"} {:sym matches-file?, :meta {:doc nil, :arglists ([{:keys [file]} link])}, :source "(defn\n matches-file?\n [{:keys [file]} link]\n (when-let\n  [link-href (.-href link)]\n  (let\n   [match\n    (string/join\n     \"/\"\n     (take-while\n      identity\n      (map\n       (fn*\n        [p1__18493# p2__18494#]\n        (if (= p1__18493# p2__18494#) p1__18493# false))\n       (reverse (string/split file \"/\"))\n       (reverse (string/split (truncate-url link-href) \"/\")))))\n    match-length\n    (count match)\n    file-name-length\n    (count (last (string/split file \"/\")))]\n   (when\n    (>= match-length file-name-length)\n    {:link link,\n     :link-href link-href,\n     :match-length match-length,\n     :current-url-length (count (truncate-url link-href))}))))\n"} {:sym build-topo-sort, :meta {:doc nil, :arglists ([get-deps])}, :source "(defn\n build-topo-sort\n [get-deps]\n (let\n  [get-deps (memoize get-deps)]\n  (letfn\n   [(topo-sort-helper*\n     [x depth state]\n     (let\n      [deps (get-deps x)]\n      (when-not (empty? deps) (topo-sort* deps depth state))))\n    (topo-sort*\n     ([deps] (topo-sort* deps 0 (atom (sorted-map))))\n     ([deps depth state]\n      (swap! state update-in [depth] (fnil into #{}) deps)\n      (doseq\n       [dep deps]\n       (when\n        (and dep (not (in-upper-level? @state depth dep)))\n        (topo-sort-helper* dep (inc depth) state)))\n      (when (= depth 0) (elim-dups* (reverse (vals @state))))))\n    (elim-dups*\n     [[x & xs]]\n     (if\n      (nil? x)\n      (list)\n      (cons\n       x\n       (elim-dups*\n        (map (fn* [p1__18484#] (difference p1__18484# x)) xs)))))]\n   topo-sort*)))\n"} {:sym unprovide!, :meta {:doc nil, :arglists ([ns])}, :source "(defn\n unprovide!\n [ns]\n (let\n  [path (name->path ns)]\n  (gobj/remove js/goog.dependencies_.visited path)\n  (gobj/remove js/goog.dependencies_.written path)\n  (gobj/remove\n   js/goog.dependencies_.written\n   (str js/goog.basePath path))))\n"} {:sym get-all-dependents, :meta {:doc nil, :arglists ([nss])}, :source "(defn\n get-all-dependents\n [nss]\n (let\n  [topo-sort' (build-topo-sort ns->dependents)]\n  (filter\n   (comp not immutable-ns?)\n   (reverse (apply concat (topo-sort' (set nss)))))))\n"} {:sym addDependency, :meta {:doc nil, :arglists ([path provides requires])}, :source "(defn\n addDependency\n [path provides requires]\n (doseq\n  [prov provides]\n  (path-to-name! path prov)\n  (doseq [req requires] (name-to-parent! req prov))))\n"} {:sym figwheel-no-load?, :meta {:doc nil, :arglists ([{:keys [namespace], :as file-msg}])}, :source "(defn\n figwheel-no-load?\n [{:keys [namespace], :as file-msg}]\n (let\n  [meta-pragmas (get @figwheel-meta-pragmas (name namespace))]\n  (:figwheel-no-load meta-pragmas)))\n"} {:sym write-script-tag-import, :meta {}, :source "(def write-script-tag-import reload-file-in-html-env)\n"} {:sym namespace-file-map?, :meta {:doc nil, :arglists ([m])}, :source "(defn\n namespace-file-map?\n [m]\n (or\n  (and\n   (map? m)\n   (string? (:namespace m))\n   (or (nil? (:file m)) (string? (:file m)))\n   (= (:type m) :namespace))\n  (do (println \"Error not namespace-file-map\" (pr-str m)) false)))\n"} {:sym path->name, :meta {:doc "returns a set of namespaces defined by a path", :arglists ([path])}, :source "(defn\n path->name\n \"returns a set of namespaces defined by a path\"\n [path]\n (get-in @dependency-data [:pathToName path]))\n"} {:sym get-figwheel-always, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-figwheel-always\n []\n (map\n  (fn [[k v]] {:namespace k, :type :namespace})\n  (filter (fn [[k v]] (:figwheel-always v)) @figwheel-meta-pragmas)))\n"} {:sym name-to-parent!, :meta {:doc nil, :arglists ([ns parent-ns])}, :source "(defn\n name-to-parent!\n [ns parent-ns]\n (swap!\n  dependency-data\n  update-in\n  [:dependents ns]\n  (fnil clojure.set/union #{})\n  #{parent-ns}))\n"} {:sym current-links, :meta {:doc nil, :arglists ([])}, :source "(defn\n current-links\n []\n (.call\n  (.. js/Array -prototype -slice)\n  (.getElementsByTagName js/document \"link\")))\n"} {:sym on-cssload-custom-event, :meta {:doc nil, :arglists ([files])}, :source "(defn\n on-cssload-custom-event\n [files]\n (utils/dispatch-custom-event \"figwheel.css-reload\" files))\n"} {:sym blocking-load, :meta {:doc nil, :arglists ([url])}, :source "(defn\n blocking-load\n [url]\n (let\n  [out (chan)]\n  (reload-file\n   {:request-url url}\n   (fn [file-msg] (put! out file-msg) (close! out)))\n  out))\n"} {:sym reload-css-files, :meta {:doc nil, :arglists ([{:keys [on-cssload]} {:keys [files], :as files-msg}])}, :source "(defn\n reload-css-files\n [{:keys [on-cssload]} {:keys [files], :as files-msg}]\n (when\n  (utils/html-env?)\n  (when-let\n   [f-datas (not-empty (distinctify :file files))]\n   (swap!\n    reload-css-deferred-chain\n    reload-css-files*\n    f-datas\n    on-cssload))))\n"} {:sym add-cache-buster, :meta {:doc nil, :arglists ([url])}, :source "(defn\n add-cache-buster\n [url]\n (dev-assert (string? url))\n (.makeUnique (guri/parse url)))\n"} {:sym ns->dependents, :meta {:doc nil, :arglists ([ns])}, :source "(defn ns->dependents [ns] (get-in @dependency-data [:dependents ns]))\n"} {:sym on-load-callbacks, :meta {}, :source "(defonce on-load-callbacks (atom {}))\n"} {:sym reload-chan, :meta {}, :source "(defonce reload-chan (chan))\n"} {:sym get-correct-link, :meta {:doc nil, :arglists ([f-data])}, :source "(defn\n get-correct-link\n [f-data]\n (when-let\n  [res\n   (first\n    (sort-by\n     (fn\n      [{:keys [match-length current-url-length]}]\n      (- current-url-length match-length))\n     (keep\n      (fn* [p1__18495#] (matches-file? f-data p1__18495#))\n      (current-links))))]\n  (:link res)))\n"} {:sym expand-files, :meta {:doc nil, :arglists ([files])}, :source "(defn\n expand-files\n [files]\n (let\n  [deps (get-all-dependents (map :namespace files))]\n  (filter\n   (comp not (partial re-matches #\"figwheel\\.connect.*\") :namespace)\n   (map\n    (fn\n     [n]\n     (if-let\n      [file-msg\n       (first\n        (filter\n         (fn* [p1__18489#] (= (:namespace p1__18489#) n))\n         files))]\n      file-msg\n      {:type :namespace, :namespace n}))\n    deps))))\n"} {:sym setup-ns->dependents!, :meta {:doc "This reverses the goog.dependencies_.requires for looking up ns-dependents.", :arglists ([])}, :source "(defn\n setup-ns->dependents!\n \"This reverses the goog.dependencies_.requires for looking up ns-dependents.\"\n []\n (let\n  [requires\n   (gobj/filter\n    js/goog.dependencies_.requires\n    (fn [v k o] (gstring/startsWith k \"../\")))]\n  (gobj/forEach\n   requires\n   (fn\n    [v k _]\n    (gobj/forEach\n     v\n     (fn\n      [v' k' _]\n      (doseq [n (path->name k)] (name-to-parent! k' n))))))))\n"} {:sym before-jsload-custom-event, :meta {:doc nil, :arglists ([files])}, :source "(defn\n before-jsload-custom-event\n [files]\n (utils/dispatch-custom-event \"figwheel.before-js-reload\" files))\n"} {:sym setup-path->name!, :meta {:doc "Setup a path to name dependencies map.\n   That goes from path -> #{ ns-names }", :arglists ([])}, :source "(defn\n setup-path->name!\n \"Setup a path to name dependencies map.\\n   That goes from path -> #{ ns-names }\"\n []\n (let\n  [nameToPath\n   (gobj/filter\n    js/goog.dependencies_.nameToPath\n    (fn [v k o] (gstring/startsWith v \"../\")))]\n  (gobj/forEach nameToPath (fn [v k o] (path-to-name! v k)))))\n"} {:sym js-reload, :meta {:doc nil, :arglists ([{:keys [request-url namespace], :as file-msg} callback])}, :source "(defn\n js-reload\n [{:keys [request-url namespace], :as file-msg} callback]\n (dev-assert (namespace-file-map? file-msg))\n (if\n  (reload-file? file-msg)\n  (require-with-callback file-msg callback)\n  (do\n   (utils/debug-prn\n    (str \"Figwheel: Not trying to load file \" request-url))\n   (apply callback [file-msg]))))\n"} {:sym get-requires, :meta {:doc nil, :arglists ([ns])}, :source "(defn\n get-requires\n [ns]\n (->>\n  ns\n  name->path\n  (gobj/get js/goog.dependencies_.requires)\n  (gobj/getKeys)\n  (filter (fn* [p1__18483#] (not (immutable-ns? p1__18483#))))\n  set))\n"} {:sym add-link-to-document, :meta {:doc nil, :arglists ([orig-link klone finished-fn])}, :source "(defn\n add-link-to-document\n [orig-link klone finished-fn]\n (let\n  [parent (.-parentNode orig-link)]\n  (if\n   (= orig-link (.-lastChild parent))\n   (.appendChild parent klone)\n   (.insertBefore parent klone (.-nextSibling orig-link)))\n  (js/setTimeout\n   (fn* [] (do (.removeChild parent orig-link) (finished-fn)))\n   300)))\n"} {:sym truncate-url, :meta {:doc nil, :arglists ([url])}, :source "(defn\n truncate-url\n [url]\n (->\n  (first (string/split url #\"\\?\"))\n  (string/replace-first (str (.-protocol js/location) \"//\") \"\")\n  (string/replace-first \".*://\" \"\")\n  (string/replace-first #\"^//\" \"\")\n  (string/replace-first #\"[^\\/]*\" \"\")))\n"} {:sym clone-link, :meta {:doc nil, :arglists ([link url])}, :source "(defn\n clone-link\n [link url]\n (let\n  [clone (.createElement js/document \"link\")]\n  (set! (.-rel clone) \"stylesheet\")\n  (set! (.-media clone) (.-media link))\n  (set! (.-disabled clone) (.-disabled link))\n  (set! (.-href clone) (add-cache-buster url))\n  clone))\n"} {:sym name->path, :meta {:doc nil, :arglists ([ns])}, :source "(defn\n name->path\n [ns]\n (dev-assert (string? ns))\n (gobj/get js/goog.dependencies_.nameToPath ns))\n"} {:sym reloader-loop, :meta {}, :source "(defonce\n reloader-loop\n (go-loop\n  []\n  (when-let\n   [[url opt-source-text] (<! reload-chan)]\n   (cond\n    opt-source-text\n    (do\n     (js/console.log \"Evaling!\" opt-source-text)\n     (js/eval opt-source-text))\n    url\n    (let\n     [file-msg (<! (blocking-load url))]\n     (js/console.log \"Loading!\" url)\n     (if-let\n      [callback (get @on-load-callbacks url)]\n      (callback file-msg)\n      (swap! dependencies-loaded conj file-msg))))\n   (recur))))\n"} {:sym require-with-callback, :meta {:doc nil, :arglists ([{:keys [namespace], :as file-msg} callback])}, :source "(defn\n require-with-callback\n [{:keys [namespace], :as file-msg} callback]\n (let\n  [request-url (resolve-ns namespace)]\n  (swap!\n   on-load-callbacks\n   assoc\n   request-url\n   (fn\n    [file-msg']\n    (swap! on-load-callbacks dissoc request-url)\n    (apply\n     callback\n     [(merge file-msg (select-keys file-msg' [:loaded-file]))])))\n  (figwheel-require (name namespace) true)))\n"} {:sym distinctify, :meta {:doc nil, :arglists ([key seqq])}, :source "(defn\n distinctify\n [key seqq]\n (vals\n  (reduce\n   (fn*\n    [p1__18496# p2__18497#]\n    (assoc p1__18496# (get p2__18497# key) p2__18497#))\n   {}\n   seqq)))\n"} {:sym bootstrap-goog-base, :meta {:doc "Reusable browser REPL bootstrapping. Patches the essential functions\n  in goog.base to support re-loading of namespaces after page load.", :arglists ([])}, :source "(defn\n bootstrap-goog-base\n \"Reusable browser REPL bootstrapping. Patches the essential functions\\n  in goog.base to support re-loading of namespaces after page load.\"\n []\n (when-not\n  js/COMPILED\n  (set!\n   (.-require_figwheel_backup_ js/goog)\n   (or js/goog.require__ js/goog.require))\n  (set! (.-isProvided_ js/goog) (fn [name] false))\n  (setup-path->name!)\n  (setup-ns->dependents!)\n  (set!\n   (.-addDependency_figwheel_backup_ js/goog)\n   js/goog.addDependency)\n  (set!\n   (.-addDependency js/goog)\n   (fn\n    [& args]\n    (apply addDependency args)\n    (apply (.-addDependency_figwheel_backup_ js/goog) args)))\n  (goog/constructNamespace_ \"cljs.user\")\n  (set! (.-CLOSURE_IMPORT_SCRIPT goog/global) queued-file-reload)\n  (set! (.-require js/goog) figwheel-require)))\n"} {:sym reload-css-deferred-chain, :meta {}, :source "(defonce reload-css-deferred-chain (atom (.succeed Deferred)))\n"} {:sym reload-css-files*, :meta {:doc nil, :arglists ([deferred f-datas on-cssload])}, :source "(defn\n reload-css-files*\n [deferred f-datas on-cssload]\n (->\n  deferred\n  (utils/mapConcatD reload-css-file f-datas)\n  (utils/liftContD\n   (fn\n    [f-datas' fin]\n    (let\n     [loaded-f-datas (filter :loaded f-datas')]\n     (on-cssload-custom-event loaded-f-datas)\n     (when (fn? on-cssload) (on-cssload loaded-f-datas)))\n    (fin)))))\n"} {:sym in-upper-level?, :meta {:doc nil, :arglists ([topo-state current-depth dep])}, :source "(defn\n in-upper-level?\n [topo-state current-depth dep]\n (some\n  (fn [[_ v]] (and v (v dep)))\n  (filter (fn [[k v]] (> k current-depth)) topo-state)))\n"} {:sym get-all-dependencies, :meta {:doc nil, :arglists ([ns])}, :source "(defn\n get-all-dependencies\n [ns]\n (let\n  [topo-sort' (build-topo-sort get-requires)]\n  (apply concat (topo-sort' (set [ns])))))\n"} {:sym queued-file-reload, :meta {:doc nil, :arglists [[url] [url opt-source-text]]}, :source "(defn\n queued-file-reload\n ([url] (queued-file-reload url nil))\n ([url opt-source-text] (put! reload-chan [url opt-source-text])))\n"} {:sym gloader, :meta {}, :source "(def\n gloader\n (cond\n  (exists? loader/safeLoad)\n  (fn*\n   [p1__18485# p2__18486#]\n   (loader/safeLoad\n    (conv/trustedResourceUrlFromString (str p1__18485#))\n    p2__18486#))\n  (exists? loader/load)\n  (fn*\n   [p1__18487# p2__18488#]\n   (loader/load (str p1__18487#) p2__18488#))\n  :else\n  (throw (ex-info \"No remote script loading function found.\" {}))))\n"} {:sym patch-goog-base, :meta {:doc nil, :arglists ([])}, :source "(defn\n patch-goog-base\n []\n (defonce bootstrapped-cljs (do (bootstrap-goog-base) true)))\n"} {:sym reload-file?, :meta {:doc nil, :arglists ([{:keys [namespace], :as file-msg}])}, :source "(defn\n reload-file?\n [{:keys [namespace], :as file-msg}]\n (dev-assert (namespace-file-map? file-msg))\n (let\n  [meta-pragmas (get @figwheel-meta-pragmas (name namespace))]\n  (and\n   (not (figwheel-no-load? file-msg))\n   (or\n    (:figwheel-always meta-pragmas)\n    (:figwheel-load meta-pragmas)\n    (provided? (name namespace))))))\n"} {:sym on-jsload-custom-event, :meta {:doc nil, :arglists ([url])}, :source "(defn\n on-jsload-custom-event\n [url]\n (utils/dispatch-custom-event \"figwheel.js-reload\" url))\n"} {:sym dependencies-loaded, :meta {}, :source "(defonce dependencies-loaded (atom []))\n"} {:sym reload-css-file, :meta {:doc nil, :arglists ([f-data fin])}, :source "(defn\n reload-css-file\n [f-data fin]\n (if-let\n  [link (get-correct-link f-data)]\n  (add-link-to-document\n   link\n   (clone-link link (.-href link))\n   (fn* [] (fin (assoc f-data :loaded true))))\n  (fin f-data)))\n"} {:sym provided?, :meta {:doc nil, :arglists ([ns])}, :source "(defn\n provided?\n [ns]\n (gobj/get js/goog.dependencies_.written (name->path ns)))\n"} {:sym immutable-ns?, :meta {:doc nil, :arglists ([name])}, :source "(defn\n immutable-ns?\n [name]\n (or\n  (#{\"cljs.nodejs\" \"goog\" \"cljs.core\"} name)\n  (goog.string/startsWith \"clojure.\" name)\n  (goog.string/startsWith \"goog.\" name)))\n"} {:sym figwheel-meta-pragmas, :meta {}, :source "(defonce figwheel-meta-pragmas (atom {}))\n"} {:sym sort-files, :meta {:doc nil, :arglists ([files])}, :source "(defn\n sort-files\n [files]\n (if\n  (<= (count files) 1)\n  files\n  (let\n   [keep-files (set (keep :namespace files))]\n   (filter (comp keep-files :namespace) (expand-files files)))))\n"} {:sym resolve-ns, :meta {:doc nil, :arglists ([ns])}, :source "(defn resolve-ns [ns] (str goog/basePath (name->path ns)))\n"} {:sym reload-js-file, :meta {:doc nil, :arglists ([file-msg])}, :source "(defn\n reload-js-file\n [file-msg]\n (let\n  [out (chan)]\n  (js-reload file-msg (fn [url] (put! out url) (close! out)))\n  out))\n"} {:sym eval-body, :meta {:doc nil, :arglists ([{:keys [eval-body file]} opts])}, :source "(defn\n eval-body\n [{:keys [eval-body file]} opts]\n (when\n  (and eval-body (string? eval-body))\n  (let\n   [code eval-body]\n   (try\n    (utils/debug-prn (str \"Evaling file \" file))\n    (utils/eval-helper code opts)\n    (catch\n     :default\n     e\n     (utils/log :error (str \"Unable to evaluate \" file)))))))\n"} {:sym load-all-js-files, :meta {:doc "Returns a chanel with one collection of loaded filenames on it.", :arglists ([files])}, :source "(defn\n load-all-js-files\n \"Returns a chanel with one collection of loaded filenames on it.\"\n [files]\n (let\n  [out (chan)]\n  (go-loop\n   [[f & fs] files]\n   (if-not\n    (nil? f)\n    (do (put! out (<! (reload-js-file f))) (recur fs))\n    (close! out)))\n  (async/into [] out)))\n"} {:sym reload-file*, :meta {}, :source "(def\n reload-file*\n (condp\n  =\n  (utils/host-env?)\n  :node\n  (create-node-script-import-fn)\n  :html\n  write-script-tag-import\n  :worker\n  worker-import-script\n  (fn [a b] (throw \"Reload not defined for this platform\"))))\n"} {:sym path-to-name!, :meta {:doc nil, :arglists ([path name])}, :source "(defn\n path-to-name!\n [path name]\n (swap!\n  dependency-data\n  update-in\n  [:pathToName path]\n  (fnil clojure.set/union #{})\n  #{name}))\n"} {:sym create-link, :meta {:doc nil, :arglists ([url])}, :source "(defn\n create-link\n [url]\n (let\n  [link (.createElement js/document \"link\")]\n  (set! (.-rel link) \"stylesheet\")\n  (set! (.-href link) (add-cache-buster url))\n  link))\n"} {:sym reload-js-files, :meta {:doc nil, :arglists ([{:keys [before-jsload on-jsload reload-dependents], :as opts} {:keys [files figwheel-meta recompile-dependents], :as msg}])}, :source "(defn\n reload-js-files\n [{:keys [before-jsload on-jsload reload-dependents], :as opts}\n  {:keys [files figwheel-meta recompile-dependents], :as msg}]\n (when-not\n  (empty? figwheel-meta)\n  (reset! figwheel-meta-pragmas figwheel-meta))\n (go\n  (before-jsload files)\n  (before-jsload-custom-event files)\n  (let\n   [eval-bodies\n    (filter (fn* [p1__18490#] (:eval-body p1__18490#)) files)]\n   (when\n    (not-empty eval-bodies)\n    (doseq\n     [eval-body-file eval-bodies]\n     (eval-body eval-body-file opts))))\n  (reset! dependencies-loaded (list))\n  (let\n   [all-files\n    (filter\n     (fn*\n      [p1__18491#]\n      (and\n       (:namespace p1__18491#)\n       (not (:eval-body p1__18491#))\n       (not (figwheel-no-load? p1__18491#))))\n     files)\n    all-files\n    (concat all-files (get-figwheel-always))\n    all-files\n    (if\n     (or reload-dependents recompile-dependents)\n     (expand-files all-files)\n     (sort-files all-files))\n    res'\n    (<! (load-all-js-files all-files))\n    res\n    (filter :loaded-file res')\n    files-not-loaded\n    (filter (fn* [p1__18492#] (not (:loaded-file p1__18492#))) res')\n    dependencies-that-loaded\n    (filter :loaded-file @dependencies-loaded)]\n   (when\n    (not-empty dependencies-that-loaded)\n    (utils/log :debug \"Figwheel: loaded these dependencies\")\n    (utils/log\n     (pr-str\n      (map\n       (fn\n        [{:keys [request-url]}]\n        (string/replace request-url goog/basePath \"\"))\n       (reverse dependencies-that-loaded)))))\n   (when\n    (not-empty res)\n    (utils/log :debug \"Figwheel: loaded these files\")\n    (utils/log\n     (pr-str\n      (map\n       (fn\n        [{:keys [namespace file]}]\n        (if namespace (name->path (name namespace)) file))\n       res)))\n    (js/setTimeout\n     (fn* [] (do (on-jsload-custom-event res) (apply on-jsload [res])))\n     10))\n   (when\n    (not-empty files-not-loaded)\n    (utils/log :debug \"Figwheel: NOT loading these files \")\n    (let\n     [{:keys [figwheel-no-load not-required]}\n      (group-by\n       (fn\n        [{:keys [namespace]}]\n        (let\n         [meta-data (get @figwheel-meta-pragmas (name namespace))]\n         (cond\n          (nil? meta-data)\n          :not-required\n          (meta-data :figwheel-no-load)\n          :figwheel-no-load\n          :else\n          :not-required)))\n       files-not-loaded)]\n     (when\n      (not-empty figwheel-no-load)\n      (utils/log\n       (str\n        \"figwheel-no-load meta-data: \"\n        (pr-str (map (comp name->path :namespace) figwheel-no-load)))))\n     (when\n      (not-empty not-required)\n      (utils/log\n       (str \"not required: \" (pr-str (map :file not-required))))))))))\n"} {:sym worker-import-script, :meta {:doc nil, :arglists ([request-url callback])}, :source "(defn\n worker-import-script\n [request-url callback]\n (dev-assert (string? request-url) (not (nil? callback)))\n (callback\n  (try\n   (do (.importScripts js/self (add-cache-buster request-url)) true)\n   (catch\n    js/Error\n    e\n    (utils/log\n     :error\n     (str \"Figwheel: Error loading file \" request-url))\n    (utils/log :error (.-stack e))\n    false))))\n"} {:sym reload-file, :meta {:doc nil, :arglists ([{:keys [request-url], :as file-msg} callback])}, :source "(defn\n reload-file\n [{:keys [request-url], :as file-msg} callback]\n (dev-assert (string? request-url) (not (nil? callback)))\n (utils/debug-prn (str \"FigWheel: Attempting to load \" request-url))\n ((or (gobj/get goog.global \"FIGWHEEL_IMPORT_SCRIPT\") reload-file*)\n  request-url\n  (fn\n   [success?]\n   (if\n    success?\n    (do\n     (utils/debug-prn\n      (str \"FigWheel: Successfully loaded \" request-url))\n     (apply callback [(assoc file-msg :loaded-file true)]))\n    (do\n     (utils/log\n      :error\n      (str \"Figwheel: Error loading file \" request-url))\n     (apply callback [file-msg]))))))\n"} {:sym dependency-data, :meta {}, :source "(defonce dependency-data (atom {:pathToName {}, :dependents {}}))\n"}), cljs.tools.reader.impl.inspect ({:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists [[x] [truncate x]]}, :source "(defn\n inspect\n \"Return a string description of the value supplied.\\n   May be the a string version of the value itself (e.g. \\\"true\\\")\\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\\n   If truncate is true then return a very terse version of\\n   the inspection.\"\n ([x] (inspect* false x))\n ([truncate x] (inspect* truncate x)))\n"}), sablono.core ({:sym wrap-attrs, :meta {:doc "Add an optional attribute argument to a function that returns a element vector.", :arglists ([func])}, :source "(defn\n wrap-attrs\n \"Add an optional attribute argument to a function that returns a element vector.\"\n [func]\n (fn\n  [& args]\n  (if\n   (map? (first args))\n   (let\n    [[tag & body] (apply func (rest args))]\n    (if\n     (map? (first body))\n     (into [tag (merge (first body) (first args))] (rest body))\n     (into [tag (first args)] body)))\n   (apply func args))))\n"} {:sym include-css, :meta {:doc "Include a list of external stylesheet files.", :arglists ([& styles])}, :source "(defn\n include-css\n \"Include a list of external stylesheet files.\"\n [& styles]\n (for\n  [style styles]\n  [:link {:type \"text/css\", :href (as-str style), :rel \"stylesheet\"}]))\n"} {:sym include-react, :meta {:doc "Include Facebook's React JavaScript library.", :arglists ([])}, :source "(defn\n include-react\n \"Include Facebook's React JavaScript library.\"\n []\n (include-js \"http://fb.me/react-0.12.2.js\"))\n"} {:sym *group*, :meta {}, :source "(def *group* [])\n"} {:sym file-upload, :meta {}, :source "(def file-upload file-field)\n"}), clojure.set ({:sym union, :meta {:doc "Return a set that is the union of the input sets", :arglists [[] [s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n union\n \"Return a set that is the union of the input sets\"\n ([] #{})\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce conj s2 s1)\n   (reduce conj s1 s2)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n   (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym map-invert, :meta {:doc "Returns the map with the vals mapped to the keys.", :arglists ([m])}, :source "(defn\n map-invert\n \"Returns the map with the vals mapped to the keys.\"\n [m]\n (reduce (fn [m [k v]] (assoc m v k)) {} m))\n"} {:sym join, :meta {:doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :arglists [[xrel yrel] [xrel yrel km]]}, :source "(defn\n join\n \"When passed 2 rels, returns the rel corresponding to the natural\\n  join. When passed an additional keymap, joins on the corresponding\\n  keys.\"\n ([xrel yrel]\n  (if\n   (and (seq xrel) (seq yrel))\n   (let\n    [ks\n     (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n     [r s]\n     (if (<= (count xrel) (count yrel)) [xrel yrel] [yrel xrel])\n     idx\n     (index r ks)]\n    (reduce\n     (fn\n      [ret x]\n      (let\n       [found (idx (select-keys x ks))]\n       (if\n        found\n        (reduce\n         (fn*\n          [p1__18460# p2__18461#]\n          (conj p1__18460# (merge p2__18461# x)))\n         ret\n         found)\n        ret)))\n     #{}\n     s))\n   #{}))\n ([xrel yrel km]\n  (let\n   [[r s k]\n    (if\n     (<= (count xrel) (count yrel))\n     [xrel yrel (map-invert km)]\n     [yrel xrel km])\n    idx\n    (index r (vals k))]\n   (reduce\n    (fn\n     [ret x]\n     (let\n      [found (idx (rename-keys (select-keys x (keys k)) k))]\n      (if\n       found\n       (reduce\n        (fn*\n         [p1__18462# p2__18463#]\n         (conj p1__18462# (merge p2__18463# x)))\n        ret\n        found)\n       ret)))\n    #{}\n    s))))\n"} {:sym select, :meta {:doc "Returns a set of the elements for which pred is true", :arglists ([pred xset])}, :source "(defn\n select\n \"Returns a set of the elements for which pred is true\"\n [pred xset]\n (reduce (fn [s k] (if (pred k) s (disj s k))) xset xset))\n"} {:sym intersection, :meta {:doc "Return a set that is the intersection of the input sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n intersection\n \"Return a set that is the intersection of the input sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s2) (count s1))\n   (recur s2 s1)\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) result (disj result item)))\n    s1\n    s1)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets\n    (bubble-max-key\n     (fn* [p1__18457#] (- (count p1__18457#)))\n     (conj sets s2 s1))]\n   (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym superset?, :meta {:doc "Is set1 a superset of set2?", :arglists ([set1 set2])}, :source "(defn\n superset?\n \"Is set1 a superset of set2?\"\n [set1 set2]\n (and\n  (>= (count set1) (count set2))\n  (every? (fn* [p1__18465#] (contains? set1 p1__18465#)) set2)))\n"} {:sym index, :meta {:doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :arglists ([xrel ks])}, :source "(defn\n index\n \"Returns a map of the distinct values of ks in the xrel mapped to a\\n  set of the maps in xrel with the corresponding values of ks.\"\n [xrel ks]\n (reduce\n  (fn\n   [m x]\n   (let [ik (select-keys x ks)] (assoc m ik (conj (get m ik #{}) x))))\n  {}\n  xrel))\n"} {:sym subset?, :meta {:doc "Is set1 a subset of set2?", :arglists ([set1 set2])}, :source "(defn\n subset?\n \"Is set1 a subset of set2?\"\n [set1 set2]\n (and\n  (<= (count set1) (count set2))\n  (every? (fn* [p1__18464#] (contains? set2 p1__18464#)) set1)))\n"} {:sym rename, :meta {:doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :arglists ([xrel kmap])}, :source "(defn\n rename\n \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n [xrel kmap]\n (set (map (fn* [p1__18459#] (rename-keys p1__18459# kmap)) xrel)))\n"} {:sym rename-keys, :meta {:doc "Returns the map with the keys in kmap renamed to the vals in kmap", :arglists ([map kmap])}, :source "(defn\n rename-keys\n \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n [map kmap]\n (reduce\n  (fn\n   [m [old new]]\n   (if (contains? map old) (assoc m new (get map old)) m))\n  (apply dissoc map (keys kmap))\n  kmap))\n"} {:sym project, :meta {:doc "Returns a rel of the elements of xrel with only the keys in ks", :arglists ([xrel ks])}, :source "(defn\n project\n \"Returns a rel of the elements of xrel with only the keys in ks\"\n [xrel ks]\n (set (map (fn* [p1__18458#] (select-keys p1__18458# ks)) xrel)))\n"} {:sym difference, :meta {:doc "Return a set that is the first set without elements of the remaining sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n difference\n \"Return a set that is the first set without elements of the remaining sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) (disj result item) result))\n    s1\n    s1)\n   (reduce disj s1 s2)))\n ([s1 s2 & sets] (reduce difference s1 (conj sets s2))))\n"}), reagent.impl.component ({:sym get-props, :meta {:doc nil, :arglists ([c])}, :source "(defn\n get-props\n [c]\n (let\n  [p ($ c :props)]\n  (if-some [v ($ p :argv)] (extract-props v) (shallow-obj-to-map p))))\n"} {:sym get-wrapper, :meta {:doc nil, :arglists ([key f name])}, :source "(defn\n get-wrapper\n [key f name]\n (let\n  [wrap (custom-wrapper key f)]\n  (when (and wrap f) (assert-callable f))\n  (or wrap f)))\n"} {:sym get-argv, :meta {:doc nil, :arglists ([c])}, :source "(defn get-argv [c] (props-argv c ($ c :props)))\n"} {:sym wrap-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n wrap-render\n [c]\n (let\n  [f\n   ($ c :reagentRender)\n   _\n   (assert-callable f)\n   res\n   (if\n    (true? ($ c :cljsLegacyRender))\n    (.call f c c)\n    (let\n     [v (get-argv c) n (count v)]\n     (case\n      n\n      1\n      (.call f c)\n      2\n      (.call f c (nth v 1))\n      3\n      (.call f c (nth v 1) (nth v 2))\n      4\n      (.call f c (nth v 1) (nth v 2) (nth v 3))\n      5\n      (.call f c (nth v 1) (nth v 2) (nth v 3) (nth v 4))\n      (.apply f c (.slice (into-array v) 1)))))]\n  (cond\n   (vector? res)\n   (as-element res)\n   (ifn? res)\n   (let\n    [f\n     (if\n      (reagent-class? res)\n      (fn [& args] (as-element (apply vector res args)))\n      res)]\n    ($! c :reagentRender f)\n    (recur c))\n   :else\n   res)))\n"} {:sym rat-opts, :meta {}, :source "(def rat-opts {:no-cache true})\n"} {:sym obligatory, :meta {}, :source "(def\n obligatory\n {:shouldComponentUpdate nil,\n  :componentWillMount nil,\n  :componentWillUnmount nil})\n"} {:sym props-argv, :meta {:doc nil, :arglists ([c p])}, :source "(defn\n props-argv\n [c p]\n (if-some [a ($ p :argv)] a [(.-constructor c) (shallow-obj-to-map p)]))\n"} {:sym as-element, :meta {}, :source "(defonce as-element nil)\n"} {:sym do-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n do-render\n [c]\n (binding\n  [*current-component* c]\n  (if\n   (dev?)\n   (let\n    [ok (array false)]\n    (try\n     (let [res (wrap-render c)] (aset ok 0 true) res)\n     (finally\n      (when-not\n       (aget ok 0)\n       (error (str \"Error rendering component\" (comp-name)))))))\n   (wrap-render c))))\n"} {:sym comp-name, :meta {:doc nil, :arglists ([])}, :source "(defn\n comp-name\n []\n (if\n  (dev?)\n  (let\n   [c\n    *current-component*\n    n\n    (or (component-path c) (some-> c .-constructor util/fun-name))]\n   (if-not (empty? n) (str \" (in \" n \")\") \"\"))\n  \"\"))\n"} {:sym add-obligatory, :meta {:doc nil, :arglists ([fun-map])}, :source "(defn add-obligatory [fun-map] (merge obligatory fun-map))\n"} {:sym cached-react-class, :meta {:doc nil, :arglists ([c])}, :source "(defn cached-react-class [c] ($ c :cljsReactClass))\n"} {:sym state-atom, :meta {:doc nil, :arglists ([this])}, :source "(defn\n state-atom\n [this]\n (let\n  [sa ($ this :cljsState)]\n  (if-not (nil? sa) sa ($! this :cljsState (ratom/atom nil)))))\n"} {:sym fiber-component-path, :meta {:doc nil, :arglists ([fiber])}, :source "(defn\n fiber-component-path\n [fiber]\n (let\n  [name\n   (some-> fiber ($ :type) ($ :displayName))\n   parent\n   (some-> fiber ($ :return))\n   path\n   (some-> parent fiber-component-path (str \" > \"))\n   res\n   (str path name)]\n  (when-not (empty? res) res)))\n"} {:sym dash-to-camel, :meta {}, :source "(def dash-to-camel (util/memoize-1 util/dash-to-camel))\n"} {:sym reagent-component?, :meta {:doc nil, :arglists ([c])}, :source "(defn reagent-component? [c] (some? ($ c :reagentRender)))\n"} {:sym static-fns, :meta {}, :source "(def\n static-fns\n {:render\n  (fn\n   render\n   []\n   (this-as\n    c\n    (if\n     util/*non-reactive*\n     (do-render c)\n     (let\n      [rat ($ c :cljsRatom)]\n      (batch/mark-rendered c)\n      (if\n       (nil? rat)\n       (ratom/run-in-reaction\n        (fn* [] (do-render c))\n        c\n        \"cljsRatom\"\n        batch/queue-render\n        rat-opts)\n       (._run rat false))))))})\n"} {:sym as-class, :meta {:doc nil, :arglists ([tag])}, :source "(defn\n as-class\n [tag]\n (if-some\n  [cached-class (cached-react-class tag)]\n  cached-class\n  (fn-to-class tag)))\n"} {:sym reagent-class?, :meta {:doc nil, :arglists ([c])}, :source "(defn\n reagent-class?\n [c]\n (and (fn? c) (some? (some-> c .-prototype ($ :reagentRender)))))\n"} {:sym fn-to-class, :meta {:doc nil, :arglists ([f])}, :source "(defn\n fn-to-class\n [f]\n (assert-callable f)\n (warn-unless\n  (not (and (react-class? f) (not (reagent-class? f))))\n  \"Using native React classes directly in Hiccup forms \"\n  \"is not supported. Use create-element or \"\n  \"adapt-react-class instead: \"\n  (let [n (util/fun-name f)] (if (empty? n) f n))\n  (comp-name))\n (if\n  (reagent-class? f)\n  (cache-react-class f f)\n  (let\n   [spec\n    (meta f)\n    withrender\n    (assoc spec :reagent-render f)\n    res\n    (create-class withrender)]\n   (cache-react-class f res))))\n"} {:sym reactify-component, :meta {:doc nil, :arglists ([comp])}, :source "(defn\n reactify-component\n [comp]\n (if (react-class? comp) comp (as-class comp)))\n"} {:sym extract-children, :meta {:doc nil, :arglists ([v])}, :source "(defn\n extract-children\n [v]\n (let\n  [p (nth v 1 nil) first-child (if (or (nil? p) (map? p)) 2 1)]\n  (if (> (count v) first-child) (subvec v first-child))))\n"} {:sym component-path, :meta {:doc nil, :arglists ([c])}, :source "(defn\n component-path\n [c]\n (if-let\n  [fiber (some-> c ($ :_reactInternalFiber))]\n  (fiber-component-path fiber)\n  (let\n   [elem\n    (or\n     (some->\n      (or (some-> c ($ :_reactInternalInstance)) c)\n      ($ :_currentElement)))\n    name\n    (some-> elem ($ :type) ($ :displayName))\n    path\n    (some-> elem ($ :_owner) component-path (str \" > \"))\n    res\n    (str path name)]\n   (when-not (empty? res) res))))\n"} {:sym extract-props, :meta {:doc nil, :arglists ([v])}, :source "(defn extract-props [v] (let [p (nth v 1 nil)] (if (map? p) p)))\n"} {:sym get-children, :meta {:doc nil, :arglists ([c])}, :source "(defn\n get-children\n [c]\n (let\n  [p ($ c :props)]\n  (if-some\n   [v ($ p :argv)]\n   (extract-children v)\n   (->> ($ p :children) (react/Children.toArray) (into [])))))\n"} {:sym camelify-map-keys, :meta {:doc nil, :arglists ([fun-map])}, :source "(defn\n camelify-map-keys\n [fun-map]\n (reduce-kv\n  (fn [m k v] (assoc m (-> k dash-to-camel keyword) v))\n  {}\n  fun-map))\n"} {:sym shallow-obj-to-map, :meta {:doc nil, :arglists ([o])}, :source "(defn\n shallow-obj-to-map\n [o]\n (let\n  [ks (js-keys o) len (alength ks)]\n  (loop\n   [m {} i 0]\n   (if\n    (< i len)\n    (let\n     [k (aget ks i)]\n     (recur (assoc m (keyword k) (aget o k)) (inc i)))\n    m))))\n"} {:sym cljsify, :meta {:doc nil, :arglists ([body])}, :source "(defn\n cljsify\n [body]\n (-> body camelify-map-keys add-obligatory wrap-funs map-to-js))\n"} {:sym react-class?, :meta {:doc nil, :arglists ([c])}, :source "(defn\n react-class?\n [c]\n (and (fn? c) (some? (some-> c .-prototype ($ :render)))))\n"} {:sym cache-react-class, :meta {:doc nil, :arglists ([c constructor])}, :source "(defn\n cache-react-class\n [c constructor]\n ($! c :cljsReactClass constructor))\n"} {:sym custom-wrapper, :meta {:doc nil, :arglists ([key f])}, :source "(defn\n custom-wrapper\n [key f]\n (case\n  key\n  :getDefaultProps\n  (throw (js/Error. \"getDefaultProps not supported\"))\n  :getInitialState\n  (fn\n   getInitialState\n   []\n   (this-as c (reset! (state-atom c) (.call f c c))))\n  :componentWillReceiveProps\n  (fn\n   componentWillReceiveProps\n   [nextprops]\n   (this-as c (.call f c c (props-argv c nextprops))))\n  :shouldComponentUpdate\n  (fn\n   shouldComponentUpdate\n   [nextprops nextstate]\n   (or\n    util/*always-update*\n    (this-as\n     c\n     (let\n      [old-argv\n       ($ c :props.argv)\n       new-argv\n       ($ nextprops :argv)\n       noargv\n       (or (nil? old-argv) (nil? new-argv))]\n      (cond\n       (nil? f)\n       (or noargv (not= old-argv new-argv))\n       noargv\n       (.call f c c (get-argv c) (props-argv c nextprops))\n       :else\n       (.call f c c old-argv new-argv))))))\n  :componentWillUpdate\n  (fn\n   componentWillUpdate\n   [nextprops]\n   (this-as c (.call f c c (props-argv c nextprops))))\n  :componentDidUpdate\n  (fn\n   componentDidUpdate\n   [oldprops]\n   (this-as c (.call f c c (props-argv c oldprops))))\n  :componentWillMount\n  (fn\n   componentWillMount\n   []\n   (this-as\n    c\n    ($! c :cljsMountOrder (batch/next-mount-count))\n    (when-not (nil? f) (.call f c c))))\n  :componentDidMount\n  (fn componentDidMount [] (this-as c (.call f c c)))\n  :componentWillUnmount\n  (fn\n   componentWillUnmount\n   []\n   (this-as\n    c\n    (some-> ($ c :cljsRatom) ratom/dispose!)\n    (batch/mark-rendered c)\n    (when-not (nil? f) (.call f c c))))\n  :componentDidCatch\n  (fn\n   componentDidCatch\n   [error info]\n   (this-as c (.call f c c error info)))\n  nil))\n"} {:sym create-class, :meta {:doc nil, :arglists ([body])}, :source "(defn\n create-class\n [body]\n {:pre [(map? body)]}\n (->> body cljsify create-react-class))\n"} {:sym wrap-funs, :meta {:doc nil, :arglists ([fmap])}, :source "(defn\n wrap-funs\n [fmap]\n (when\n  (dev?)\n  (let\n   [renders\n    (select-keys fmap [:render :reagentRender :componentFunction])\n    render-fun\n    (-> renders vals first)]\n   (assert (pos? (count renders)) \"Missing reagent-render\")\n   (assert (== 1 (count renders)) \"Too many render functions supplied\")\n   (assert-callable render-fun)))\n (let\n  [render-fun\n   (or (:reagentRender fmap) (:componentFunction fmap))\n   legacy-render\n   (nil? render-fun)\n   render-fun\n   (or render-fun (:render fmap))\n   name\n   (str (or (:displayName fmap) (util/fun-name render-fun)))\n   name\n   (case name \"\" (str (gensym \"reagent\")) name)\n   fmap\n   (reduce-kv (fn [m k v] (assoc m k (get-wrapper k v name))) {} fmap)]\n  (assoc\n   fmap\n   :displayName\n   name\n   :autobind\n   false\n   :cljsLegacyRender\n   legacy-render\n   :reagentRender\n   render-fun\n   :render\n   (:render static-fns))))\n"}), paren-soup.instarepl ({:sym elem?, :meta {}, :source "(def elem? (fn* [p1__18510#] (instance? js/Element p1__18510#)))\n"} {:sym elems->locations, :meta {:doc "Returns the location of each elem.", :arglists ([elems top-offset])}, :source "(defn\n elems->locations\n \"Returns the location of each elem.\"\n [elems top-offset]\n (loop\n  [i 0 locations (transient [])]\n  (if-let\n   [elem (get elems i)]\n   (let\n    [top\n     (-> elem .-offsetTop (- top-offset))\n     height\n     (-> elem .-offsetHeight)]\n    (recur (inc i) (conj! locations {:top top, :height height})))\n   (persistent! locations))))\n"} {:sym results->html, :meta {:doc "Returns HTML for the given eval results.", :arglists ([results locations])}, :source "(defn\n results->html\n \"Returns HTML for the given eval results.\"\n [results locations]\n (loop\n  [i 0 evals (transient [])]\n  (let\n   [res (get results i) {:keys [top height]} (get locations i)]\n   (if\n    (and res top height)\n    (recur\n     (inc i)\n     (conj!\n      evals\n      (format\n       \"<div class='%s' style='top: %spx; height: %spx; min-height: %spx'>%s</div>\"\n       (if (array? res) \"result error\" \"result\")\n       top\n       height\n       height\n       (some-> (if (array? res) (first res) res) hs/escape-html-str))))\n    (join (persistent! evals))))))\n"} {:sym get-collections, :meta {:doc "Returns collections from the given DOM node.", :arglists ([element])}, :source "(defn\n get-collections\n \"Returns collections from the given DOM node.\"\n [element]\n (vec\n  (for\n   [elem\n    (-> element .-children array-seq)\n    :let\n    [classes (.-classList elem)]\n    :when\n    (or (.contains classes \"collection\") (.contains classes \"symbol\"))]\n   elem)))\n"} {:sym collection->content, :meta {:doc nil, :arglists ([elem])}, :source "(defn\n collection->content\n [elem]\n (loop\n  [e elem content (.-textContent elem)]\n  (if-let\n   [prev (.-previousSibling e)]\n   (if\n    (text-node? prev)\n    (recur prev (str (.-textContent prev) content))\n    content)\n   content)))\n"} {:sym create-compiler-fn, :meta {:doc nil, :arglists ([])}, :source "(defn\n create-compiler-fn\n []\n (try\n  (let\n   [eval-worker (js/Worker. \"paren-soup-compiler.js\")]\n   (fn\n    [coll receive-fn]\n    (set!\n     (.-onmessage eval-worker)\n     (fn* [p1__18511#] (receive-fn (vec (.-data p1__18511#)))))\n    (.postMessage eval-worker (into-array coll))))\n  (catch js/Error _ (fn [_ _] (throw js/Error \"Can't compile!\")))))\n"}), dynadoc.state ({:sym *state, :meta {}, :source "(defonce *state (atom {}))\n"}), cljs.pprint ({:sym pprint, :meta {:doc nil, :arglists [[object] [object writer]]}, :source "(defn\n pprint\n ([object]\n  (let\n   [sb (StringBuffer.)]\n   (binding\n    [*out* (StringBufferWriter. sb)]\n    (pprint object *out*)\n    (string-print (str sb)))))\n ([object writer]\n  (with-pretty-writer\n   writer\n   (binding [*print-pretty* true] (write-out object))\n   (if (not (= 0 (get-column *out*))) (-write *out* \\newline)))))\n"} {:sym get-pretty-writer, :meta {:doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :arglists ([writer])}, :source "(defn\n get-pretty-writer\n \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\\nwrite, and cl-format all call it if they need to. However if you want the state to be\\npreserved across calls, you will want to wrap them with this.\\n\\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\\ndo it like in this example:\\n\\n    (defn print-table [aseq column-width]\\n      (binding [*out* (get-pretty-writer *out*)]\\n        (doseq [row aseq]\\n          (doseq [col row]\\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\\n          (prn))))\\n\\nNow when you run:\\n\\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\\n\\nIt prints a table of squares and cubes for the numbers from 1 to 10:\\n\\n       1      1       1\\n       2      4       8\\n       3      9      27\\n       4     16      64\\n       5     25     125\\n       6     36     216\\n       7     49     343\\n       8     64     512\\n       9     81     729\\n      10    100    1000\"\n [writer]\n (if\n  (pretty-writer? writer)\n  writer\n  (pretty-writer writer *print-right-margin* *print-miser-width*)))\n"} {:sym *print-suppress-namespaces*, :meta {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"}, :source "(def *print-suppress-namespaces* nil)\n"} {:sym char-code, :meta {:doc "Convert char to int", :arglists ([c])}, :source "(defn\n char-code\n \"Convert char to int\"\n [c]\n (cond\n  (number? c)\n  c\n  (and (string? c) (== (.-length c) 1))\n  (.charCodeAt c 0)\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym *print-pretty*, :meta {:doc "Bind to true if you want write to use pretty printing"}, :source "(def *print-pretty* true)\n"} {:sym *print-pprint-dispatch*, :meta {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."}, :source "(defonce *print-pprint-dispatch* nil)\n"} {:sym pprint-newline, :meta {:doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :arglists ([kind])}, :source "(defn\n pprint-newline\n \"Print a conditional newline to a pretty printing stream. kind specifies if the\\n  newline is :linear, :miser, :fill, or :mandatory.\\n\\n  This function is intended for use when writing custom dispatch functions.\\n\\n  Output is sent to *out* which must be a pretty printing writer.\"\n [kind]\n (check-enumerated-arg kind #{:mandatory :miser :fill :linear})\n (nl *out* kind))\n"} {:sym float?, :meta {:doc "Returns true if n is an float.", :arglists ([n])}, :source "(defn\n float?\n \"Returns true if n is an float.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (not (== (js/parseFloat n) (js/parseInt n 10)))))\n"} {:sym pprint-tab, :meta {:doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :arglists ([kind colnum colinc])}, :source "(defn\n pprint-tab\n \"Tab at this point in the pretty printing stream. kind specifies whether the tab\\nis :line, :section, :line-relative, or :section-relative.\\n\\nColnum and colinc specify the target column and the increment to move the target\\nforward if the output is already past the original target.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\\n\\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n {:added \"1.2\"}\n [kind colnum colinc]\n (check-enumerated-arg\n  kind\n  #{:section :line :line-relative :section-relative})\n (throw (js/Error. \"pprint-tab is not yet implemented\")))\n"} {:sym pprint-set, :meta {}, :source "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))\n"} {:sym print-table, :meta {:doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :arglists [[ks rows] [rows]]}, :source "(defn\n print-table\n \"Prints a collection of maps in a textual table. Prints table headings\\n   ks, and then a line of output for each row, corresponding to the keys\\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n {:added \"1.3\"}\n ([ks rows]\n  (binding\n   [*print-newline*]\n   (when\n    (seq rows)\n    (let\n     [widths\n      (map\n       (fn\n        [k]\n        (apply\n         max\n         (count (str k))\n         (map\n          (fn* [p1__18646#] (count (str (get p1__18646# k))))\n          rows)))\n       ks)\n      spacers\n      (map\n       (fn* [p1__18647#] (apply str (repeat p1__18647# \"-\")))\n       widths)\n      fmt-row\n      (fn\n       [leader divider trailer row]\n       (str\n        leader\n        (apply\n         str\n         (interpose\n          divider\n          (for\n           [[col width]\n            (map\n             vector\n             (map (fn* [p1__18648#] (get row p1__18648#)) ks)\n             widths)]\n           (add-padding width (str col)))))\n        trailer))]\n     (cljs.core/println)\n     (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n     (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n     (doseq\n      [row rows]\n      (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n ([rows] (print-table (keys (first rows)) rows)))\n"} {:sym set-pprint-dispatch, :meta {:doc nil, :arglists ([function])}, :source "(defn\n set-pprint-dispatch\n [function]\n (set! *print-pprint-dispatch* function)\n nil)\n"} {:sym fresh-line, :meta {:doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :arglists ([])}, :source "(defn\n fresh-line\n \"Make a newline if *out* is not already at the beginning of the line. If *out* is\\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n []\n (if\n  (satisfies? IDeref *out*)\n  (if (not (= 0 (get-column (:base @@*out*)))) (prn))\n  (prn)))\n"} {:sym pprint-indent, :meta {:doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :arglists ([relative-to n])}, :source "(defn\n pprint-indent\n \"Create an indent at this point in the pretty printing stream. This defines how\\nfollowing lines are indented. relative-to can be either :block or :current depending\\nwhether the indent should be computed relative to the start of the logical block or\\nthe current column position. n is an offset.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\"\n [relative-to n]\n (check-enumerated-arg relative-to #{:block :current})\n (indent *out* relative-to n))\n"} {:sym *print-radix*, :meta {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "}, :source "(def *print-radix* nil)\n"} {:sym IPrettyFlush, :meta {:doc nil}, :methods (-ppflush)} {:sym cl-format, :meta {:doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :arglists ([writer format-in & args])}, :source "(defn\n cl-format\n \"An implementation of a Common Lisp compatible format function. cl-format formats its\\narguments to an output stream or string based on the format control string given. It\\nsupports sophisticated formatting of structured data.\\n\\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\\nto a string, format-in is the format control string and the remaining arguments\\nare the data to be formatted.\\n\\nThe format control string is a string to be output with embedded 'format directives'\\ndescribing how to format the various arguments passed in.\\n\\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\\nreturns nil.\\n\\nFor example:\\n (let [results [46 38 22]]\\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\\n                   (count results) results))\\n\\nPrints via *print-fn*:\\n There are 3 results: 46, 38, 22\\n\\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\\nand in the Common Lisp HyperSpec at\\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n {:see-also\n  [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n    \"Common Lisp the Language\"]\n   [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n    \"Common Lisp HyperSpec\"]]}\n [writer format-in & args]\n (let\n  [compiled-format\n   (if (string? format-in) (compile-format format-in) format-in)\n   navigator\n   (init-navigator args)]\n  (execute-format writer compiled-format navigator)))\n"} {:sym *print-miser-width*, :meta {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."}, :source "(def *print-miser-width* 40)\n"} {:sym write, :meta {:doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :arglists ([object & kw-args])}, :source "(defn\n write\n \"Write an object subject to the current bindings of the printer control variables.\\nUse the kw-args argument to override individual variables for this call (and any\\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\\n\\nThe following keyword arguments can be passed with values:\\n  Keyword              Meaning                              Default value\\n  :stream              Writer for output or nil             true (indicates *out*)\\n  :base                Base to use for writing rationals    Current value of *print-base*\\n  :circle*             If true, mark circular structures    Current value of *print-circle*\\n  :length              Maximum elements to show in sublists Current value of *print-length*\\n  :level               Maximum depth                        Current value of *print-level*\\n  :lines*              Maximum lines of output              Current value of *print-lines*\\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\\n  :readably*           If true, print readably              Current value of *print-readably*\\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\\n\\n  * = not yet supported\\n\"\n [object & kw-args]\n (let\n  [options (merge {:stream true} (apply hash-map kw-args))]\n  (binding\n   [cljs.pprint/*print-base*\n    (:base options cljs.pprint/*print-base*)\n    cljs.pprint/*print-circle*\n    (:circle options cljs.pprint/*print-circle*)\n    cljs.core/*print-length*\n    (:length options cljs.core/*print-length*)\n    cljs.core/*print-level*\n    (:level options cljs.core/*print-level*)\n    cljs.pprint/*print-lines*\n    (:lines options cljs.pprint/*print-lines*)\n    cljs.pprint/*print-miser-width*\n    (:miser-width options cljs.pprint/*print-miser-width*)\n    cljs.pprint/*print-pprint-dispatch*\n    (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n    cljs.pprint/*print-pretty*\n    (:pretty options cljs.pprint/*print-pretty*)\n    cljs.pprint/*print-radix*\n    (:radix options cljs.pprint/*print-radix*)\n    cljs.core/*print-readably*\n    (:readably options cljs.core/*print-readably*)\n    cljs.pprint/*print-right-margin*\n    (:right-margin options cljs.pprint/*print-right-margin*)\n    cljs.pprint/*print-suppress-namespaces*\n    (:suppress-namespaces\n     options\n     cljs.pprint/*print-suppress-namespaces*)]\n   (binding\n    []\n    (let\n     [sb\n      (StringBuffer.)\n      optval\n      (if (contains? options :stream) (:stream options) true)\n      base-writer\n      (if\n       (or (true? optval) (nil? optval))\n       (StringBufferWriter. sb)\n       optval)]\n     (if\n      *print-pretty*\n      (with-pretty-writer base-writer (write-out object))\n      (binding [*out* base-writer] (pr object)))\n     (if (true? optval) (string-print (str sb)))\n     (if (nil? optval) (str sb)))))))\n"} {:sym -ppflush, :meta {:doc nil, :arglists ([pp])}, :protocol IPrettyFlush} {:sym *print-right-margin*, :meta {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."}, :source "(def *print-right-margin* 72)\n"} {:sym write-out, :meta {:doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :arglists ([object])}, :source "(defn\n write-out\n \"Write an object to *out* subject to the current bindings of the printer control\\nvariables. Use the kw-args argument to override individual variables for this call (and\\nany recursive calls).\\n\\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\\nof the caller.\\n\\nThis method is primarily intended for use by pretty print dispatch functions that\\nalready know that the pretty printer will have set up their environment appropriately.\\nNormal library clients should use the standard \\\"write\\\" interface. \"\n [object]\n (let\n  [length-reached\n   (and\n    *current-length*\n    *print-length*\n    (>= *current-length* *print-length*))]\n  (if-not\n   *print-pretty*\n   (pr object)\n   (if\n    length-reached\n    (-write *out* \"...\")\n    (do\n     (if\n      *current-length*\n      (set! *current-length* (inc *current-length*)))\n     (*print-pprint-dispatch* object))))\n  length-reached))\n"} {:sym *print-base*, :meta {:doc "The base to use for printing integers and rationals."}, :source "(def *print-base* 10)\n"}), oakcljs.tools.reader.impl.inspect ({:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists [[x] [truncate x]]}, :source "(defn\n inspect\n \"Return a string description of the value supplied.\\n   May be the a string version of the value itself (e.g. \\\"true\\\")\\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\\n   If truncate is true then return a very terse version of\\n   the inspection.\"\n ([x] (inspect* false x))\n ([truncate x] (inspect* truncate x)))\n"}), cljs.tools.reader.impl.utils ({:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :source "(defn\n reader-conditional\n \"Construct a data representation of a reader conditional.\\n  If true, splicing? indicates read-cond-splicing.\"\n [form splicing?]\n (ReaderConditional. splicing? form))\n"} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :source "(defn\n whitespace?\n \"Checks whether a given character is whitespace\"\n [ch]\n (when-not (nil? ch) (if (identical? ch \\,) true (.test ws-rx ch))))\n"} {:sym last-id, :meta {}, :source "(def last-id (atom 0))\n"} {:sym char, :meta {:doc nil, :arglists ([x])}, :source "(defn char [x] (when-not (nil? x) (cljs.core/char x)))\n"} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :source "(defn\n numeric?\n \"Checks whether a given character is numeric\"\n [ch]\n (when-not (nil? ch) (gstring/isNumeric ch)))\n"} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :source "(defn second' [[a b]] (when-not a b))\n"} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :source "(defn\n desugar-meta\n \"Resolves syntactical sugar in metadata\"\n [f]\n (cond\n  (keyword? f)\n  {f true}\n  (symbol? f)\n  {:tag f}\n  (string? f)\n  {:tag f}\n  :else\n  f))\n"} {:sym next-id, :meta {:doc nil, :arglists ([])}, :source "(defn next-id [] (swap! last-id inc))\n"} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :source "(defn ex-info? [ex] (instance? cljs.core.ExceptionInfo ex))\n"} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :source "(defn\n reader-conditional?\n \"Return true if the value is the data representation of a reader conditional\"\n [value]\n (instance? ReaderConditional value))\n"} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :source "(defn\n newline?\n \"Checks whether the character is a newline\"\n [c]\n (or (identical? \\newline c) (identical? \"\\n\" c) (nil? c)))\n"} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :source "(defn\n namespace-keys\n [ns keys]\n (for\n  [key keys]\n  (if\n   (or (symbol? key) (keyword? key))\n   (let\n    [[key-ns key-name]\n     ((juxt namespace name) key)\n     ->key\n     (if (symbol? key) symbol keyword)]\n    (cond\n     (nil? key-ns)\n     (->key ns key-name)\n     (= \"_\" key-ns)\n     (->key key-name)\n     :else\n     key))\n   key)))\n"} {:sym ws-rx, :meta {}, :source "(def ws-rx #\"[\\s]\")\n"}), figwheel.client ({:sym focus-msgs, :meta {:doc nil, :arglists ([name-set msg-hist])}, :source "(defn\n focus-msgs\n [name-set msg-hist]\n (cons\n  (first msg-hist)\n  (filter (comp name-set :msg-name) (rest msg-hist))))\n"} {:sym handle-deprecated-jsload-callback, :meta {:doc nil, :arglists ([config])}, :source "(defn\n handle-deprecated-jsload-callback\n [config]\n (if\n  (:jsload-callback config)\n  (->\n   config\n   (assoc :on-jsload (:jsload-callback config))\n   (dissoc :jsload-callback))\n  config))\n"} {:sym default-on-compile-fail, :meta {:doc nil, :arglists ([{:keys [formatted-exception exception-data cause], :as ed}])}, :source "(defn\n default-on-compile-fail\n [{:keys [formatted-exception exception-data cause], :as ed}]\n (utils/log :debug \"Figwheel: Compile Exception\")\n (doseq [msg (format-messages exception-data)] (utils/log :info msg))\n (if cause (utils/log :info (str \"Error on \" (file-line-column ed))))\n ed)\n"} {:sym reload-file?*, :meta {:doc nil, :arglists ([msg-name opts])}, :source "(defn\n reload-file?*\n [msg-name opts]\n (or (:load-warninged-code opts) (not= msg-name :compile-warning)))\n"} {:sym add-json-message-watch, :meta {:doc nil, :arglists ([key callback])}, :source "(defn\n add-json-message-watch\n [key callback]\n (add-message-watch key (comp callback clj->js)))\n"} {:sym enforce-figwheel-version-plugin, :meta {:doc nil, :arglists ([opts])}, :source "(defn\n enforce-figwheel-version-plugin\n [opts]\n (fn\n  [msg-hist]\n  (when-let\n   [figwheel-version (-> msg-hist first :figwheel-version)]\n   (when\n    (not= figwheel-version _figwheel-version_)\n    (socket/close!)\n    (.error\n     js/console\n     \"Figwheel: message received from different version of Figwheel.\")\n    (when\n     (:heads-up-display opts)\n     (go\n      (<! (timeout 2000))\n      (heads-up/display-system-warning\n       \"Figwheel Client and Server have different versions!!\"\n       (str\n        \"Figwheel Client Version <strong>\"\n        _figwheel-version_\n        \"</strong> is not equal to \"\n        \"Figwheel Sidecar Version <strong>\"\n        figwheel-version\n        \"</strong>\"\n        \".  Shutting down Websocket Connection!\"\n        \"<h4>To fix try:</h4>\"\n        \"<ol><li>Reload this page and make sure you are not getting a cached version of the client.</li>\"\n        \"<li>You may have to clean (delete compiled assets) and rebuild to make sure that the new client code is being used.</li>\"\n        \"<li>Also, make sure you have consistent Figwheel dependencies.</li></ol>\"))))))))\n"} {:sym repl-result-pr-str, :meta {:doc nil, :arglists ([v])}, :source "(defn\n repl-result-pr-str\n [v]\n (if (repl-pprint) (utils/pprint-to-string v) (pr-str v)))\n"} {:sym error-msg-format, :meta {:doc nil, :arglists ([{:keys [message class]}])}, :source "(defn\n error-msg-format\n [{:keys [message class]}]\n (str class \" : \" message))\n"} {:sym compile-fail-warning-plugin, :meta {:doc nil, :arglists ([{:keys [on-compile-warning on-compile-fail]}])}, :source "(defn\n compile-fail-warning-plugin\n [{:keys [on-compile-warning on-compile-fail]}]\n (fn\n  [[{:keys [msg-name], :as msg} & _]]\n  (condp\n   =\n   msg-name\n   :compile-warning\n   (on-compile-warning msg)\n   :compile-failed\n   (on-compile-fail msg)\n   nil)))\n"} {:sym console-intro-message, :meta {}, :source "(def\n console-intro-message\n \"Figwheel has compiled a temporary helper application to your :output-file.\\n\\nThe code currently in your configured output file does not\\nrepresent the code that you are trying to compile.\\n\\nThis temporary application is intended to help you continue to get\\nfeedback from Figwheel until the build you are working on compiles\\ncorrectly.\\n\\nWhen your ClojureScript source code compiles correctly this helper\\napplication will auto-reload and pick up your freshly compiled\\nClojureScript program.\")\n"} {:sym add-message-watch, :meta {:doc nil, :arglists ([key callback])}, :source "(defn\n add-message-watch\n [key callback]\n (add-watch\n  socket/message-history-atom\n  key\n  (fn [_ _ _ msg-hist] (callback (first msg-hist)))))\n"} {:sym auto-jump-to-error, :meta {:doc nil, :arglists ([opts error])}, :source "(defn\n auto-jump-to-error\n [opts error]\n (when\n  (:auto-jump-to-source-on-error opts)\n  (heads-up/auto-notify-source-file-line error)))\n"} {:sym repl-out-print-fn, :meta {:doc nil, :arglists ([& args])}, :source "(defn\n repl-out-print-fn\n [& args]\n (console-out-print args)\n (figwheel-repl-print :out args)\n nil)\n"} {:sym add-plugins, :meta {:doc nil, :arglists ([plugins system-options])}, :source "(defn\n add-plugins\n [plugins system-options]\n (doseq\n  [[k plugin] plugins]\n  (when\n   plugin\n   (let\n    [pl (plugin system-options)]\n    (add-watch\n     socket/message-history-atom\n     k\n     (fn [_ _ _ msg-hist] (pl msg-hist)))))))\n"} {:sym set-repl-pprint, :meta {:doc "This method gives you the ability to turn the pretty printing of\n  the REPL's return value on and off.\n\n  (figwheel.client/set-repl-pprint false)\n\n  NOTE: This is a persistent setting, meaning that it will persist\n  through browser reloads.", :arglists ([b])}, :source "(defn\n set-repl-pprint\n \"This method gives you the ability to turn the pretty printing of\\n  the REPL's return value on and off.\\n\\n  (figwheel.client/set-repl-pprint false)\\n\\n  NOTE: This is a persistent setting, meaning that it will persist\\n  through browser reloads.\"\n [b]\n (assert (or (true? b) (false? b)))\n (utils/persistent-config-set! :figwheel-repl-pprint b))\n"} {:sym bad-compile-helper-app, :meta {:doc nil, :arglists ([])}, :source "(defn\n bad-compile-helper-app\n []\n (enable-console-print!)\n (let\n  [config (fetch-data-from-env)]\n  (println console-intro-message)\n  (heads-up/bad-compile-screen)\n  (when-not js/goog.dependencies_ (set! js/goog.dependencies_ true))\n  (start config)\n  (add-message-watch\n   :listen-for-successful-compile\n   (fn\n    [{:keys [msg-name]}]\n    (when\n     (= msg-name :files-changed)\n     (set! js/location.href js/location.href))))))\n"} {:sym figwheel-repl-print, :meta {:doc nil, :arglists [[stream args] [args]]}, :source "(defn\n figwheel-repl-print\n ([stream args]\n  (socket/send!\n   {:figwheel-event \"callback\",\n    :callback-name \"figwheel-repl-print\",\n    :content\n    {:stream stream,\n     :args\n     (mapv\n      (fn*\n       [p1__18479#]\n       (if (string? p1__18479#) p1__18479# (js-stringify p1__18479#)))\n      args)}})\n  nil)\n ([args] (figwheel-repl-print :out args)))\n"} {:sym file-reloader-plugin, :meta {:doc nil, :arglists ([opts])}, :source "(defn\n file-reloader-plugin\n [opts]\n (let\n  [ch (chan)]\n  (go-loop\n   []\n   (when-let\n    [msg-hist' (<! ch)]\n    (let\n     [msg-hist\n      (focus-msgs #{:compile-warning :files-changed} msg-hist')\n      msg-names\n      (map :msg-name msg-hist)\n      msg\n      (first msg-hist)]\n     (if\n      (autoload?)\n      (cond\n       (reload-file-state? msg-names opts)\n       (alts! [(reloading/reload-js-files opts msg) (timeout 1000)])\n       (block-reload-file-state? msg-names opts)\n       (utils/log\n        :warn\n        (str\n         \"Figwheel: Not loading code with warnings - \"\n         (-> msg :files first :file))))\n      (do\n       (utils/log :warn \"Figwheel: code autoloading is OFF\")\n       (utils/log\n        :info\n        (str \"Not loading: \" (map :file (:files msg))))))\n     (recur))))\n  (fn [msg-hist] (put! ch msg-hist) msg-hist)))\n"} {:sym repl-pprint, :meta {:doc nil, :arglists ([])}, :source "(defn\n repl-pprint\n []\n (utils/persistent-config-get :figwheel-repl-pprint true))\n"} {:sym set-autoload, :meta {:doc "Figwheel by default loads code changes as you work. Sometimes you\n  just want to work on your code without the ramifications of\n  autoloading and simply load your code piecemeal in the REPL. You can\n  turn autoloading on and of with this method.\n\n  (figwheel.client/set-autoload false)\n\n  NOTE: This is a persistent setting, meaning that it will persist\n  through browser reloads.", :arglists ([b])}, :source "(defn\n set-autoload\n \"Figwheel by default loads code changes as you work. Sometimes you\\n  just want to work on your code without the ramifications of\\n  autoloading and simply load your code piecemeal in the REPL. You can\\n  turn autoloading on and of with this method.\\n\\n  (figwheel.client/set-autoload false)\\n\\n  NOTE: This is a persistent setting, meaning that it will persist\\n  through browser reloads.\"\n [b]\n (assert (or (true? b) (false? b)))\n (utils/persistent-config-set! :figwheel-autoload b))\n"} {:sym get-ua-product, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-ua-product\n []\n (cond\n  (utils/node-env?)\n  :chrome\n  product/SAFARI\n  :safari\n  product/CHROME\n  :chrome\n  product/FIREFOX\n  :firefox\n  product/IE\n  :ie))\n"} {:sym heads-up-plugin-msg-handler, :meta {:doc nil, :arglists ([opts msg-hist'])}, :source "(defn\n heads-up-plugin-msg-handler\n [opts msg-hist']\n (let\n  [msg-hist\n   (focus-msgs\n    #{:compile-failed :compile-warning :files-changed}\n    msg-hist')\n   msg-names\n   (map :msg-name msg-hist)\n   msg\n   (first msg-hist)]\n  (go\n   (cond\n    (reload-file-state? msg-names opts)\n    (if\n     (and (autoload?) (:autoload opts))\n     (<! (heads-up/flash-loaded))\n     (<! (heads-up/clear)))\n    (compile-refail-state? msg-names)\n    (do\n     (<! (heads-up/clear))\n     (<! (heads-up/display-exception (:exception-data msg)))\n     (auto-jump-to-error opts (:exception-data msg)))\n    (compile-fail-state? msg-names)\n    (do\n     (<! (heads-up/display-exception (:exception-data msg)))\n     (auto-jump-to-error opts (:exception-data msg)))\n    (warning-append-state? msg-names)\n    (heads-up/append-warning-message (:message msg))\n    (rewarning-state? msg-names)\n    (do\n     (<! (heads-up/clear))\n     (<! (heads-up/display-warning (:message msg)))\n     (auto-jump-to-error opts (:message msg)))\n    (warning-state? msg-names)\n    (do\n     (<! (heads-up/display-warning (:message msg)))\n     (auto-jump-to-error opts (:message msg)))\n    (css-loaded-state? msg-names)\n    (<! (heads-up/flash-loaded))))))\n"} {:sym watch-and-reload-with-opts, :meta {}, :source "(def watch-and-reload-with-opts start)\n"} {:sym compile-fail-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn\n compile-fail-state?\n [msg-names]\n (= :compile-failed (first msg-names)))\n"} {:sym format-messages, :meta {}, :source "(def\n format-messages\n (comp (partial map error-msg-format) get-essential-messages))\n"} {:sym css-reloader-plugin, :meta {:doc nil, :arglists ([opts])}, :source "(defn\n css-reloader-plugin\n [opts]\n (fn\n  [[{:keys [msg-name], :as msg} & _]]\n  (when\n   (= msg-name :css-files-changed)\n   (reloading/reload-css-files opts msg))))\n"} {:sym _figwheel-version_, :meta {}, :source "(def _figwheel-version_ \"0.5.14\")\n"} {:sym console-out-print, :meta {:doc nil, :arglists ([args])}, :source "(defn\n console-out-print\n [args]\n (.apply (.-log js/console) js/console (into-array args)))\n"} {:sym watch-and-reload, :meta {:doc nil, :arglists ([& {:keys [], :as opts}])}, :source "(defn watch-and-reload [& {:keys [], :as opts}] (start opts))\n"} {:sym start, :meta {:doc nil, :arglists [[opts] []]}, :source "(defn\n start\n ([opts]\n  (when-not\n   (nil? goog/dependencies_)\n   (defonce\n    __figwheel-start-once__\n    (js/setTimeout\n     (fn*\n      []\n      (let\n       [plugins'\n        (:plugins opts)\n        merge-plugins\n        (:merge-plugins opts)\n        system-options\n        (->\n         config-defaults\n         (merge (dissoc opts :plugins :merge-plugins))\n         handle-deprecated-jsload-callback\n         fill-url-template)\n        plugins\n        (if\n         plugins'\n         plugins'\n         (merge (base-plugins system-options) merge-plugins))]\n       (set! utils/*print-debug* (:debug opts))\n       (enable-repl-print!)\n       (add-plugins plugins system-options)\n       (reloading/patch-goog-base)\n       (doseq\n        [msg (:initial-messages system-options)]\n        (socket/handle-incoming-message msg))\n       (socket/open system-options)))))))\n ([] (start {})))\n"} {:sym repl-plugin, :meta {:doc nil, :arglists ([{:keys [build-id], :as opts}])}, :source "(defn\n repl-plugin\n [{:keys [build-id], :as opts}]\n (fn\n  [[{:keys [msg-name], :as msg} & _]]\n  (when\n   (= :repl-eval msg-name)\n   (ensure-cljs-user)\n   (eval-javascript**\n    (:code msg)\n    opts\n    (fn\n     [res]\n     (socket/send!\n      {:figwheel-event \"callback\",\n       :callback-name (:callback-name msg),\n       :content res}))))))\n"} {:sym repl-err-print-fn, :meta {:doc nil, :arglists ([& args])}, :source "(defn\n repl-err-print-fn\n [& args]\n (console-err-print args)\n (figwheel-repl-print :err args)\n nil)\n"} {:sym heads-up-plugin, :meta {:doc nil, :arglists ([opts])}, :source "(defn\n heads-up-plugin\n [opts]\n (let\n  [ch (chan)]\n  (def heads-up-config-options** opts)\n  (go-loop\n   []\n   (when-let\n    [msg-hist' (<! ch)]\n    (<! (heads-up-plugin-msg-handler opts msg-hist'))\n    (recur)))\n  (heads-up/ensure-container)\n  (fn [msg-hist] (put! ch msg-hist) msg-hist)))\n"} {:sym file-line-column, :meta {:doc nil, :arglists ([{:keys [file line column]}])}, :source "(defn\n file-line-column\n [{:keys [file line column]}]\n (cond->\n  \"\"\n  file\n  (str \"file \" file)\n  line\n  (str \" at line \" line)\n  (and line column)\n  (str \", column \" column)))\n"} {:sym css-loaded-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn\n css-loaded-state?\n [msg-names]\n (= :css-files-changed (first msg-names)))\n"} {:sym block-reload-file-state?, :meta {:doc nil, :arglists ([msg-names opts])}, :source "(defn\n block-reload-file-state?\n [msg-names opts]\n (and\n  (= (first msg-names) :files-changed)\n  (not (reload-file?* (second msg-names) opts))))\n"} {:sym fill-url-template, :meta {:doc nil, :arglists ([config])}, :source "(defn\n fill-url-template\n [config]\n (if\n  (utils/html-env?)\n  (update-in\n   config\n   [:websocket-url]\n   (fn\n    [x]\n    (->\n     x\n     (string/replace \"[[client-hostname]]\" js/location.hostname)\n     (string/replace \"[[client-port]]\" js/location.port))))\n  config))\n"} {:sym rewarning-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn\n rewarning-state?\n [msg-names]\n (=\n  [:compile-warning :files-changed :compile-warning]\n  (take 3 msg-names)))\n"} {:sym js-stringify, :meta {}, :source "(def\n js-stringify\n (if\n  (and (exists? js/JSON) (some? js/JSON.stringify))\n  (fn [x] (str \"#js \" (js/JSON.stringify x nil \" \")))\n  (fn\n   [x]\n   (try (str x) (catch js/Error e \"Error: Unable to stringify\")))))\n"} {:sym toggle-autoload, :meta {:doc nil, :arglists ([])}, :source "(defn\n toggle-autoload\n []\n (let\n  [res\n   (utils/persistent-config-set! :figwheel-autoload (not (autoload?)))]\n  (utils/log\n   :info\n   (str\n    \"Toggle autoload deprecated! Use (figwheel.client/set-autoload! false)\"))\n  (utils/log\n   :info\n   (str \"Figwheel autoloading \" (if (autoload?) \"ON\" \"OFF\")))\n  res))\n"} {:sym get-essential-messages, :meta {:doc nil, :arglists ([ed])}, :source "(defn\n get-essential-messages\n [ed]\n (when\n  ed\n  (cons\n   (select-keys ed [:message :class])\n   (get-essential-messages (:cause ed)))))\n"} {:sym default-on-jsload, :meta {}, :source "(def default-on-jsload identity)\n"} {:sym base-plugins, :meta {:doc nil, :arglists ([system-options])}, :source "(defn\n base-plugins\n [system-options]\n (let\n  [base\n   {:enforce-project-plugin enforce-project-plugin,\n    :enforce-figwheel-version-plugin enforce-figwheel-version-plugin,\n    :file-reloader-plugin file-reloader-plugin,\n    :comp-fail-warning-plugin compile-fail-warning-plugin,\n    :css-reloader-plugin css-reloader-plugin,\n    :repl-plugin repl-plugin}\n   base\n   (if\n    (not (utils/html-env?))\n    (select-keys\n     base\n     [:file-reloader-plugin :comp-fail-warning-plugin :repl-plugin])\n    base)\n   base\n   (if\n    (false? (:autoload system-options))\n    (dissoc base :file-reloader-plugin)\n    base)]\n  (if\n   (and (:heads-up-display system-options) (utils/html-env?))\n   (assoc base :heads-up-display-plugin heads-up-plugin)\n   base)))\n"} {:sym default-on-cssload, :meta {:doc nil, :arglists ([files])}, :source "(defn\n default-on-cssload\n [files]\n (utils/log :debug \"Figwheel: loaded CSS files\")\n (utils/log :info (pr-str (map :file files)))\n files)\n"} {:sym console-err-print, :meta {:doc nil, :arglists ([args])}, :source "(defn\n console-err-print\n [args]\n (.apply (.-error js/console) js/console (into-array args)))\n"} {:sym enforce-project-plugin, :meta {:doc nil, :arglists ([opts])}, :source "(defn\n enforce-project-plugin\n [opts]\n (fn\n  [msg-hist]\n  (when\n   (< 1 (count (set (keep :project-id (take 5 msg-hist)))))\n   (socket/close!)\n   (.error\n    js/console\n    \"Figwheel: message received from different project. Shutting socket down.\")\n   (when\n    (:heads-up-display opts)\n    (go\n     (<! (timeout 3000))\n     (heads-up/display-system-warning\n      \"Connection from different project\"\n      \"Shutting connection down!!!!!\"))))))\n"} {:sym warning-append-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn\n warning-append-state?\n [msg-names]\n (= [:compile-warning :compile-warning] (take 2 msg-names)))\n"} {:sym config-defaults, :meta {}, :source "(defonce\n config-defaults\n {:on-compile-warning #'default-on-compile-warning,\n  :on-jsload default-on-jsload,\n  :reload-dependents true,\n  :on-compile-fail #'default-on-compile-fail,\n  :debug false,\n  :heads-up-display true,\n  :websocket-url\n  (str\n   \"ws://\"\n   (if (utils/html-env?) js/location.host \"localhost:3449\")\n   \"/figwheel-ws\"),\n  :auto-jump-to-source-on-error false,\n  :before-jsload default-before-load,\n  :load-warninged-code false,\n  :eval-fn false,\n  :retry-count 100,\n  :autoload true,\n  :on-cssload default-on-cssload})\n"} {:sym compile-refail-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn\n compile-refail-state?\n [msg-names]\n (= [:compile-failed :compile-failed] (take 2 msg-names)))\n"} {:sym autoload?, :meta {:doc nil, :arglists ([])}, :source "(defn\n autoload?\n []\n (utils/persistent-config-get :figwheel-autoload true))\n"} {:sym fetch-data-from-env, :meta {:doc nil, :arglists ([])}, :source "(defn\n fetch-data-from-env\n []\n (try\n  (read-string (gobj/get js/window \"FIGWHEEL_CLIENT_CONFIGURATION\"))\n  (catch\n   js/Error\n   e\n   (cljs.core/*print-err-fn*\n    \"Unable to load FIGWHEEL_CLIENT_CONFIGURATION from the environment\")\n   {:autoload false})))\n"} {:sym reload-file-state?, :meta {:doc nil, :arglists ([msg-names opts])}, :source "(defn\n reload-file-state?\n [msg-names opts]\n (and\n  (= (first msg-names) :files-changed)\n  (reload-file?* (second msg-names) opts)))\n"} {:sym default-on-compile-warning, :meta {:doc nil, :arglists ([{:keys [message], :as w}])}, :source "(defn\n default-on-compile-warning\n [{:keys [message], :as w}]\n (utils/log\n  :warn\n  (str\n   \"Figwheel: Compile Warning - \"\n   (:message message)\n   \" in \"\n   (file-line-column message)))\n w)\n"} {:sym warning-state?, :meta {:doc nil, :arglists ([msg-names])}, :source "(defn warning-state? [msg-names] (= :compile-warning (first msg-names)))\n"} {:sym default-before-load, :meta {:doc nil, :arglists ([files])}, :source "(defn\n default-before-load\n [files]\n (utils/log :debug \"Figwheel: notified of file changes\")\n files)\n"} {:sym enable-repl-print!, :meta {:doc nil, :arglists ([])}, :source "(defn\n enable-repl-print!\n []\n (set! *print-newline* false)\n (set-print-fn! repl-out-print-fn)\n (set-print-err-fn! repl-err-print-fn)\n nil)\n"} {:sym truncate-stack-trace, :meta {:doc nil, :arglists ([stack-str])}, :source "(defn\n truncate-stack-trace\n [stack-str]\n (take-while\n  (fn*\n   [p1__18480#]\n   (not (re-matches #\".*eval_javascript_STAR__STAR_.*\" p1__18480#)))\n  (string/split-lines stack-str)))\n"}), basic-lein-cljs.core ({:sym clicks, :meta {:doc "Shows the number of times the user clicked the button.", :arglists ([button-text])}, :source "(defn\n clicks\n \"Shows the number of times the user clicked the button.\"\n [button-text]\n (let\n  [state (r/atom {:clicks 0})]\n  (fn\n   []\n   [:div\n    [:p \"You clicked \" (:clicks @state) \" times\"]\n    [:button\n     {:on-click (fn [] (swap! state update :clicks inc))}\n     button-text]])))\n", :examples [{:with-card card, :with-focus {:binding [:sym focus], :init-expr [clicks "Click me!"]}, :body (do (reagent.core/unmount-component-at-node card) (reagent.core/render-component focus card) nil), :body-str "[clicks \"Click me!\"]\n", :id "basic-lein-cljs.core/clicks/0"}]} {:sym get-lib-version, :meta {:doc "Queries Clojars for the version of the given library, providing it in a\n  callback. If it can't find it, the callback receives an error object.", :arglists ([lib-name callback])}, :source "(defn\n get-lib-version\n \"Queries Clojars for the version of the given library, providing it in a\\n  callback. If it can't find it, the callback receives an error object.\"\n [lib-name callback]\n (.send\n  XhrIo\n  (str \"https://clojars.org/api/artifacts/\" lib-name)\n  (fn\n   [e]\n   (callback\n    (or\n     (when\n      (.isSuccess (.-target e))\n      (->\n       e\n       .-target\n       .getResponseText\n       js/JSON.parse\n       (gobj/get \"latest_release\")))\n     (js/Error. (str \"Can't find version for: \" lib-name)))))\n  \"GET\"))\n", :examples [{:with-callback callback, :body (get-lib-version "dynadoc" callback), :body-str "(get-lib-version \"dynadoc\" callback)\n", :id "basic-lein-cljs.core/get-lib-version/0"}]}), oakcljs.tools.reader.reader-types ({:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n indexing-push-back-reader\n \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (indexing-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len] (indexing-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (IndexingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name)))\n"} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :source "(defn\n log-source*\n [reader f]\n (let\n  [buffer (:buffer @(.-frames reader))]\n  (try\n   (swap!\n    (.-frames reader)\n    update-in\n    [:offset]\n    conj\n    (.getLength buffer))\n   (let\n    [ret (f)]\n    (if\n     (implements? IMeta ret)\n     (merge-meta ret {:source (peek-source-log @(.-frames reader))})\n     ret))\n   (finally (swap! (.-frames reader) update-in [:offset] rest)))))\n"} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :source "(defn\n merge-meta\n \"Returns an object of the same type and value as `obj`, with its\\nmetadata merged over `m`.\"\n [obj m]\n (let\n  [orig-meta (meta obj)]\n  (with-meta obj (merge m (dissoc orig-meta :source)))))\n"} {:sym Reader, :meta {:doc nil}, :methods (peek-char read-char)} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n source-logging-push-back-reader\n \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (source-logging-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len]\n  (source-logging-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (SourceLoggingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name\n   (atom {:buffer (StringBuffer.), :offset '(0)}))))\n"} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :protocol IPushbackReader} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :protocol Reader} {:sym IPushbackReader, :meta {:doc nil}, :methods (unread)} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :source "(defn\n indexing-reader?\n \"Returns true if the reader satisfies IndexingReader\"\n [rdr]\n (implements? IndexingReader rdr))\n"} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists [[s]]}, :source "(defn\n string-reader\n \"Creates a StringReader from a given string\"\n ([s] (StringReader. s (count s) 0)))\n"} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :protocol Reader} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :protocol IndexingReader} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists [[rdr]]}, :source "(defn\n read-line\n \"Reads a line from the reader or from *in* if no reader is specified\"\n ([rdr]\n  (loop\n   [c (read-char rdr) s (StringBuffer.)]\n   (if (newline? c) (str s) (recur (read-char rdr) (.append s c))))))\n"} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists [[s] [s buf-len]]}, :source "(defn\n string-push-back-reader\n \"Creates a PushbackReader from a given string\"\n ([s] (string-push-back-reader s 1))\n ([s buf-len]\n  (PushbackReader.\n   (string-reader s)\n   (object-array buf-len)\n   buf-len\n   buf-len)))\n"} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :source "(defn\n line-start?\n \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n [rdr]\n (when (indexing-reader? rdr) (== 1 (get-column-number rdr))))\n"} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n source-logging-reader?\n [rdr]\n (instance? SourceLoggingPushbackReader rdr))\n"} {:sym IndexingReader, :meta {:doc nil}, :methods (get-column-number get-file-name get-line-number)} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :source "(defn\n node-readable-push-back-reader\n [readable]\n (PushbackReader.\n  (NodeReadableReader. readable nil)\n  (object-array 1)\n  1\n  1))\n"} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader}), cljs.source-map ({:sym update-result, :meta {:doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-result\n \"Helper for decode. Take a source map and update it based on a\\n  segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:line line, :col col, :source source}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [gline]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [gcol]\n      (fnil (fn* [p1__18531#] (conj p1__18531# d)) [])))\n    (sorted-map)))))\n"} {:sym invert-reverse-map, :meta {:doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :arglists ([reverse-map])}, :source "(defn\n invert-reverse-map\n \"Given a ClojureScript to JavaScript source map, invert it. Useful when\\n   mapping JavaScript stack traces when environment support is unavailable.\"\n [reverse-map]\n (let\n  [inverted (atom (sorted-map))]\n  (doseq\n   [[line columns] reverse-map]\n   (doseq\n    [[column column-info] columns]\n    (doseq\n     [{:keys [gline gcol name]} column-info]\n     (swap!\n      inverted\n      update-in\n      [gline]\n      (fnil\n       (fn\n        [columns]\n        (update-in\n         columns\n         [gcol]\n         (fnil conj [])\n         {:line line, :col column, :name name}))\n       (sorted-map))))))\n  @inverted))\n"} {:sym decode, :meta {:doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode\n \"Convert a v3 source map JSON object into a source map mapping\\n  generated JavaScript source locations to the original\\n  ClojureScript.\"\n ([source-map] (decode (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline 0 lines lines relseg relseg-init result {}]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym seg->map, :meta {:doc "Take a source map segment represented as a vector\n   and return a map.", :arglists ([seg source-map])}, :source "(defn\n seg->map\n \"Take a source map segment represented as a vector\\n   and return a map.\"\n [seg source-map]\n (let\n  [[gcol source line col name] seg]\n  {:gcol gcol,\n   :source (aget (gobj/get source-map \"sources\") source),\n   :line line,\n   :col col,\n   :name\n   (when-let\n    [name (-> seg meta :name)]\n    (aget (gobj/get source-map \"names\") name))}))\n"} {:sym source-compare, :meta {:doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :arglists ([sources])}, :source "(defn\n source-compare\n \"Take a seq of source file names and return a comparator\\n   that can be used to construct a sorted map. For reverse\\n   source maps.\"\n [sources]\n (let\n  [sources (indexed-sources sources)]\n  (fn [a b] (compare (sources a) (sources b)))))\n"} {:sym decode-reverse, :meta {:doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode-reverse\n \"Convert a v3 source map JSON object into a reverse source map\\n  mapping original ClojureScript source locations to the generated\\n  JavaScript.\"\n ([source-map]\n  (decode-reverse (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline\n     0\n     lines\n     lines\n     relseg\n     relseg-init\n     result\n     (sorted-map-by (source-compare sources))]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-reverse-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym lines->segs, :meta {:doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :arglists ([lines])}, :source "(defn\n lines->segs\n \"Take a nested sorted map encoding line and column information\\n   for a file and return a vector of vectors of encoded segments.\\n   Each vector represents a line, and the internal vectors are segments\\n   representing the contents of the line.\"\n [lines]\n (let\n  [relseg (atom [0 0 0 0 0])]\n  (reduce\n   (fn\n    [segs cols]\n    (swap!\n     relseg\n     (fn [[_ source line col name]] [0 source line col name]))\n    (conj\n     segs\n     (reduce\n      (fn\n       [cols [gcol sidx line col name :as seg]]\n       (let\n        [offset (map - seg @relseg)]\n        (swap!\n         relseg\n         (fn [[_ _ _ _ lname]] [gcol sidx line col (or name lname)]))\n        (conj cols (base64-vlq/encode offset))))\n      []\n      cols)))\n   []\n   lines)))\n"} {:sym merge-source-maps, :meta {:doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :arglists ([cljs-map js-map])}, :source "(defn\n merge-source-maps\n \"Merge an internal source map representation of a single\\n   ClojureScript file mapping original to generated with a\\n   second source map mapping original JS to generated JS.\\n   The is to support source maps that work through multiple\\n   compilation steps like Google Closure optimization passes.\"\n [cljs-map js-map]\n (loop\n  [line-map-seq (seq cljs-map) new-lines (sorted-map)]\n  (if\n   line-map-seq\n   (let\n    [[line col-map]\n     (first line-map-seq)\n     new-cols\n     (loop\n      [col-map-seq (seq col-map) new-cols (sorted-map)]\n      (if\n       col-map-seq\n       (let\n        [[col infos] (first col-map-seq)]\n        (recur\n         (next col-map-seq)\n         (assoc\n          new-cols\n          col\n          (reduce\n           (fn\n            [v {:keys [gline gcol]}]\n            (into v (get-in js-map [gline gcol])))\n           []\n           infos))))\n       new-cols))]\n    (recur (next line-map-seq) (assoc new-lines line new-cols)))\n   new-lines)))\n"} {:sym update-reverse-result, :meta {:doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-reverse-result\n \"Helper for decode-reverse. Take a reverse source map and\\n  update it with a segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:gline gline, :gcol gcol}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [source]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [line]\n      (fnil\n       (fn [m] (update-in m [col] (fnil (fn [v] (conj v d)) [])))\n       (sorted-map))))\n    (sorted-map)))))\n"} {:sym indexed-sources, :meta {:doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :arglists ([sources])}, :source "(defn\n indexed-sources\n \"Take a seq of source file names and return a map from\\n   file number to integer index. For reverse source maps.\"\n [sources]\n (->>\n  sources\n  (map-indexed (fn [a b] [a b]))\n  (reduce (fn [m [i v]] (assoc m v i)) {})))\n"} {:sym seg-combine, :meta {:doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :arglists ([seg relseg])}, :source "(defn\n seg-combine\n \"Combine a source map segment vector and a relative\\n   source map segment vector and combine them to get\\n   an absolute segment posititon information as a vector.\"\n [seg relseg]\n (let\n  [[gcol source line col name]\n   seg\n   [rgcol rsource rline rcol rname]\n   relseg\n   nseg\n   [(+ gcol rgcol)\n    (+ (or source 0) rsource)\n    (+ (or line 0) rline)\n    (+ (or col 0) rcol)\n    (+ (or name 0) rname)]]\n  (if name (with-meta nseg {:name (+ name rname)}) nseg)))\n"}), oakcljs.tools.reader.impl.commons ({:sym match-number, :meta {:doc nil, :arglists ([s])}, :source "(defn\n match-number\n [s]\n (if\n  (matches? int-pattern s)\n  (match-int s)\n  (if\n   (matches? float-pattern s)\n   (match-float s)\n   (when (matches? ratio-pattern s) (match-ratio s)))))\n"} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :source "(defn\n skip-line\n \"Advances the reader to the end of a line. Returns the reader\"\n [reader]\n (loop [] (when-not (newline? (read-char reader)) (recur)))\n reader)\n"} {:sym int-pattern, :meta {}, :source "(def\n int-pattern\n #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n"} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :source "(defn read-comment [rdr & _] (skip-line rdr))\n"} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :source "(defn\n parse-symbol\n \"Parses a string into a vector of the namespace and symbol\"\n [token]\n (when-not\n  (or\n   (identical? \"\" token)\n   (true? (.test #\":$\" token))\n   (true? (.test #\"^::\" token)))\n  (let\n   [ns-idx\n    (.indexOf token \"/\")\n    ns\n    (when (pos? ns-idx) (subs token 0 ns-idx))]\n   (if-not\n    (nil? ns)\n    (let\n     [ns-idx (inc ns-idx)]\n     (when-not\n      (== ns-idx (count token))\n      (let\n       [sym (subs token ns-idx)]\n       (when\n        (and\n         (not (numeric? (nth sym 0)))\n         (not (identical? \"\" sym))\n         (false? (.test #\":$\" ns))\n         (or (identical? sym \"/\") (== -1 (.indexOf sym \"/\"))))\n        [ns sym]))))\n    (when\n     (or (identical? token \"/\") (== -1 (.indexOf token \"/\")))\n     [nil token])))))\n"} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :source "(defn\n number-literal?\n \"Checks whether the reader is at the start of a number literal\"\n [reader initch]\n (or\n  (numeric? initch)\n  (and\n   (or (identical? \\+ initch) (identical? \\- initch))\n   (numeric? (peek-char reader)))))\n"} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :source "(defn\n read-past\n \"Read until first character that doesn't match pred, returning\\n   char.\"\n [pred rdr]\n (loop [ch (read-char rdr)] (if (pred ch) (recur (read-char rdr)) ch)))\n"} {:sym float-pattern, :meta {}, :source "(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n"} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :source "(defn\n matches?\n [pattern s]\n (let [[match] (re-find pattern s)] (identical? match s)))\n"} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :source "(defn throwing-reader [msg] (fn [rdr & _] (reader-error rdr msg)))\n"} {:sym ratio-pattern, :meta {}, :source "(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n"}), figwheel.client.utils ({:sym mapConcatD, :meta {:doc "maps an async action across a collection and chains the results\n  onto a deferred", :arglists ([deferred f coll])}, :source "(defn\n mapConcatD\n \"maps an async action across a collection and chains the results\\n  onto a deferred\"\n [deferred f coll]\n (let\n  [results (atom [])]\n  (.then\n   (reduce\n    (fn\n     [defr v]\n     (liftContD\n      defr\n      (fn [_ fin] (f v (fn [v] (swap! results conj v) (fin v))))))\n    deferred\n    coll)\n   (fn [_] (.succeed Deferred @results)))))\n"} {:sym base-url-path, :meta {:doc nil, :arglists ([])}, :source "(defn base-url-path [] (string/replace goog/basePath #\"(.*)goog/\" \"$1\"))\n"} {:sym log, :meta {:doc nil, :arglists [[x] [level arg]]}, :source "(defn\n log\n ([x] (log :info x))\n ([level arg]\n  (let\n   [f\n    (condp\n     =\n     (if (html-or-react-native-env?) level :info)\n     :warn\n     (fn* [p1__18504#] (.warn js/console p1__18504#))\n     :debug\n     (fn* [p1__18505#] (.debug js/console p1__18505#))\n     :error\n     (fn* [p1__18506#] (.error js/console p1__18506#))\n     (fn* [p1__18507#] (.log js/console p1__18507#)))]\n   (f arg))))\n"} {:sym create-custom-event, :meta {:doc nil, :arglists ([event-name data])}, :source "(defn\n create-custom-event\n [event-name data]\n (if-not\n  product/IE\n  (js/CustomEvent. event-name (js-obj \"detail\" data))\n  (let\n   [event (js/document.createEvent \"CustomEvent\")]\n   (.. event (initCustomEvent event-name false false data))\n   event)))\n"} {:sym worker-env?, :meta {:doc nil, :arglists ([])}, :source "(defn\n worker-env?\n []\n (and\n  (nil? goog/global.document)\n  (exists? js/self)\n  (exists? (.-importScripts js/self))))\n"} {:sym host-env?, :meta {:doc nil, :arglists ([])}, :source "(defn\n host-env?\n []\n (cond\n  (node-env?)\n  :node\n  (html-env?)\n  :html\n  (react-native-env?)\n  :react-native\n  (worker-env?)\n  :worker))\n"} {:sym persistent-config-set!, :meta {:doc "Set a local value on a key that in a browser will persist even when \nthe browser gets reloaded.", :arglists ([ky v])}, :source "(defn\n persistent-config-set!\n \"Set a local value on a key that in a browser will persist even when \\nthe browser gets reloaded.\"\n [ky v]\n (swap! local-persistent-config assoc ky v))\n"} {:sym html-or-react-native-env?, :meta {:doc nil, :arglists ([])}, :source "(defn html-or-react-native-env? [] (or (html-env?) (react-native-env?)))\n"} {:sym node-env?, :meta {:doc nil, :arglists ([])}, :source "(defn node-env? [] (not (nil? goog/nodeGlobalRequire)))\n"} {:sym html-env?, :meta {:doc nil, :arglists ([])}, :source "(defn html-env? [] (not (nil? goog/global.document)))\n"} {:sym liftContD, :meta {:doc "chains an async action on to a deferred\n  Must provide a goog.async.Deferred and action function that\n  takes an initial value and a continuation fn to call with the result", :arglists ([deferred f])}, :source "(defn\n liftContD\n \"chains an async action on to a deferred\\n  Must provide a goog.async.Deferred and action function that\\n  takes an initial value and a continuation fn to call with the result\"\n [deferred f]\n (.then\n  deferred\n  (fn\n   [val]\n   (let\n    [new-def (Deferred.)]\n    (f val (fn* [p1__18508#] (.callback new-def p1__18508#)))\n    new-def))))\n"} {:sym *print-debug*, :meta {}, :source "(def *print-debug* false)\n"} {:sym pprint-to-string, :meta {:doc nil, :arglists ([x])}, :source "(defn\n pprint-to-string\n [x]\n (let\n  [sb (StringBuffer.) sbw (StringBufferWriter. sb)]\n  (pprint x sbw)\n  (gstring/trimRight (str sb))))\n"} {:sym local-persistent-config, :meta {}, :source "(defonce\n local-persistent-config\n (let\n  [a (atom {})]\n  (when\n   (exists? js/localStorage)\n   (add-watch\n    a\n    :sync-local-storage\n    (fn\n     [_ _ _ n]\n     (mapv\n      (fn [[ky v]] (.setItem js/localStorage (name ky) (pr-str v)))\n      n))))\n  a))\n"} {:sym dispatch-custom-event, :meta {:doc nil, :arglists ([event-name data])}, :source "(defn\n dispatch-custom-event\n [event-name data]\n (when\n  (and\n   (html-env?)\n   (gobj/get js/window \"CustomEvent\")\n   (js* \"typeof document !== 'undefined'\"))\n  (.dispatchEvent\n   (.-body js/document)\n   (create-custom-event event-name data))))\n"} {:sym debug-prn, :meta {:doc nil, :arglists ([o])}, :source "(defn\n debug-prn\n [o]\n (when\n  *print-debug*\n  (let\n   [o (if (or (map? o) (seq? o)) (prn-str o) o)]\n   (.log js/console o))))\n"} {:sym persistent-config-get, :meta {:doc nil, :arglists [[ky not-found] [ky]]}, :source "(defn\n persistent-config-get\n ([ky not-found]\n  (try\n   (cond\n    (contains? @local-persistent-config ky)\n    (get @local-persistent-config ky)\n    (and\n     (exists? js/localStorage)\n     (.getItem js/localStorage (name ky)))\n    (let\n     [v (read-string (.getItem js/localStorage (name ky)))]\n     (persistent-config-set! ky v)\n     v)\n    :else\n    not-found)\n   (catch js/Error e not-found)))\n ([ky] (persistent-config-get ky nil)))\n"} {:sym react-native-env?, :meta {:doc nil, :arglists ([])}, :source "(defn\n react-native-env?\n []\n (and\n  (exists? goog/global.navigator)\n  (= goog/global.navigator.product \"ReactNative\")))\n"} {:sym eval-helper, :meta {:doc nil, :arglists ([code {:keys [eval-fn], :as opts}])}, :source "(defn\n eval-helper\n [code {:keys [eval-fn], :as opts}]\n (if eval-fn (eval-fn code opts) (js* \"eval(~{code})\")))\n"}), reagent.debug ({:sym has-console, :meta {}, :source "(def has-console (exists? js/console))\n"} {:sym tracking, :meta {}, :source "(def tracking false)\n"} {:sym warnings, :meta {}, :source "(defonce warnings (atom nil))\n"} {:sym track-warnings, :meta {:doc nil, :arglists ([f])}, :source "(defn\n track-warnings\n [f]\n (set! tracking true)\n (reset! warnings nil)\n (f)\n (let\n  [warns @warnings]\n  (reset! warnings nil)\n  (set! tracking false)\n  warns))\n"}), cljs.repl ({:sym print-doc, :meta {:doc nil, :arglists ([{n :ns, nm :name, :as m}])}, :source "(defn\n print-doc\n [{n :ns, nm :name, :as m}]\n (println \"-------------------------\")\n (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n (when (:protocol m) (println \"Protocol\"))\n (cond\n  (:forms m)\n  (doseq [f (:forms m)] (println \"  \" f))\n  (:arglists m)\n  (let\n   [arglists (:arglists m)]\n   (if\n    (or (:macro m) (:repl-special-function m))\n    (prn arglists)\n    (prn\n     (if (= 'quote (first arglists)) (second arglists) arglists)))))\n (if\n  (:special-form m)\n  (do\n   (println \"Special Form\")\n   (println \" \" (:doc m))\n   (if\n    (contains? m :url)\n    (when\n     (:url m)\n     (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n    (println\n     (str\n      \"\\n  Please see http://clojure.org/special_forms#\"\n      (:name m)))))\n  (do\n   (when (:macro m) (println \"Macro\"))\n   (when (:repl-special-function m) (println \"REPL Special Function\"))\n   (println \" \" (:doc m))\n   (when\n    (:protocol m)\n    (doseq\n     [[name {:keys [doc arglists]}] (:methods m)]\n     (println)\n     (println \" \" name)\n     (println \" \" arglists)\n     (when doc (println \" \" doc))))\n   (when\n    n\n    (when-let\n     [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n     (print \"Spec\")\n     (doseq\n      [role [:args :ret :fn]]\n      (when-let\n       [spec (get fnspec role)]\n       (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))\n"}), cljs.core.async.impl.ioc-helpers ({:sym EXCEPTION-FRAMES, :meta {}, :source "(def EXCEPTION-FRAMES 4)\n"} {:sym process-exception, :meta {:doc nil, :arglists ([state])}, :source "(defn\n process-exception\n [state]\n (let\n  [exception-frame\n   (aget-object state EXCEPTION-FRAMES)\n   catch-block\n   (:catch-block exception-frame)\n   catch-exception\n   (:catch-exception exception-frame)\n   exception\n   (aget-object state CURRENT-EXCEPTION)]\n  (cond\n   (and exception (not exception-frame))\n   (throw exception)\n   (and\n    exception\n    catch-block\n    (or\n     (= :default catch-exception)\n     (instance? catch-exception exception)))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    catch-block\n    VALUE-IDX\n    exception\n    CURRENT-EXCEPTION\n    nil\n    EXCEPTION-FRAMES\n    (assoc exception-frame :catch-block nil :catch-exception nil))\n   (and\n    exception\n    (not catch-block)\n    (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all! state EXCEPTION-FRAMES (:prev exception-frame))\n    (recur state))\n   (and exception (not catch-block) (:finally-block exception-frame))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    (:finally-block exception-frame)\n    EXCEPTION-FRAMES\n    (assoc exception-frame :finally-block nil))\n   (and (not exception) (:finally-block exception-frame))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:finally-block exception-frame)\n     EXCEPTION-FRAMES\n     (assoc exception-frame :finally-block nil)))\n   (and (not exception) (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:continue-block exception-frame)\n     EXCEPTION-FRAMES\n     (:prev exception-frame)))\n   :else\n   (throw (js/Error. \"No matching clause\")))))\n"} {:sym STATE-IDX, :meta {}, :source "(def STATE-IDX 1)\n"} {:sym aset-object, :meta {:doc nil, :arglists ([arr idx o])}, :source "(defn aset-object [arr idx o] (aget arr idx o))\n"} {:sym add-exception-frame, :meta {:doc nil, :arglists ([state catch-block catch-exception finally-block continue-block])}, :source "(defn\n add-exception-frame\n [state catch-block catch-exception finally-block continue-block]\n (ioc/aset-all!\n  state\n  EXCEPTION-FRAMES\n  (->ExceptionFrame\n   catch-block\n   catch-exception\n   finally-block\n   continue-block\n   (aget-object state EXCEPTION-FRAMES))))\n"} {:sym run-state-machine-wrapped, :meta {:doc nil, :arglists ([state])}, :source "(defn\n run-state-machine-wrapped\n [state]\n (try\n  (run-state-machine state)\n  (catch\n   js/Object\n   ex\n   (impl/close! (aget-object state USER-START-IDX))\n   (throw ex))))\n"} {:sym FN-IDX, :meta {}, :source "(def FN-IDX 0)\n"} {:sym aget-object, :meta {:doc nil, :arglists ([arr idx])}, :source "(defn aget-object [arr idx] (aget arr idx))\n"} {:sym return-chan, :meta {:doc nil, :arglists ([state value])}, :source "(defn\n return-chan\n [state value]\n (let\n  [c (aget state USER-START-IDX)]\n  (when-not (nil? value) (impl/put! c value (fn-handler (fn [] nil))))\n  (impl/close! c)\n  c))\n"} {:sym BINDINGS-IDX, :meta {}, :source "(def BINDINGS-IDX 3)\n"} {:sym CURRENT-EXCEPTION, :meta {}, :source "(def CURRENT-EXCEPTION 5)\n"} {:sym run-state-machine, :meta {:doc nil, :arglists ([state])}, :source "(defn run-state-machine [state] ((aget-object state FN-IDX) state))\n"} {:sym finished?, :meta {:doc "Returns true if the machine is in a finished state", :arglists ([state-array])}, :source "(defn\n finished?\n \"Returns true if the machine is in a finished state\"\n [state-array]\n (keyword-identical? (aget state-array STATE-IDX) :finished))\n"} {:sym USER-START-IDX, :meta {}, :source "(def USER-START-IDX 6)\n"} {:sym put!, :meta {:doc nil, :arglists ([state blk c val])}, :source "(defn\n put!\n [state blk c val]\n (if-let\n  [cb\n   (impl/put!\n    c\n    val\n    (fn-handler\n     (fn\n      [ret-val]\n      (ioc/aset-all! state VALUE-IDX ret-val STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym take!, :meta {:doc nil, :arglists ([state blk c])}, :source "(defn\n take!\n [state blk c]\n (if-let\n  [cb\n   (impl/take!\n    c\n    (fn-handler\n     (fn\n      [x]\n      (ioc/aset-all! state VALUE-IDX x STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym VALUE-IDX, :meta {}, :source "(def VALUE-IDX 2)\n"}), figwheel.client.heads-up ({:sym get-content, :meta {:doc nil, :arglists ([{:keys [content-area-el]}])}, :source "(defn\n get-content\n [{:keys [content-area-el]}]\n (.-innerHTML content-area-el))\n"} {:sym auto-notify-source-file-line, :meta {:doc nil, :arglists ([{:keys [file line column]}])}, :source "(defn\n auto-notify-source-file-line\n [{:keys [file line column]}]\n (socket/send!\n  {:figwheel-event \"file-selected\",\n   :file-name (str file),\n   :file-line (str line),\n   :file-column (str column)}))\n"} {:sym display-exception, :meta {:doc nil, :arglists ([exception-data])}, :source "(defn\n display-exception\n [exception-data]\n (let\n  [{:keys [head sub-head messages last-message file line column]}\n   (-> exception-data exception->display-data)\n   msg\n   (apply str messages)]\n  (display-heads-up\n   {:backgroundColor \"rgba(255, 161, 161, 0.95)\"}\n   (str\n    (close-link)\n    (heading head sub-head)\n    (file-selector-div file line column msg)))))\n"} {:sym set-style!, :meta {:doc nil, :arglists ([{:keys [container-el]} st-map])}, :source "(defn\n set-style!\n [{:keys [container-el]} st-map]\n (mapv\n  (fn [[k v]] (gobj/set (.-style container-el) (name k) v))\n  st-map))\n"} {:sym heading, :meta {:doc nil, :arglists [[s] [s sub-head]]}, :source "(defn\n heading\n ([s] (heading s \"\"))\n ([s sub-head]\n  (str\n   \"<div style=\\\"\"\n   \"font-size: 26px;\"\n   \"line-height: 26px;\"\n   \"margin-bottom: 2px;\"\n   \"padding-top: 1px;\"\n   \"\\\">\"\n   s\n   \" <span style=\\\"\"\n   \"display: inline-block;\"\n   \"font-size: 13px;\"\n   \"\\\">\"\n   sub-head\n   \"</span></div>\")))\n"} {:sym clear, :meta {:doc nil, :arglists ([])}, :source "(defn\n clear\n []\n (go\n  (let\n   [c (ensure-container)]\n   (set-style! c {:opacity \"0.0\"})\n   (<! (timeout 300))\n   (set-style!\n    c\n    {:width \"auto\",\n     :height \"0px\",\n     :minHeight \"0px\",\n     :padding \"0px 10px 0px 70px\",\n     :borderRadius \"0px\",\n     :backgroundColor \"transparent\"})\n   (<! (timeout 200))\n   (set-content! c \"\"))))\n"} {:sym escape, :meta {:doc nil, :arglists ([x])}, :source "(defn escape [x] (goog.string/htmlEscape x))\n"} {:sym inline-error-line, :meta {:doc nil, :arglists ([style line-number line])}, :source "(defn\n inline-error-line\n [style line-number line]\n (str\n  \"<span style='\"\n  style\n  \"'>\"\n  \"<span style='color: #757575;'>\"\n  line-number\n  \"  </span>\"\n  (escape line)\n  \"</span>\"))\n"} {:sym pad-line-number, :meta {:doc nil, :arglists ([n line-number])}, :source "(defn\n pad-line-number\n [n line-number]\n (let\n  [len (count ((fnil str \"\") line-number))]\n  (->\n   (if (< len n) (apply str (repeat (- n len) \" \")) \"\")\n   (str line-number))))\n"} {:sym get-dataset, :meta {:doc nil, :arglists ([el])}, :source "(defn\n get-dataset\n [el]\n (first\n  (keep\n   (fn [x] (when (.. x -dataset -figwheelEvent) (.. x -dataset)))\n   (take 4 (ancestor-nodes el)))))\n"} {:sym flatten-exception, :meta {}, :source "(def\n flatten-exception\n (fn* [p1__18499#] (take-while some? (iterate :cause p1__18499#))))\n"} {:sym display-heads-up, :meta {:doc nil, :arglists ([style msg])}, :source "(defn\n display-heads-up\n [style msg]\n (go\n  (let\n   [c (ensure-container)]\n   (set-style!\n    c\n    (merge\n     {:paddingTop \"10px\",\n      :paddingBottom \"10px\",\n      :width \"100%\",\n      :minHeight \"68px\",\n      :opacity \"1.0\"}\n     style))\n   (set-content! c msg)\n   (<! (timeout 300))\n   (set-style! c {:height \"auto\"}))))\n"} {:sym format-line, :meta {:doc nil, :arglists ([msg {:keys [file line column]}])}, :source "(defn\n format-line\n [msg {:keys [file line column]}]\n (let\n  [msg (goog.string/htmlEscape msg)]\n  (if\n   (or file line)\n   (file-selector-div file line column msg)\n   (str \"<div>\" msg \"</div>\"))))\n"} {:sym format-inline-error-line, :meta {:doc nil, :arglists ([[typ line-number line]])}, :source "(defn\n format-inline-error-line\n [[typ line-number line]]\n (condp\n  =\n  typ\n  :code-line\n  (inline-error-line \"color: #999;\" line-number line)\n  :error-in-code\n  (inline-error-line\n   \"color: #ccc; font-weight: bold;\"\n   line-number\n   line)\n  :error-message\n  (inline-error-line \"color: #D07D7D;\" line-number line)\n  (inline-error-line \"color: #666;\" line-number line)))\n"} {:sym pad-line-numbers, :meta {:doc nil, :arglists ([inline-error])}, :source "(defn\n pad-line-numbers\n [inline-error]\n (let\n  [max-line-number-length\n   (count (str (reduce max (map second inline-error))))]\n  (map\n   (fn*\n    [p1__18498#]\n    (update-in\n     p1__18498#\n     [1]\n     (partial pad-line-number max-line-number-length)))\n   inline-error)))\n"} {:sym heads-up-onclick-handler, :meta {:doc nil, :arglists ([event])}, :source "(defn\n heads-up-onclick-handler\n [event]\n (let\n  [dataset (get-dataset (.. event -target))]\n  (.preventDefault event)\n  (when dataset (heads-up-event-dispatch dataset))))\n"} {:sym set-content!, :meta {:doc nil, :arglists ([{:keys [content-area-el], :as c} dom-str])}, :source "(defn\n set-content!\n [{:keys [content-area-el], :as c} dom-str]\n (set! (.-innerHTML content-area-el) dom-str))\n"} {:sym warning-data->display-data, :meta {:doc nil, :arglists ([{:keys [file line column message error-inline], :as warning-data}])}, :source "(defn\n warning-data->display-data\n [{:keys [file line column message error-inline], :as warning-data}]\n (let\n  [last-message\n   (cond\n    (and file line)\n    (str \"Please see line \" line \" of file \" file)\n    file\n    (str \"Please see \" file)\n    :else\n    nil)]\n  {:head \"Compile Warning\",\n   :sub-head file,\n   :messages\n   (concat\n    (map\n     (fn* [p1__18503#] (str \"<div>\" p1__18503# \"</div>\"))\n     [(when\n       message\n       (str\n        \"<span style=\\\"font-weight:bold;\\\">\"\n        (escape message)\n        \"</span>\"))\n      (when\n       (pos? (count error-inline))\n       (format-inline-error error-inline))])\n    (when\n     last-message\n     [(str\n       \"<div style=\\\"color: #AD4F4F; padding-top: 3px; margin-bottom: 10px;\\\">\"\n       (escape last-message)\n       \"</div>\")])),\n   :file file,\n   :line line,\n   :column column}))\n"} {:sym display-warning, :meta {:doc nil, :arglists ([warning-data])}, :source "(defn\n display-warning\n [warning-data]\n (let\n  [{:keys [head sub-head messages last-message file line column]}\n   (-> warning-data warning-data->display-data)\n   msg\n   (apply str messages)]\n  (display-heads-up\n   {:backgroundColor \"rgba(255, 220, 110, 0.95)\"}\n   (str\n    (close-link)\n    (heading head sub-head)\n    (file-selector-div file line column msg)))))\n"} {:sym file-selector-div, :meta {:doc nil, :arglists ([file-name line-number column-number msg])}, :source "(defn\n file-selector-div\n [file-name line-number column-number msg]\n (str\n  \"<div style=\\\"cursor: pointer;\\\" data-figwheel-event=\\\"file-selected\\\" data-file-name=\\\"\"\n  file-name\n  \"\\\" data-file-line=\\\"\"\n  line-number\n  \"\\\" data-file-column=\\\"\"\n  column-number\n  \"\\\">\"\n  msg\n  \"</div>\"))\n"} {:sym display-loaded-start, :meta {:doc nil, :arglists ([])}, :source "(defn\n display-loaded-start\n []\n (display-heads-up\n  {:backgroundColor \"rgba(211,234,172,1.0)\",\n   :width \"68px\",\n   :height \"68px\",\n   :paddingLeft \"0px\",\n   :paddingRight \"0px\",\n   :borderRadius \"35px\"}\n  \"\"))\n"} {:sym ensure-container, :meta {:doc nil, :arglists ([])}, :source "(defn\n ensure-container\n []\n (let\n  [cont-id\n   \"figwheel-heads-up-container\"\n   content-id\n   \"figwheel-heads-up-content-area\"]\n  (if-not\n   (.querySelector js/document (str \"#\" cont-id))\n   (let\n    [el\n     (node\n      :div\n      {:id cont-id,\n       :style\n       (str\n        \"-webkit-transition: all 0.2s ease-in-out;\"\n        \"-moz-transition: all 0.2s ease-in-out;\"\n        \"-o-transition: all 0.2s ease-in-out;\"\n        \"transition: all 0.2s ease-in-out;\"\n        \"font-size: 13px;\"\n        \"border-top: 1px solid #f5f5f5;\"\n        \"box-shadow: 0px 0px 1px #aaaaaa;\"\n        \"line-height: 18px;\"\n        \"color: #333;\"\n        \"font-family: monospace;\"\n        \"padding: 0px 10px 0px 70px;\"\n        \"position: fixed;\"\n        \"bottom: 0px;\"\n        \"left: 0px;\"\n        \"height: 0px;\"\n        \"opacity: 0.0;\"\n        \"box-sizing: border-box;\"\n        \"z-index: 10000;\"\n        \"text-align: left;\")})]\n    (set! (.-onclick el) heads-up-onclick-handler)\n    (set! (.-innerHTML el) cljs-logo-svg)\n    (.appendChild el (node :div {:id content-id}))\n    (-> (.-body js/document) (.appendChild el))))\n  {:container-el (.getElementById js/document cont-id),\n   :content-area-el (.getElementById js/document content-id)}))\n"} {:sym node, :meta {:doc nil, :arglists ([t attrs & children])}, :source "(defn\n node\n [t attrs & children]\n (let\n  [e (.createElement js/document (name t))]\n  (doseq [k (keys attrs)] (.setAttribute e (name k) (get attrs k)))\n  (doseq [ch children] (.appendChild e ch))\n  e))\n"} {:sym exception->display-data, :meta {:doc nil, :arglists ([{:keys [failed-loading-clj-file failed-compiling reader-exception analysis-exception display-ex-data class file line column message error-inline], :as exception}])}, :source "(defn\n exception->display-data\n [{:keys\n   [failed-loading-clj-file\n    failed-compiling\n    reader-exception\n    analysis-exception\n    display-ex-data\n    class\n    file\n    line\n    column\n    message\n    error-inline],\n   :as exception}]\n (let\n  [last-message\n   (cond\n    (and file line)\n    (str \"Please see line \" line \" of file \" file)\n    file\n    (str \"Please see \" file)\n    :else\n    nil)]\n  {:head\n   (cond\n    failed-loading-clj-file\n    \"Couldn't load Clojure file\"\n    analysis-exception\n    \"Could not Analyze\"\n    reader-exception\n    \"Could not Read\"\n    failed-compiling\n    \"Could not Compile\"\n    :else\n    \"Compile Exception\"),\n   :sub-head file,\n   :messages\n   (concat\n    (map\n     (fn* [p1__18500#] (str \"<div>\" p1__18500# \"</div>\"))\n     (if\n      message\n      [(str\n        (if class (str (escape class) \": \") \"\")\n        \"<span style=\\\"font-weight:bold;\\\">\"\n        (escape message)\n        \"</span>\")\n       (when\n        display-ex-data\n        (str\n         \"<pre>\"\n         (utils/pprint-to-string display-ex-data)\n         \"</pre>\"))\n       (when\n        (pos? (count error-inline))\n        (format-inline-error error-inline))]\n      (map\n       (fn*\n        [p1__18501#]\n        (str\n         (escape (:class p1__18501#))\n         \": \"\n         (escape (:message p1__18501#))))\n       (flatten-exception (:exception-data exception)))))\n    (when\n     last-message\n     [(str\n       \"<div style=\\\"color: #AD4F4F; padding-top: 3px;\\\">\"\n       (escape last-message)\n       \"</div>\")])),\n   :file file,\n   :line line,\n   :column column}))\n"} {:sym cljs-logo-svg, :meta {}, :source "(def\n cljs-logo-svg\n \"<?xml version='1.0' encoding='utf-8'?>\\n<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>\\n<svg width='49px' height='49px' style='position:absolute; top:9px; left: 10px;' version='1.1'\\n  xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px'\\n  viewBox='0 0 428 428' enable-background='new 0 0 428 428' xml:space='preserve'>\\n<circle fill='#fff' cx='213' cy='214' r='213' />\\n<g>\\n<path fill='#96CA4B' d='M122,266.6c-12.7,0-22.3-3.7-28.9-11.1c-6.6-7.4-9.9-18-9.9-31.8c0-14.1,3.4-24.9,10.3-32.5\\n  s16.8-11.4,29.9-11.4c8.8,0,16.8,1.6,23.8,4.9l-5.4,14.3c-7.5-2.9-13.7-4.4-18.6-4.4c-14.5,0-21.7,9.6-21.7,28.8\\n  c0,9.4,1.8,16.4,5.4,21.2c3.6,4.7,8.9,7.1,15.9,7.1c7.9,0,15.4-2,22.5-5.9v15.5c-3.2,1.9-6.6,3.2-10.2,4\\n  C131.5,266.2,127.1,266.6,122,266.6z'/>\\n<path fill='#96CA4B' d='M194.4,265.1h-17.8V147.3h17.8V265.1z'/>\\n<path fill='#5F7FBF' d='M222.9,302.3c-5.3,0-9.8-0.6-13.3-1.9v-14.1c3.4,0.9,6.9,1.4,10.5,1.4c7.6,0,11.4-4.3,11.4-12.9v-93.5h17.8\\n  v94.7c0,8.6-2.3,15.2-6.8,19.6C237.9,300.1,231.4,302.3,222.9,302.3z M230.4,159.2c0-3.2,0.9-5.6,2.6-7.3c1.7-1.7,4.2-2.6,7.5-2.6\\n  c3.1,0,5.6,0.9,7.3,2.6c1.7,1.7,2.6,4.2,2.6,7.3c0,3-0.9,5.4-2.6,7.2c-1.7,1.7-4.2,2.6-7.3,2.6c-3.2,0-5.7-0.9-7.5-2.6\\n  C231.2,164.6,230.4,162.2,230.4,159.2z'/>\\n<path fill='#5F7FBF' d='M342.5,241.3c0,8.2-3,14.4-8.9,18.8c-6,4.4-14.5,6.5-25.6,6.5c-11.2,0-20.1-1.7-26.9-5.1v-15.4\\n  c9.8,4.5,19,6.8,27.5,6.8c10.9,0,16.4-3.3,16.4-9.9c0-2.1-0.6-3.9-1.8-5.3c-1.2-1.4-3.2-2.9-6-4.4c-2.8-1.5-6.6-3.2-11.6-5.1\\n  c-9.6-3.7-16.2-7.5-19.6-11.2c-3.4-3.7-5.1-8.6-5.1-14.5c0-7.2,2.9-12.7,8.7-16.7c5.8-4,13.6-5.9,23.6-5.9c9.8,0,19.1,2,27.9,6\\n  l-5.8,13.4c-9-3.7-16.6-5.6-22.8-5.6c-9.4,0-14.1,2.7-14.1,8c0,2.6,1.2,4.8,3.7,6.7c2.4,1.8,7.8,4.3,16,7.5\\n  c6.9,2.7,11.9,5.1,15.1,7.3c3.1,2.2,5.4,4.8,7,7.7C341.7,233.7,342.5,237.2,342.5,241.3z'/>\\n</g>\\n<path fill='#96CA4B' stroke='#96CA4B' stroke-width='6' stroke-miterlimit='10' d='M197,392.7c-91.2-8.1-163-85-163-178.3\\n  S105.8,44.3,197,36.2V16.1c-102.3,8.2-183,94-183,198.4s80.7,190.2,183,198.4V392.7z'/>\\n<path fill='#5F7FBF' stroke='#5F7FBF' stroke-width='6' stroke-miterlimit='10' d='M229,16.1v20.1c91.2,8.1,163,85,163,178.3\\n  s-71.8,170.2-163,178.3v20.1c102.3-8.2,183-94,183-198.4S331.3,24.3,229,16.1z'/>\\n</svg>\")\n"} {:sym close-bad-compile-screen, :meta {:doc nil, :arglists ([])}, :source "(defn\n close-bad-compile-screen\n []\n (when-let\n  [el (js/document.getElementById \"figwheelFailScreen\")]\n  (dom/removeNode el)))\n"} {:sym format-inline-error, :meta {:doc nil, :arglists ([inline-error])}, :source "(defn\n format-inline-error\n [inline-error]\n (let\n  [lines\n   (map format-inline-error-line (pad-line-numbers inline-error))]\n  (str\n   \"<pre style='whitespace:pre; overflow-x: scroll; display:block; font-family:monospace; font-size:0.8em; border-radius: 3px;\"\n   \" line-height: 1.1em; padding: 10px; background-color: rgb(24,26,38); margin-right: 5px'>\"\n   (string/join \"\\n\" lines)\n   \"</pre>\")))\n"} {:sym format-warning-message, :meta {:doc nil, :arglists ([{:keys [message file line column], :as warning-data}])}, :source "(defn\n format-warning-message\n [{:keys [message file line column], :as warning-data}]\n (cond->\n  message\n  line\n  (str \" at line \" line)\n  (and line column)\n  (str \", column \" column)\n  file\n  (str \" in file \" file)))\n"} {:sym display-system-warning, :meta {:doc nil, :arglists ([header msg])}, :source "(defn\n display-system-warning\n [header msg]\n (display-heads-up\n  {:backgroundColor \"rgba(255, 220, 110, 0.95)\"}\n  (str (close-link) (heading header) \"<div>\" msg \"</div>\")))\n"} {:sym close-link, :meta {:doc nil, :arglists ([])}, :source "(defn\n close-link\n []\n (str\n  \"<a style=\\\"\"\n  \"float: right;\"\n  \"font-size: 18px;\"\n  \"text-decoration: none;\"\n  \"text-align: right;\"\n  \"width: 30px;\"\n  \"height: 30px;\"\n  \"color: rgba(84,84,84, 0.5);\"\n  \"\\\" href=\\\"#\\\"  data-figwheel-event=\\\"close-heads-up\\\">\"\n  \"x\"\n  \"</a>\"))\n"} {:sym ancestor-nodes, :meta {:doc nil, :arglists ([el])}, :source "(defn ancestor-nodes [el] (iterate (fn [e] (.-parentNode e)) el))\n"} {:sym flash-loaded, :meta {:doc nil, :arglists ([])}, :source "(defn\n flash-loaded\n []\n (go (<! (display-loaded-start)) (<! (timeout 400)) (<! (clear))))\n"}), figwheel.client.socket ({:sym get-websocket-imp, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-websocket-imp\n []\n (or\n  (gobj/get goog.global \"FIGWHEEL_WEBSOCKET_CLASS\")\n  (gobj/get goog.global \"WebSocket\")\n  (cond\n   (utils/html-or-react-native-env?)\n   (gobj/get js/window \"WebSocket\")\n   (utils/node-env?)\n   (try (js/require \"ws\") (catch js/Error e nil))\n   (utils/worker-env?)\n   (gobj/get js/self \"WebSocket\")\n   :else\n   nil)))\n"} {:sym message-history-atom, :meta {}, :source "(defonce message-history-atom (atom (list)))\n"} {:sym socket-atom, :meta {}, :source "(defonce socket-atom (atom false))\n"} {:sym send!, :meta {:doc "Send a end message to the server.", :arglists ([msg])}, :source "(defn\n send!\n \"Send a end message to the server.\"\n [msg]\n (when @socket-atom (.send @socket-atom (pr-str msg))))\n"} {:sym close!, :meta {:doc nil, :arglists ([])}, :source "(defn\n close!\n []\n (set! (.-onclose @socket-atom) identity)\n (.close @socket-atom))\n"} {:sym handle-incoming-message, :meta {:doc nil, :arglists ([msg])}, :source "(defn\n handle-incoming-message\n [msg]\n (utils/debug-prn msg)\n (and\n  (map? msg)\n  (:msg-name msg)\n  (not= (:msg-name msg) :ping)\n  (swap! message-history-atom conj msg)))\n"} {:sym open, :meta {:doc nil, :arglists ([{:keys [retry-count retried-count websocket-url build-id], :as opts}])}, :source "(defn\n open\n [{:keys [retry-count retried-count websocket-url build-id], :as opts}]\n (if-let\n  [WebSocket (get-websocket-imp)]\n  (do\n   (utils/log :debug \"Figwheel: trying to open cljs reload socket\")\n   (let\n    [url\n     (str websocket-url (if build-id (str \"/\" build-id) \"\"))\n     socket\n     (WebSocket. url)]\n    (set!\n     (.-onmessage socket)\n     (fn\n      [msg-str]\n      (when-let\n       [msg (read-string (.-data msg-str))]\n       (#'handle-incoming-message msg))))\n    (set!\n     (.-onopen socket)\n     (fn\n      [x]\n      (reset! socket-atom socket)\n      (when\n       (utils/html-env?)\n       (.addEventListener js/window \"beforeunload\" close!))\n      (utils/log :debug \"Figwheel: socket connection established\")))\n    (set!\n     (.-onclose socket)\n     (fn\n      [x]\n      (let\n       [retried-count (or retried-count 0)]\n       (utils/debug-prn \"Figwheel: socket closed or failed to open\")\n       (when\n        (> retry-count retried-count)\n        (js/setTimeout\n         (fn [] (open (assoc opts :retried-count (inc retried-count))))\n         (min 10000 (+ 2000 (* 500 retried-count))))))))\n    (set!\n     (.-onerror socket)\n     (fn [x] (utils/debug-prn \"Figwheel: socket error \")))\n    socket))\n  (utils/log\n   :debug\n   (if\n    (utils/node-env?)\n    \"Figwheel: Can't start Figwheel!! Please make sure ws is installed\\n do -> 'npm install ws'\"\n    \"Figwheel: Can't start Figwheel!! This browser doesn't support WebSockets\"))))\n"}), clojure.string ({:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :source "(defn\n ends-with?\n \"True if s ends with substr.\"\n [s substr]\n (gstring/endsWith s substr))\n"} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :source "(defn\n capitalize\n \"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"\n [s]\n (gstring/capitalize s))\n"} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :source "(defn\n reverse\n \"Returns s with its characters reversed.\"\n [s]\n (->\n  (.replace s re-surrogate-pair \"$2$1\")\n  (.. (split \"\") (reverse) (join \"\"))))\n"} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists [[coll] [separator coll]]}, :source "(defn\n join\n \"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"\n ([coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (recur (. sb (append (str (first coll)))) (next coll))\n    (.toString sb))))\n ([separator coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (do\n     (. sb (append (str (first coll))))\n     (let\n      [coll (next coll)]\n      (when-not (nil? coll) (. sb (append separator)))\n      (recur sb coll)))\n    (.toString sb)))))\n"} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace-first\n \"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (.replace s match replacement))\n"} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :source "(defn\n starts-with?\n \"True if s starts with substr.\"\n [s substr]\n (gstring/startsWith s substr))\n"} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :source "(defn\n escape\n \"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n [s cmap]\n (let\n  [buffer (StringBuffer.) length (.-length s)]\n  (loop\n   [index 0]\n   (if\n    (== length index)\n    (. buffer (toString))\n    (let\n     [ch (.charAt s index) replacement (get cmap ch)]\n     (if-not\n      (nil? replacement)\n      (.append buffer (str replacement))\n      (.append buffer ch))\n     (recur (inc index)))))))\n"} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n last-index-of\n \"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.lastIndexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.lastIndexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :source "(defn\n includes?\n \"True if s includes substr.\"\n [s substr]\n (gstring/contains s substr))\n"} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace\n \"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (cond\n  (string? match)\n  (.replace\n   s\n   (js/RegExp. (gstring/regExpEscape match) \"g\")\n   replacement)\n  (instance? js/RegExp match)\n  (if\n   (string? replacement)\n   (replace-all s match replacement)\n   (replace-all s match (replace-with replacement)))\n  :else\n  (throw (str \"Invalid match arg: \" match))))\n"} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :source "(defn split-lines \"Splits s on \\n or \\r\\n.\" [s] (split s #\"\\n|\\r\\n\"))\n"} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :source "(defn\n lower-case\n \"Converts string to all lower-case.\"\n [s]\n (.toLowerCase s))\n"} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :source "(defn\n trim-newline\n \"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"\n [s]\n (loop\n  [index (.-length s)]\n  (if\n   (zero? index)\n   \"\"\n   (let\n    [ch (get s (dec index))]\n    (if\n     (or (identical? \\newline ch) (identical? \\return ch))\n     (recur (dec index))\n     (.substring s 0 index))))))\n"} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :source "(defn\n upper-case\n \"Converts string to all upper-case.\"\n [s]\n (.toUpperCase s))\n"} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists [[s re] [s re limit]]}, :source "(defn\n split\n \"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n ([s re] (split s re 0))\n ([s re limit]\n  (discard-trailing-if-needed\n   limit\n   (if\n    (identical? \"/(?:)/\" (str re))\n    (split-with-empty-regex s limit)\n    (if\n     (< limit 1)\n     (vec (.split (str s) re))\n     (loop\n      [s s limit limit parts []]\n      (if\n       (== 1 limit)\n       (conj parts s)\n       (let\n        [m (re-find re s)]\n        (if-not\n         (nil? m)\n         (let\n          [index (.indexOf s m)]\n          (recur\n           (.substring s (+ index (count m)))\n           (dec limit)\n           (conj parts (.substring s 0 index))))\n         (conj parts s))))))))))\n"} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :source "(defn\n trimr\n \"Removes whitespace from the right side of string.\"\n [s]\n (gstring/trimRight s))\n"} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n index-of\n \"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.indexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.indexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :source "(defn\n trim\n \"Removes whitespace from both ends of string.\"\n [s]\n (gstring/trim s))\n"} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :source "(defn\n triml\n \"Removes whitespace from the left side of string.\"\n [s]\n (gstring/trimLeft s))\n"} {:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :source "(defn\n blank?\n \"True is s is nil, empty, or contains only whitespace.\"\n [s]\n (gstring/isEmptySafe s))\n"}), cljs.spec.alpha ({:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :source "(defn form \"returns the spec as data\" [spec] (describe* (specize spec)))\n"} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :source "(defn\n nilable-impl\n \"Do not call this directly, use 'nilable'\"\n [form pred gfn]\n (let\n  [spec (specize pred form)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (if (nil? x) nil (conform* spec x)))\n   (unform* [_ x] (if (nil? x) nil (unform* spec x)))\n   (explain*\n    [_ path via in x]\n    (when-not\n     (c/or (pvalid? spec x) (nil? x))\n     (conj\n      (explain-1 form pred (conj path :clojure.core/pred) via in x)\n      {:path (conj path :clojure.core/nil),\n       :pred 'nil?,\n       :val x,\n       :via via,\n       :in in})))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gen/frequency\n      [[1 (gen/delay (gen/return nil))]\n       [9\n        (gen/delay\n         (gensub\n          pred\n          overrides\n          (conj path :clojure.core/pred)\n          rmap\n          form))]])))\n   (with-gen* [_ gfn] (nilable-impl form pred gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nilable)\n       (clojure.core/list (s/mres form)))))))))\n"} {:sym *recursion-limit*, :meta {}, :source "(def\n *recursion-limit*\n \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\\n  can be recursed through during generation. After this a\\n  non-recursive branch will be chosen.\"\n 4)\n"} {:sym *coll-error-limit*, :meta {}, :source "(def\n *coll-error-limit*\n \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n 20)\n"} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :source "(defn\n explain-printer\n \"Default printer for explain-data. nil indicates a successful validation.\"\n [ed]\n (if\n  ed\n  (let\n   [problems\n    (sort-by\n     (fn* [p1__18550#] (- (count (:path p1__18550#))))\n     (:clojure.core/problems ed))]\n   (print\n    (with-out-str\n     (doseq\n      [{:keys [path pred val reason via in], :as prob} problems]\n      (when-not (empty? in) (print \"In:\" (pr-str in) \"\"))\n      (print \"val: \")\n      (pr val)\n      (print \" fails\")\n      (when-not (empty? via) (print \" spec:\" (pr-str (last via))))\n      (when-not (empty? path) (print \" at:\" (pr-str path)))\n      (print \" predicate: \")\n      (pr (abbrev pred))\n      (when reason (print \", \" reason))\n      (doseq\n       [[k v] prob]\n       (when-not\n        (#{:path :pred :via :val :reason :in} k)\n        (print \"\\n\\t\" (pr-str k) \" \")\n        (pr v)))\n      (newline))\n     (doseq\n      [[k v] ed]\n      (when-not\n       (#{:clojure.core/problems} k)\n       (print (pr-str k) \" \")\n       (pr v)\n       (newline))))))\n  (println \"Success!\")))\n"} {:sym Specize, :meta {:doc nil}, :methods (specize*)} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :source "(defn\n alt-impl\n \"Do not call this directly, use 'alt'\"\n [ks ps forms]\n (assoc (alt* ps ks forms) :id (random-uuid)))\n"} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :source "(defn\n def-impl\n \"Do not call this directly, use 'def'\"\n [k form spec]\n (assert\n  (c/and (ident? k) (namespace k))\n  \"k must be namespaced keyword or resolveable symbol\")\n (let\n  [spec\n   (if\n    (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n    spec\n    (spec-impl form spec nil nil))]\n  (swap! registry-ref assoc k (with-name spec k))\n  k))\n"} {:sym *explain-out*, :meta {}, :source "(def *explain-out* explain-printer)\n"} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :source "(defn\n regex-spec-impl\n \"Do not call this directly, use 'spec' with a regex op argument\"\n [re gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-conform re (seq x))\n    :clojure.core/invalid))\n  (unform* [_ x] (op-unform re x))\n  (explain*\n   [_ path via in x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-explain path via in re (seq x))\n    [{:path path, :pred (op-describe re), :val x, :via via, :in in}]))\n  (gen*\n   [_ overrides path rmap]\n   (if gfn (gfn) (re-gen re overrides path rmap (op-describe re))))\n  (with-gen* [_ gfn] (regex-spec-impl re gfn))\n  (describe* [_] (op-describe re))))\n"} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :source "(defn\n merge-spec-impl\n \"Do not call this directly, use 'merge'\"\n [forms preds gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (let\n    [ms\n     (map\n      (fn* [p1__18562# p2__18563#] (dt p1__18562# x p2__18563#))\n      preds\n      forms)]\n    (if (some invalid? ms) :clojure.core/invalid (apply c/merge ms))))\n  (unform*\n   [_ x]\n   (apply\n    c/merge\n    (map (fn* [p1__18564#] (unform p1__18564# x)) (reverse preds))))\n  (explain*\n   [_ path via in x]\n   (apply\n    concat\n    (map\n     (fn*\n      [p1__18565# p2__18566#]\n      (explain-1 p1__18565# p2__18566# path via in x))\n     forms\n     preds)))\n  (gen*\n   [_ overrides path rmap]\n   (if\n    gfn\n    (gfn)\n    (gen/fmap\n     (fn* [p1__18567#] (apply c/merge p1__18567#))\n     (apply\n      gen/tuple\n      (map\n       (fn*\n        [p1__18568# p2__18569#]\n        (gensub p1__18568# overrides path rmap p2__18569#))\n       preds\n       forms)))))\n  (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n  (describe*\n   [_]\n   (clojure.core/sequence\n    (clojure.core/seq\n     (clojure.core/concat\n      (clojure.core/list 'clojure.core/merge)\n      forms))))))\n"} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :source "(defn\n explain-data*\n [spec path via in x]\n (when-let\n  [probs (explain* (specize spec) path via in x)]\n  (when-not\n   (empty? probs)\n   {:clojure.core/problems probs,\n    :clojure.core/spec spec,\n    :clojure.core/value x})))\n"} {:sym MAX_INT, :meta {}, :source "(def MAX_INT 9007199254740991)\n"} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :source "(defn\n check-asserts\n \"Enable or disable spec asserts that have been compiled\\nwith '*compile-asserts*' true.  See 'assert'.\\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\\nDefaults to false.\"\n [flag]\n (set! *runtime-asserts* flag))\n"} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :source "(defn\n assert*\n \"Do not call this directly, use 'assert'.\"\n [spec x]\n (if\n  (valid? spec x)\n  x\n  (let\n   [ed\n    (c/merge\n     (assoc\n      (explain-data* spec [] [] [] x)\n      :clojure.core/failure\n      :assertion-failed))]\n   (throw\n    (js/Error.\n     (str\n      \"Spec assertion failed\\n\"\n      (with-out-str (explain-out ed))))))))\n"} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :source "(defn\n inst-in-range?\n \"Return true if inst at or after start and before end\"\n [start end inst]\n (c/and\n  (inst? inst)\n  (let\n   [t (inst-ms inst)]\n   (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n"} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :source "(defn\n and-spec-impl\n \"Do not call this directly, use 'and'\"\n [forms preds gfn]\n (let\n  [specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (conform* (specs 1) ret))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (let\n        [ret (conform* (specs 1) ret)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (conform* (specs 2) ret))))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [ret x i 0]\n       (if\n        (< i (count specs))\n        (let\n         [nret (conform* (specs i) ret)]\n         (if\n          (invalid? nret)\n          :clojure.core/invalid\n          (recur nret (inc i))))\n        ret)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform*\n    [_ x]\n    (reduce\n     (fn* [p1__18561# p2__18560#] (unform p2__18560# p1__18561#))\n     x\n     (reverse preds)))\n   (explain*\n    [_ path via in x]\n    (explain-pred-list forms preds path via in x))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gensub (first preds) overrides path rmap (first forms))))\n   (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/and)\n       forms)))))))\n"} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :protocol Spec} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :source "(defn\n map-spec-impl\n \"Do not call this directly, use 'spec' with a map argument\"\n [{:keys\n   [req-un\n    opt-un\n    keys-pred\n    pred-exprs\n    opt-keys\n    req-specs\n    req\n    req-keys\n    opt-specs\n    pred-forms\n    opt\n    gfn],\n   :as argm}]\n (let\n  [k->s\n   (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n   keys->specnames\n   (fn* [p1__18552#] (c/or (k->s p1__18552#) p1__18552#))\n   id\n   (random-uuid)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ m]\n    (if\n     (keys-pred m)\n     (let\n      [reg (registry)]\n      (loop\n       [ret m [[k v] & ks :as keys] m]\n       (if\n        keys\n        (let\n         [sname (keys->specnames k)]\n         (if-let\n          [s (get reg sname)]\n          (let\n           [cv (conform s v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (if (identical? cv v) ret (assoc ret k cv)) ks)))\n          (recur ret ks)))\n        ret)))\n     :clojure.core/invalid))\n   (unform*\n    [_ m]\n    (let\n     [reg (registry)]\n     (loop\n      [ret m [k & ks :as keys] (c/keys m)]\n      (if\n       keys\n       (if\n        (contains? reg (keys->specnames k))\n        (let\n         [cv (get m k) v (unform (keys->specnames k) cv)]\n         (recur (if (identical? cv v) ret (assoc ret k v)) ks))\n        (recur ret ks))\n       ret))))\n   (explain*\n    [_ path via in x]\n    (if-not\n     (map? x)\n     [{:path path, :pred 'map?, :val x, :via via, :in in}]\n     (let\n      [reg (registry)]\n      (apply\n       concat\n       (when-let\n        [probs\n         (->>\n          (map\n           (fn [pred form] (when-not (pred x) form))\n           pred-exprs\n           pred-forms)\n          (keep identity)\n          seq)]\n        (map\n         (fn*\n          [p1__18553#]\n          (identity\n           {:path path, :pred p1__18553#, :val x, :via via, :in in}))\n         probs))\n       (map\n        (fn\n         [[k v]]\n         (when-not\n          (c/or\n           (not (contains? reg (keys->specnames k)))\n           (pvalid? (keys->specnames k) v k))\n          (explain-1\n           (keys->specnames k)\n           (keys->specnames k)\n           (conj path k)\n           via\n           (conj in k)\n           v)))\n        (seq x))))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [rmap\n       (inck rmap id)\n       gen\n       (fn [k s] (gensub s overrides (conj path k) rmap k))\n       ogen\n       (fn\n        [k s]\n        (when-not\n         (recur-limit? rmap id path k)\n         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n       req-gens\n       (map gen req-keys req-specs)\n       opt-gens\n       (remove nil? (map ogen opt-keys opt-specs))]\n      (when\n       (every? identity (concat req-gens opt-gens))\n       (let\n        [reqs (zipmap req-keys req-gens) opts (into {} opt-gens)]\n        (gen/bind\n         (gen/choose 0 (count opts))\n         (fn*\n          [p1__18554#]\n          (let\n           [args\n            (concat (seq reqs) (when (seq opts) (shuffle (seq opts))))]\n           (->>\n            args\n            (take (c/+ p1__18554# (count reqs)))\n            (apply concat)\n            (apply gen/hash-map))))))))))\n   (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n   (describe*\n    [_]\n    (cons\n     'clojure.core/keys\n     (cond->\n      []\n      req\n      (conj :req req)\n      opt\n      (conj :opt opt)\n      req-un\n      (conj :req-un req-un)\n      opt-un\n      (conj :opt-un opt-un)))))))\n"} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :source "(defn\n explain\n \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n [spec x]\n (explain-out (explain-data spec x)))\n"} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :protocol Spec} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :source "(defn\n or-spec-impl\n \"Do not call this directly, use 'or'\"\n [keys forms preds gfn]\n (let\n  [id\n   (random-uuid)\n   kps\n   (zipmap keys preds)\n   specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         (let\n          [ret (conform* (specs 2) x)]\n          (if\n           (invalid? ret)\n           :clojure.core/invalid\n           (tagged-ret [(keys 2) ret])))\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [i 0]\n       (if\n        (< i (count specs))\n        (let\n         [spec (specs i)]\n         (let\n          [ret (conform* spec x)]\n          (if\n           (invalid? ret)\n           (recur (inc i))\n           (tagged-ret [(keys i) ret]))))\n        :clojure.core/invalid)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform* [_ [k x]] (unform (kps k) x))\n   (explain*\n    [this path via in x]\n    (when-not\n     (pvalid? this x)\n     (apply\n      concat\n      (map\n       (fn\n        [k form pred]\n        (when-not\n         (pvalid? pred x)\n         (explain-1 form pred (conj path k) via in x)))\n       keys\n       forms\n       preds))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [gen\n       (fn\n        [k p f]\n        (let\n         [rmap (inck rmap id)]\n         (when-not\n          (recur-limit? rmap id path k)\n          (gen/delay (gensub p overrides (conj path k) rmap f)))))\n       gs\n       (remove nil? (map gen keys preds forms))]\n      (when-not (empty? gs) (gen/one-of gs)))))\n   (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/or)\n       (mapcat vector keys forms))))))))\n"} {:sym *fspec-iterations*, :meta {}, :source "(def\n *fspec-iterations*\n \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n 21)\n"} {:sym Spec, :meta {:doc nil}, :methods (conform* describe* explain* gen* unform* with-gen*)} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :source "(defn\n unform\n \"Given a spec and a value created by or compliant with a call to\\n  'conform' with the same spec, returns a value with all conform\\n   destructuring undone.\"\n [spec x]\n (unform* (specize spec) x))\n"} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists [[spec x] [spec x form]]}, :source "(defn\n valid?\n \"Helper function that returns true when x is valid for spec.\"\n ([spec x]\n  (let [spec (specize spec)] (not (invalid? (conform* spec x)))))\n ([spec x form]\n  (let [spec (specize spec form)] (not (invalid? (conform* spec x))))))\n"} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists [[spec] [spec overrides]]}, :source "(defn\n gen\n \"Given a spec, returns the generator for it, or throws if none can\\n  be constructed. Optionally an overrides map can be provided which\\n  should map spec names or paths (vectors of keywords) to no-arg\\n  generator-creating fns. These will be used instead of the generators at those\\n  names/paths. Note that parent generator (in the spec or overrides\\n  map) will supersede those of any subtrees. A generator for a regex\\n  op must always return a sequential collection (i.e. a generator for\\n  s/? should return either an empty sequence/vector or a\\n  sequence/vector with one item in it)\"\n ([spec] (gen spec nil))\n ([spec overrides]\n  (gensub\n   spec\n   overrides\n   []\n   {:clojure.core/recursion-limit *recursion-limit*}\n   spec)))\n"} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :source "(defn\n nonconforming\n \"takes a spec and returns a spec that has the same properties except\\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n [spec]\n (let\n  [spec (specize spec)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ x]\n    (let\n     [ret (conform* spec x)]\n     (if (invalid? ret) :clojure.core/invalid x)))\n   (unform* [_ x] (unform* spec x))\n   (explain* [_ path via in x] (explain* spec path via in x))\n   (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n   (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nonconforming)\n       (clojure.core/list (describe* spec)))))))))\n"} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :protocol Spec} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :source "(defn\n abbrev\n [form]\n (cond\n  (seq? form)\n  (walk/postwalk\n   (fn\n    [form]\n    (cond\n     (c/and (symbol? form) (namespace form))\n     (-> form name symbol)\n     (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n     (last form)\n     :else\n     form))\n   form)\n  (c/and (symbol? form) (namespace form))\n  (-> form name symbol)\n  :else\n  form))\n"} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :source "(defn\n regex?\n \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n [x]\n (c/and (:clojure.core/op x) x))\n"} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :source "(defn\n int-in-range?\n \"Return true if start <= val, val < end and val is a fixed\\n  precision integer.\"\n [start end val]\n (cond\n  (integer? val)\n  (c/and (<= start val) (< val end))\n  (instance? goog.math.Long val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  (instance? goog.math.Integer val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  :else\n  false))\n"} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :source "(defn\n spec?\n \"returns x if x is a spec object, else logical false\"\n [x]\n (when (implements? Spec x) x))\n"} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :source "(defn\n registry\n \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n []\n @registry-ref)\n"} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :source "(defn\n rep+impl\n \"Do not call this directly, use '+'\"\n [form p]\n (pcat*\n  {:ps [p (rep* p p [] true form)],\n   :forms\n   (clojure.core/vec\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list form)\n       (clojure.core/list\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/*)\n           (clojure.core/list form))))))))),\n   :ret [],\n   :rep+ form}))\n"} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists [[spec] [spec n] [spec n overrides]]}, :source "(defn\n exercise\n \"generates a number (default 10) of values compatible with spec and maps conform over them,\\n  returning a sequence of [val conformed-val] tuples. Optionally takes\\n  a generator overrides map as per gen\"\n ([spec] (exercise spec 10))\n ([spec n] (exercise spec n nil))\n ([spec n overrides]\n  (map\n   (fn* [p1__18585#] (vector p1__18585# (conform spec p1__18585#)))\n   (gen/sample (gen spec overrides) n))))\n"} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :source "(defn\n explain-data\n \"Given a spec and a value x which ought to conform, returns nil if x\\n  conforms, else a map with at least the key ::problems whose value is\\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\\n  keys describing the predicate and the value that failed at that\\n  path.\"\n [spec x]\n (explain-data*\n  spec\n  []\n  (if-let [name (spec-name spec)] [name] [])\n  []\n  x))\n"} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists [[forms preds] [forms preds gfn]]}, :source "(defn\n tuple-impl\n \"Do not call this directly, use 'tuple'\"\n ([forms preds] (tuple-impl forms preds nil))\n ([forms preds gfn]\n  (let\n   [specs (delay (mapv specize preds forms)) cnt (count preds)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [specs @specs]\n      (if-not\n       (c/and (vector? x) (= (count x) cnt))\n       :clojure.core/invalid\n       (loop\n        [ret x i 0]\n        (if\n         (= i cnt)\n         ret\n         (let\n          [v (x i) cv (conform* (specs i) v)]\n          (if\n           (invalid? cv)\n           :clojure.core/invalid\n           (recur\n            (if (identical? cv v) ret (assoc ret i cv))\n            (inc i)))))))))\n    (unform*\n     [_ x]\n     (assert (c/and (vector? x) (= (count x) (count preds))))\n     (loop\n      [ret x i 0]\n      (if\n       (= i (count x))\n       ret\n       (let\n        [cv (x i) v (unform (preds i) cv)]\n        (recur (if (identical? cv v) ret (assoc ret i v)) (inc i))))))\n    (explain*\n     [_ path via in x]\n     (cond\n      (not (vector? x))\n      [{:path path, :pred 'vector?, :val x, :via via, :in in}]\n      (not= (count x) (count preds))\n      [{:path path,\n        :pred\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/=)\n           (clojure.core/list\n            (clojure.core/sequence\n             (clojure.core/seq\n              (clojure.core/concat\n               (clojure.core/list 'clojure.core/count)\n               (clojure.core/list '%)))))\n           (clojure.core/list (count preds))))),\n        :val x,\n        :via via,\n        :in in}]\n      :else\n      (apply\n       concat\n       (map\n        (fn\n         [i form pred]\n         (let\n          [v (x i)]\n          (when-not\n           (pvalid? pred v)\n           (explain-1 form pred (conj path i) via (conj in i) v))))\n        (range (count preds))\n        forms\n        preds))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn [i p f] (gensub p overrides (conj path i) rmap f))\n        gs\n        (map gen (range (count preds)) preds forms)]\n       (when (every? identity gs) (apply gen/tuple gs)))))\n    (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/tuple)\n        forms))))))))\n"} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists [[form mmvar retag] [form mmvar retag gfn]]}, :source "(defn\n multi-spec-impl\n \"Do not call this directly, use 'multi-spec'\"\n ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n ([form mmvar retag gfn]\n  (let\n   [id\n    (random-uuid)\n    predx\n    (fn*\n     [p1__18555#]\n     (let\n      [mm @mmvar]\n      (c/and\n       (-get-method mm ((-dispatch-fn mm) p1__18555#))\n       (mm p1__18555#))))\n    dval\n    (fn* [p1__18556#] ((-dispatch-fn @mmvar) p1__18556#))\n    tag\n    (if\n     (keyword? retag)\n     (fn* [p1__18557# p2__18558#] (assoc p1__18557# retag p2__18558#))\n     retag)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (if-let [pred (predx x)] (dt pred x form) :clojure.core/invalid))\n    (unform*\n     [_ x]\n     (if-let\n      [pred (predx x)]\n      (unform pred x)\n      (throw\n       (js/Error.\n        (str\n         \"No method of: \"\n         form\n         \" for dispatch value: \"\n         (dval x))))))\n    (explain*\n     [_ path via in x]\n     (let\n      [dv (dval x) path (conj path dv)]\n      (if-let\n       [pred (predx x)]\n       (explain-1 form pred path via in x)\n       [{:path path,\n         :pred form,\n         :val x,\n         :reason \"no method\",\n         :via via,\n         :in in}])))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn\n         [[k f]]\n         (let\n          [p (f nil)]\n          (let\n           [rmap (inck rmap id)]\n           (when-not\n            (recur-limit? rmap id path k)\n            (gen/delay\n             (gen/fmap\n              (fn* [p1__18559#] (tag p1__18559# k))\n              (gensub\n               p\n               overrides\n               (conj path k)\n               rmap\n               (list 'method form k))))))))\n        gs\n        (->>\n         (methods @mmvar)\n         (remove (fn [[k]] (invalid? k)))\n         (map gen)\n         (remove nil?))]\n       (when (every? identity gs) (gen/one-of gs)))))\n    (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/multi-spec)\n        (clojure.core/list form)\n        (clojure.core/list retag)))))))))\n"} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :source "(defn\n conform\n \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\\n  not match spec, else the (possibly destructured) value.\"\n [spec x]\n (conform* (specize spec) x))\n"} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :protocol Spec} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :source "(defn\n fspec-impl\n \"Do not call this directly, use 'fspec'\"\n [argspec aform retspec rform fnspec fform gfn]\n (let\n  [specs {:args argspec, :ret retspec, :fn fnspec}]\n  (reify\n   ILookup\n   (-lookup [this k] (get specs k))\n   (-lookup [_ k not-found] (get specs k not-found))\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ f]\n    (if\n     (ifn? f)\n     (if\n      (identical? f (validate-fn f specs *fspec-iterations*))\n      f\n      :clojure.core/invalid)\n     :clojure.core/invalid))\n   (unform* [_ f] f)\n   (explain*\n    [_ path via in f]\n    (if\n     (ifn? f)\n     (let\n      [args (validate-fn f specs 100)]\n      (if\n       (identical? f args)\n       nil\n       (let\n        [ret (try (apply f args) (catch js/Error t t))]\n        (if\n         (instance? js/Error ret)\n         [{:path path,\n           :pred '(apply fn),\n           :val args,\n           :reason (.-message ret),\n           :via via,\n           :in in}]\n         (let\n          [cret (dt retspec ret rform)]\n          (if\n           (invalid? cret)\n           (explain-1 rform retspec (conj path :ret) via in ret)\n           (when\n            fnspec\n            (let\n             [cargs (conform argspec args)]\n             (explain-1\n              fform\n              fnspec\n              (conj path :fn)\n              via\n              in\n              {:args cargs, :ret cret})))))))))\n     [{:path path, :pred 'ifn?, :val f, :via via, :in in}]))\n   (gen*\n    [_ overrides _ _]\n    (if\n     gfn\n     (gfn)\n     (gen/return\n      (fn\n       [& args]\n       (assert\n        (pvalid? argspec args)\n        (with-out-str (explain argspec args)))\n       (gen/generate (gen retspec overrides))))))\n   (with-gen*\n    [_ gfn]\n    (fspec-impl argspec aform retspec rform fnspec fform gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/fspec)\n       (clojure.core/list :args)\n       (clojure.core/list aform)\n       (clojure.core/list :ret)\n       (clojure.core/list rform)\n       (clojure.core/list :fn)\n       (clojure.core/list fform))))))))\n"} {:sym *coll-check-limit*, :meta {}, :source "(def\n *coll-check-limit*\n \"The number of items validated in a collection spec'ed with 'every'\"\n 101)\n"} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :source "(defn\n get-spec\n \"Returns spec registered for keyword/symbol/var k, or nil.\"\n [k]\n (get (registry) (if (keyword? k) k (->sym k))))\n"} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists [[form pred opts] [form pred {gen-into :into, describe-form :clojure.core/describe, :keys [kind :clojure.core/kind-form count max-count min-count distinct gen-max :clojure.core/kfn :clojure.core/cpred conform-keys :clojure.core/conform-all], :or {gen-max 20}, :as opts} gfn]]}, :source "(defn\n every-impl\n \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n ([form pred opts] (every-impl form pred opts nil))\n ([form\n   pred\n   {gen-into :into,\n    describe-form :clojure.core/describe,\n    :keys\n    [kind\n     :clojure.core/kind-form\n     count\n     max-count\n     min-count\n     distinct\n     gen-max\n     :clojure.core/kfn\n     :clojure.core/cpred\n     conform-keys\n     :clojure.core/conform-all],\n    :or {gen-max 20},\n    :as opts}\n   gfn]\n  (let\n   [conform-into\n    gen-into\n    spec\n    (delay (specize pred))\n    check?\n    (fn* [p1__18570#] (valid? @spec p1__18570#))\n    kfn\n    (c/or kfn (fn [i v] i))\n    addcv\n    (fn [ret i v cv] (conj ret cv))\n    cfns\n    (fn\n     [x]\n     (cond\n      (c/and\n       (vector? x)\n       (c/or (not conform-into) (vector? conform-into)))\n      [identity\n       (fn [ret i v cv] (if (identical? v cv) ret (assoc ret i cv)))\n       identity]\n      (c/and\n       (map? x)\n       (c/or (c/and kind (not conform-into)) (map? conform-into)))\n      [(if conform-keys empty identity)\n       (fn\n        [ret i v cv]\n        (if\n         (c/and (identical? v cv) (not conform-keys))\n         ret\n         (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n       identity]\n      (c/or\n       (list? conform-into)\n       (seq? conform-into)\n       (c/and (not conform-into) (c/or (list? x) (seq? x))))\n      [empty addcv reverse]\n      :else\n      [(fn* [p1__18571#] (empty (c/or conform-into p1__18571#)))\n       addcv\n       identity]))]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [spec @spec]\n      (cond\n       (not (cpred x))\n       :clojure.core/invalid\n       conform-all\n       (let\n        [[init add complete] (cfns x)]\n        (loop\n         [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n         (if\n          vseq\n          (let\n           [cv (conform* spec v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (add ret i v cv) (inc i) vs)))\n          (complete ret))))\n       :else\n       (if\n        (indexed? x)\n        (let\n         [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n         (loop\n          [i 0]\n          (if\n           (>= i (c/count x))\n           x\n           (if\n            (valid? spec (nth x i))\n            (recur (c/+ i step))\n            :clojure.core/invalid))))\n        (let\n         [limit *coll-check-limit*]\n         (loop\n          [i 0 [v & vs :as vseq] (seq x)]\n          (cond\n           (c/or (nil? vseq) (= i limit))\n           x\n           (valid? spec v)\n           (recur (inc i) vs)\n           :else\n           :clojure.core/invalid)))))))\n    (unform*\n     [_ x]\n     (if\n      conform-all\n      (let\n       [spec @spec [init add complete] (cfns x)]\n       (loop\n        [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n        (if\n         (>= i (c/count x))\n         (complete ret)\n         (recur (add ret i v (unform* spec v)) (inc i) vs))))\n      x))\n    (explain*\n     [_ path via in x]\n     (c/or\n      (coll-prob\n       x\n       kind\n       kind-form\n       distinct\n       count\n       min-count\n       max-count\n       path\n       via\n       in)\n      (apply\n       concat\n       ((if conform-all identity (partial take *coll-error-limit*))\n        (keep\n         identity\n         (map\n          (fn\n           [i v]\n           (let\n            [k (kfn i v)]\n            (when-not\n             (check? v)\n             (let\n              [prob (explain-1 form pred path via (conj in k) v)]\n              prob))))\n          (range)\n          x))))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [pgen (gensub pred overrides path rmap form)]\n       (gen/bind\n        (cond\n         gen-into\n         (gen/return (empty gen-into))\n         kind\n         (gen/fmap\n          (fn*\n           [p1__18572#]\n           (if (empty? p1__18572#) p1__18572# (empty p1__18572#)))\n          (gensub kind overrides path rmap form))\n         :else\n         (gen/return []))\n        (fn\n         [init]\n         (gen/fmap\n          (fn*\n           [p1__18573#]\n           (if (vector? init) p1__18573# (into init p1__18573#)))\n          (cond\n           distinct\n           (if\n            count\n            (gen/vector-distinct\n             pgen\n             {:num-elements count, :max-tries 100})\n            (gen/vector-distinct\n             pgen\n             {:min-elements (c/or min-count 0),\n              :max-elements\n              (c/or\n               max-count\n               (max gen-max (c/* 2 (c/or min-count 0)))),\n              :max-tries 100}))\n           count\n           (gen/vector pgen count)\n           (c/or min-count max-count)\n           (gen/vector\n            pgen\n            (c/or min-count 0)\n            (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n           :else\n           (gen/vector pgen 0 gen-max))))))))\n    (with-gen* [_ gfn] (every-impl form pred opts gfn))\n    (describe*\n     [_]\n     (c/or\n      describe-form\n      (clojure.core/sequence\n       (clojure.core/seq\n        (clojure.core/concat\n         (clojure.core/list 'clojure.core/every)\n         (clojure.core/list (s/mres form))\n         (mapcat identity opts))))))))))\n"} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists [[form pred gfn cpred?] [form pred gfn cpred? unc]]}, :source "(defn\n spec-impl\n \"Do not call this directly, use 'spec'\"\n ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n ([form pred gfn cpred? unc]\n  (cond\n   (spec? pred)\n   (cond-> pred gfn (with-gen gfn))\n   (regex? pred)\n   (regex-spec-impl pred gfn)\n   (ident? pred)\n   (cond-> (the-spec pred) gfn (with-gen gfn))\n   :else\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [ret (pred x)]\n      (if cpred? ret (if ret x :clojure.core/invalid))))\n    (unform*\n     [_ x]\n     (if\n      cpred?\n      (if unc (unc x) (throw (js/Error. \"no unform fn for conformer\")))\n      x))\n    (explain*\n     [_ path via in x]\n     (when\n      (invalid? (dt pred x form cpred?))\n      [{:path path, :pred form, :val x, :via via, :in in}]))\n    (gen* [_ _ _ _] (if gfn (gfn) (gen/gen-for-pred pred)))\n    (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n    (describe* [_] form)))))\n"} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :source "(defn\n invalid?\n \"tests the validity of a conform return value\"\n [ret]\n (keyword-identical? :clojure.core/invalid ret))\n"} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :source "(defn\n amp-impl\n \"Do not call this directly, use '&'\"\n [re preds pred-forms]\n {:clojure.core/op :clojure.core/amp,\n  :p1 re,\n  :ps preds,\n  :forms pred-forms})\n"} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :source "(defn\n cat-impl\n \"Do not call this directly, use 'cat'\"\n [ks ps forms]\n (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n"} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :source "(defn\n explain-str\n \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n [spec x]\n (with-out-str (explain spec x)))\n"} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."}, :source "(defonce *compile-asserts* (s/init-compile-asserts))\n"} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :source "(defn\n with-gen\n \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n [spec gen-fn]\n (let\n  [spec (reg-resolve spec)]\n  (if\n   (regex? spec)\n   (assoc spec :clojure.core/gfn gen-fn)\n   (with-gen* (specize spec) gen-fn))))\n"} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :protocol Spec} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :source "(defn\n check-asserts?\n \"Returns the value set by check-asserts.\"\n []\n *runtime-asserts*)\n"} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :source "(defn\n rep-impl\n \"Do not call this directly, use '*'\"\n [form p]\n (rep* p p [] false form))\n"} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :source "(defn\n describe\n \"returns an abbreviated description of the spec as data\"\n [spec]\n (abbrev (form spec)))\n"} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :source "(defn\n explain-out\n \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\\n    by default explain-printer.\"\n [ed]\n (*explain-out* ed))\n"} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :protocol Specize} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :source "(defn\n maybe-impl\n \"Do not call this directly, use '?'\"\n [p form]\n (assoc\n  (alt* [p (accept :clojure.core/nil)] nil [form :clojure.core/nil])\n  :maybe\n  form))\n"} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :protocol Spec}), cljs.reader ({:sym *default-data-reader-fn*, :meta {}, :source "(def *default-data-reader-fn* (atom nil))\n"} {:sym read, :meta {:doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader]\n  (edn/read\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   reader))\n ([{:keys [eof], :as opts} reader]\n  (edn/read\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   reader))\n ([reader eof-error? eof opts]\n  (edn/read\n   reader\n   eof-error?\n   eof\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m))))))\n"} {:sym *tag-table*, :meta {}, :source "(def\n *tag-table*\n (atom\n  (add-data-readers\n   {'inst read-date, 'uuid read-uuid, 'queue read-queue, 'js read-js})))\n"} {:sym parse-and-validate-timestamp, :meta {:doc nil, :arglists ([s])}, :source "(defn\n parse-and-validate-timestamp\n [s]\n (let\n  [[_\n    years\n    months\n    days\n    hours\n    minutes\n    seconds\n    fraction\n    offset-sign\n    offset-hours\n    offset-minutes\n    :as\n    v]\n   (re-matches timestamp-regex s)]\n  (if-not\n   v\n   (throw (js/Error. (str \"Unrecognized date/time syntax: \" s)))\n   (let\n    [years\n     (parse-int years)\n     months\n     (or (parse-int months) 1)\n     days\n     (or (parse-int days) 1)\n     hours\n     (or (parse-int hours) 0)\n     minutes\n     (or (parse-int minutes) 0)\n     seconds\n     (or (parse-int seconds) 0)\n     fraction\n     (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n     offset-sign\n     (if (= offset-sign \"-\") -1 1)\n     offset-hours\n     (or (parse-int offset-hours) 0)\n     offset-minutes\n     (or (parse-int offset-minutes) 0)\n     offset\n     (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n    [years\n     (check 1 months 12 \"timestamp month field must be in range 1..12\")\n     (check\n      1\n      days\n      (days-in-month months (leap-year? years))\n      \"timestamp day field must be in range 1..last day in month\")\n     (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n     (check\n      0\n      minutes\n      59\n      \"timestamp minute field must be in range 0..59\")\n     (check\n      0\n      seconds\n      (if (= minutes 59) 60 59)\n      \"timestamp second field must be in range 0..60\")\n     (check\n      0\n      fraction\n      999\n      \"timestamp millisecond field must be in range 0..999\")\n     offset]))))\n"} {:sym register-tag-parser!, :meta {:doc nil, :arglists ([tag f])}, :source "(defn\n register-tag-parser!\n [tag f]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* assoc tag f)\n  old-parser))\n"} {:sym register-default-tag-parser!, :meta {:doc nil, :arglists ([f])}, :source "(defn\n register-default-tag-parser!\n [f]\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] f))\n  old-parser))\n"} {:sym deregister-default-tag-parser!, :meta {:doc nil, :arglists ([])}, :source "(defn\n deregister-default-tag-parser!\n []\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] nil))\n  old-parser))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per cljs.tools.reader.edn/read\"\n ([s]\n  (edn/read-string\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   s))\n ([opts s]\n  (edn/read-string\n   (update\n    (merge {:default @*default-data-reader-fn*} opts)\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   s)))\n"} {:sym deregister-tag-parser!, :meta {:doc nil, :arglists ([tag])}, :source "(defn\n deregister-tag-parser!\n [tag]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* dissoc tag)\n  old-parser))\n"} {:sym parse-timestamp, :meta {:doc nil, :arglists ([ts])}, :source "(defn\n parse-timestamp\n [ts]\n (if-let\n  [[years months days hours minutes seconds ms offset]\n   (parse-and-validate-timestamp ts)]\n  (js/Date.\n   (-\n    (.UTC js/Date years (dec months) days hours minutes seconds ms)\n    (* offset 60 1000)))\n  (throw (js/Error. (str \"Unrecognized date/time syntax: \" ts)))))\n"}), clojure.walk ({:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :source "(defn\n walk\n \"Traverses form, an arbitrary data structure.  inner and outer are\\n  functions.  Applies inner to each element of form, building up a\\n  data structure of the same type, then applies outer to the result.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [inner outer form]\n (cond\n  (list? form)\n  (outer (apply list (map inner form)))\n  (seq? form)\n  (outer (doall (map inner form)))\n  (record? form)\n  (outer (reduce (fn [r x] (conj r (inner x))) form form))\n  (coll? form)\n  (outer (into (empty form) (map inner form)))\n  :else\n  (outer form)))\n"} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :source "(defn\n postwalk\n \"Performs a depth-first, post-order traversal of form.  Calls f on\\n  each sub-form, uses f's return value in place of the original.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial postwalk f) f form))\n"} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :source "(defn\n prewalk\n \"Like postwalk, but does pre-order traversal.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial prewalk f) identity (f form)))\n"} {:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :source "(defn\n keywordize-keys\n \"Recursively transforms all map keys from strings to keywords.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :source "(defn\n stringify-keys\n \"Recursively transforms all map keys from keywords to strings.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :source "(defn\n prewalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the root of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :source "(defn\n postwalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the leaves of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"}), cljs.core.async.impl.timers ({:sym MAX_LEVEL, :meta {}, :source "(def MAX_LEVEL 15)\n"} {:sym P, :meta {}, :source "(def P (/ 1 2))\n"} {:sym random-level, :meta {:doc nil, :arglists [[] [level]]}, :source "(defn\n random-level\n ([] (random-level 0))\n ([level]\n  (if\n   (and (< (.random js/Math) P) (< level MAX_LEVEL))\n   (recur (inc level))\n   level)))\n"} {:sym skip-list-node, :meta {:doc nil, :arglists [[level] [k v level]]}, :source "(defn\n skip-list-node\n ([level] (skip-list-node nil nil level))\n ([k v level]\n  (let\n   [arr (make-array (inc level))]\n   (loop\n    [i 0]\n    (when (< i (alength arr)) (aset arr i nil) (recur (inc i))))\n   (SkipListNode. k v arr))))\n"} {:sym least-greater-node, :meta {:doc nil, :arglists [[x k level] [x k level update]]}, :source "(defn\n least-greater-node\n ([x k level] (least-greater-node x k level nil))\n ([x k level update]\n  (if-not\n   (neg? level)\n   (let\n    [x\n     (loop\n      [x x]\n      (if-let\n       [x' (aget (.-forward x) level)]\n       (if (< (.-key x') k) (recur x') x)\n       x))]\n    (when-not (nil? update) (aset update level x))\n    (recur x k (dec level) update))\n   x)))\n"} {:sym skip-list, :meta {:doc nil, :arglists ([])}, :source "(defn skip-list [] (SkipList. (skip-list-node 0) 0))\n"} {:sym timeouts-map, :meta {}, :source "(def timeouts-map (skip-list))\n"} {:sym TIMEOUT_RESOLUTION_MS, :meta {}, :source "(def TIMEOUT_RESOLUTION_MS 10)\n"} {:sym timeout, :meta {:doc "returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"returns a channel that will close after msecs\"\n [msecs]\n (let\n  [timeout\n   (+ (.valueOf (js/Date.)) msecs)\n   me\n   (.ceilingEntry timeouts-map timeout)]\n  (or\n   (when\n    (and me (< (.-key me) (+ timeout TIMEOUT_RESOLUTION_MS)))\n    (.-val me))\n   (let\n    [timeout-channel (channels/chan nil)]\n    (.put timeouts-map timeout timeout-channel)\n    (dispatch/queue-delay\n     (fn\n      []\n      (.remove timeouts-map timeout)\n      (impl/close! timeout-channel))\n     msecs)\n    timeout-channel))))\n"}), reagent.dom ({:sym render, :meta {:doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element. The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance.", :arglists [[comp container] [comp container callback]]}, :source "(defn\n render\n \"Render a Reagent component into the DOM. The first argument may be\\n  either a vector (using Reagent's Hiccup syntax), or a React element. The second argument should be a DOM node.\\n\\n  Optionally takes a callback that is called when the component is in place.\\n\\n  Returns the mounted component instance.\"\n ([comp container] (render comp container nil))\n ([comp container callback]\n  (ratom/flush!)\n  (let\n   [f (fn [] (tmpl/as-element (if (fn? comp) (comp) comp)))]\n   (render-comp f container callback))))\n"} {:sym unmount-component-at-node, :meta {:doc nil, :arglists ([container])}, :source "(defn unmount-component-at-node [container] (unmount-comp container))\n"} {:sym dom-node, :meta {:doc "Returns the root DOM node of a mounted component.", :arglists ([this])}, :source "(defn\n dom-node\n \"Returns the root DOM node of a mounted component.\"\n [this]\n (react-dom/findDOMNode this))\n"} {:sym force-update-all, :meta {:doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead.", :arglists ([])}, :source "(defn\n force-update-all\n \"Force re-rendering of all mounted Reagent components. This is\\n  probably only useful in a development environment, when you want to\\n  update components in response to some dynamic changes to code.\\n\\n  Note that force-update-all may not update root components. This\\n  happens if a component 'foo' is mounted with `(render [foo])` (since\\n  functions are passed by value, and not by reference, in\\n  ClojureScript). To get around this you'll have to introduce a layer\\n  of indirection, for example by using `(render [#'foo])` instead.\"\n []\n (ratom/flush!)\n (doseq [v (vals @roots)] (apply re-render-component v))\n \"Updated\")\n"}), cljs.spec.gen.alpha ({:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :source "(defn quick-check [& args] (apply @quick-check-ref args))\n"} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :source "(defn\n for-all*\n \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n [& args]\n (apply @for-all*-ref args))\n"} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :source "(defn\n delay-impl\n [gfnd]\n (generator (fn [rnd size] ((:gen @gfnd) rnd size))))\n"} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :source "(defn\n cat\n \"Returns a generator of a sequence catenated from results of\\ngens, each of which should generate something sequential.\"\n [& gens]\n (fmap (fn* [p1__18546#] (apply concat p1__18546#)) (apply tuple gens)))\n"} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :source "(defn\n gen-for-pred\n \"Given a predicate, returns a built-in generator if one exists.\"\n [pred]\n (if (set? pred) (elements pred) (get @gen-builtins pred)))\n"})}, :rel-path "../../", :static? true, :check-for-updates? false, :ns-sym clojure.core, :vars [{:sym keys, :meta {:arglists ([map]), :doc "Returns a sequence of the map's keys, in the same order as (seq map)."}, :source "(defn keys\n  \"Returns a sequence of the map's keys, in the same order as (seq map).\"\n  {:added \"1.0\"\n   :static true}\n  [map] (. clojure.lang.RT (keys map)))", :spec nil, :examples []}]}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
