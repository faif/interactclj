<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../style.css">
        <link rel="stylesheet" type="text/css" href="../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-1461750551"><div data-reactid="2"><div class="nses" data-reactid="3"><div data-reactid="4"><div class="tag" data-reactid="5">CLJS</div><a href="../cljs/basic-lein-cljs.core.html" data-reactid="6">basic-lein-cljs.core</a></div><div data-reactid="7"><a href="../clj/cljs.analyzer.html" data-reactid="8">cljs.analyzer</a></div><div data-reactid="9"><a href="../clj/cljs.compiler.html" data-reactid="10">cljs.compiler</a></div><div data-reactid="11"><div class="tag" data-reactid="12">CLJS</div><a href="../cljs/cljs.core.html" data-reactid="13">cljs.core</a></div><div data-reactid="14"><div class="tag" data-reactid="15">CLJS</div><a href="../cljs/cljs.core.async.html" data-reactid="16">cljs.core.async</a></div><div data-reactid="17"><div class="tag" data-reactid="18">CLJS</div><a href="../cljs/cljs.core.async.impl.buffers.html" data-reactid="19">cljs.core.async.impl.buffers</a></div><div data-reactid="20"><div class="tag" data-reactid="21">CLJS</div><a href="../cljs/cljs.core.async.impl.channels.html" data-reactid="22">cljs.core.async.impl.channels</a></div><div data-reactid="23"><div class="tag" data-reactid="24">CLJS</div><a href="../cljs/cljs.core.async.impl.dispatch.html" data-reactid="25">cljs.core.async.impl.dispatch</a></div><div data-reactid="26"><div class="tag" data-reactid="27">CLJS</div><a href="../cljs/cljs.core.async.impl.ioc-helpers.html" data-reactid="28">cljs.core.async.impl.ioc-helpers</a></div><div data-reactid="29"><div class="tag" data-reactid="30">CLJS</div><a href="../cljs/cljs.core.async.impl.protocols.html" data-reactid="31">cljs.core.async.impl.protocols</a></div><div data-reactid="32"><div class="tag" data-reactid="33">CLJS</div><a href="../cljs/cljs.core.async.impl.timers.html" data-reactid="34">cljs.core.async.impl.timers</a></div><div data-reactid="35"><a href="../clj/cljs.env.html" data-reactid="36">cljs.env</a></div><div data-reactid="37"><a href="../clj/cljs.externs.html" data-reactid="38">cljs.externs</a></div><div data-reactid="39"><div class="tag" data-reactid="40">CLJS</div><a href="../cljs/cljs.js.html" data-reactid="41">cljs.js</a></div><div data-reactid="42"><a href="../clj/cljs.js-deps.html" data-reactid="43">cljs.js-deps</a></div><div data-reactid="44"><div class="tag" data-reactid="45">CLJS</div><a href="../cljs/cljs.reader.html" data-reactid="46">cljs.reader</a></div><div data-reactid="47"><a href="../clj/cljs.source-map.html" data-reactid="48">cljs.source-map</a></div><div data-reactid="49"><div class="tag" data-reactid="50">CLJS</div><a href="../cljs/cljs.source-map.html" data-reactid="51">cljs.source-map</a></div><div data-reactid="52"><a href="../clj/cljs.source-map.base64.html" data-reactid="53">cljs.source-map.base64</a></div><div data-reactid="54"><div class="tag" data-reactid="55">CLJS</div><a href="../cljs/cljs.source-map.base64.html" data-reactid="56">cljs.source-map.base64</a></div><div data-reactid="57"><a href="../clj/cljs.source-map.base64-vlq.html" data-reactid="58">cljs.source-map.base64-vlq</a></div><div data-reactid="59"><div class="tag" data-reactid="60">CLJS</div><a href="../cljs/cljs.source-map.base64-vlq.html" data-reactid="61">cljs.source-map.base64-vlq</a></div><div data-reactid="62"><div class="tag" data-reactid="63">CLJS</div><a href="../cljs/cljs.spec.alpha.html" data-reactid="64">cljs.spec.alpha</a></div><div data-reactid="65"><div class="tag" data-reactid="66">CLJS</div><a href="../cljs/cljs.spec.gen.alpha.html" data-reactid="67">cljs.spec.gen.alpha</a></div><div data-reactid="68"><a href="../clj/cljs.tagged-literals.html" data-reactid="69">cljs.tagged-literals</a></div><div data-reactid="70"><div class="tag" data-reactid="71">CLJS</div><a href="../cljs/cljs.tools.reader.html" data-reactid="72">cljs.tools.reader</a></div><div data-reactid="73"><div class="tag" data-reactid="74">CLJS</div><a href="../cljs/cljs.tools.reader.edn.html" data-reactid="75">cljs.tools.reader.edn</a></div><div data-reactid="76"><div class="tag" data-reactid="77">CLJS</div><a href="../cljs/cljs.tools.reader.impl.commons.html" data-reactid="78">cljs.tools.reader.impl.commons</a></div><div data-reactid="79"><div class="tag" data-reactid="80">CLJS</div><a href="../cljs/cljs.tools.reader.impl.errors.html" data-reactid="81">cljs.tools.reader.impl.errors</a></div><div data-reactid="82"><div class="tag" data-reactid="83">CLJS</div><a href="../cljs/cljs.tools.reader.impl.inspect.html" data-reactid="84">cljs.tools.reader.impl.inspect</a></div><div data-reactid="85"><div class="tag" data-reactid="86">CLJS</div><a href="../cljs/cljs.tools.reader.impl.utils.html" data-reactid="87">cljs.tools.reader.impl.utils</a></div><div data-reactid="88"><div class="tag" data-reactid="89">CLJS</div><a href="../cljs/cljs.tools.reader.reader-types.html" data-reactid="90">cljs.tools.reader.reader-types</a></div><div data-reactid="91"><a href="../clj/cljs.util.html" data-reactid="92">cljs.util</a></div><div data-reactid="93"><a href="../clj/clojure.core.html" data-reactid="94">clojure.core</a></div><div data-reactid="95"><a href="../clj/clojure.core.async.html" data-reactid="96">clojure.core.async</a></div><div data-reactid="97"><a href="../clj/clojure.core.async.impl.buffers.html" data-reactid="98">clojure.core.async.impl.buffers</a></div><div data-reactid="99"><a href="../clj/clojure.core.async.impl.channels.html" data-reactid="100">clojure.core.async.impl.channels</a></div><div data-reactid="101"><a href="../clj/clojure.core.async.impl.concurrent.html" data-reactid="102">clojure.core.async.impl.concurrent</a></div><div data-reactid="103"><a href="../clj/clojure.core.async.impl.dispatch.html" data-reactid="104">clojure.core.async.impl.dispatch</a></div><div data-reactid="105"><a href="../clj/clojure.core.async.impl.exec.threadpool.html" data-reactid="106">clojure.core.async.impl.exec.threadpool</a></div><div data-reactid="107"><a href="../clj/clojure.core.async.impl.ioc-macros.html" data-reactid="108">clojure.core.async.impl.ioc-macros</a></div><div data-reactid="109"><a href="../clj/clojure.core.async.impl.mutex.html" data-reactid="110">clojure.core.async.impl.mutex</a></div><div data-reactid="111"><a href="../clj/clojure.core.async.impl.protocols.html" data-reactid="112">clojure.core.async.impl.protocols</a></div><div data-reactid="113"><a href="../clj/clojure.core.async.impl.timers.html" data-reactid="114">clojure.core.async.impl.timers</a></div><div data-reactid="115"><a href="../clj/clojure.core.cache.html" data-reactid="116">clojure.core.cache</a></div><div data-reactid="117"><a href="../clj/clojure.core.memoize.html" data-reactid="118">clojure.core.memoize</a></div><div data-reactid="119"><a href="../clj/clojure.core.protocols.html" data-reactid="120">clojure.core.protocols</a></div><div data-reactid="121"><a href="../clj/clojure.core.server.html" data-reactid="122">clojure.core.server</a></div><div data-reactid="123"><a href="../clj/clojure.data.json.html" data-reactid="124">clojure.data.json</a></div><div data-reactid="125"><a href="../clj/clojure.data.priority-map.html" data-reactid="126">clojure.data.priority-map</a></div><div data-reactid="127"><a href="../clj/clojure.edn.html" data-reactid="128">clojure.edn</a></div><div data-reactid="129"><a href="../clj/clojure.instant.html" data-reactid="130">clojure.instant</a></div><div data-reactid="131"><a href="../clj/clojure.java.io.html" data-reactid="132">clojure.java.io</a></div><div data-reactid="133"><a href="../clj/clojure.main.html" data-reactid="134">clojure.main</a></div><div data-reactid="135"><a href="../clj/clojure.pprint.html" data-reactid="136">clojure.pprint</a></div><div data-reactid="137"><a href="../clj/clojure.reflect.html" data-reactid="138">clojure.reflect</a></div><div data-reactid="139"><a href="../clj/clojure.repl.html" data-reactid="140">clojure.repl</a></div><div data-reactid="141"><a href="../clj/clojure.set.html" data-reactid="142">clojure.set</a></div><div data-reactid="143"><div class="tag" data-reactid="144">CLJS</div><a href="../cljs/clojure.set.html" data-reactid="145">clojure.set</a></div><div data-reactid="146"><a href="../clj/clojure.spec.alpha.html" data-reactid="147">clojure.spec.alpha</a></div><div data-reactid="148"><a href="../clj/clojure.spec.gen.alpha.html" data-reactid="149">clojure.spec.gen.alpha</a></div><div data-reactid="150"><a href="../clj/clojure.string.html" data-reactid="151">clojure.string</a></div><div data-reactid="152"><div class="tag" data-reactid="153">CLJS</div><a href="../cljs/clojure.string.html" data-reactid="154">clojure.string</a></div><div data-reactid="155"><a href="../clj/clojure.tools.analyzer.html" data-reactid="156">clojure.tools.analyzer</a></div><div data-reactid="157"><a href="../clj/clojure.tools.analyzer.ast.html" data-reactid="158">clojure.tools.analyzer.ast</a></div><div data-reactid="159"><a href="../clj/clojure.tools.analyzer.env.html" data-reactid="160">clojure.tools.analyzer.env</a></div><div data-reactid="161"><a href="../clj/clojure.tools.analyzer.jvm.html" data-reactid="162">clojure.tools.analyzer.jvm</a></div><div data-reactid="163"><a href="../clj/clojure.tools.analyzer.jvm.utils.html" data-reactid="164">clojure.tools.analyzer.jvm.utils</a></div><div data-reactid="165"><a href="../clj/clojure.tools.analyzer.passes.html" data-reactid="166">clojure.tools.analyzer.passes</a></div><div data-reactid="167"><a href="../clj/clojure.tools.analyzer.passes.add-binding-atom.html" data-reactid="168">clojure.tools.analyzer.passes.add-binding-atom</a></div><div data-reactid="169"><a href="../clj/clojure.tools.analyzer.passes.cleanup.html" data-reactid="170">clojure.tools.analyzer.passes.cleanup</a></div><div data-reactid="171"><a href="../clj/clojure.tools.analyzer.passes.constant-lifter.html" data-reactid="172">clojure.tools.analyzer.passes.constant-lifter</a></div><div data-reactid="173"><a href="../clj/clojure.tools.analyzer.passes.elide-meta.html" data-reactid="174">clojure.tools.analyzer.passes.elide-meta</a></div><div data-reactid="175"><a href="../clj/clojure.tools.analyzer.passes.emit-form.html" data-reactid="176">clojure.tools.analyzer.passes.emit-form</a></div><div data-reactid="177"><a href="../clj/clojure.tools.analyzer.passes.jvm.analyze-host-expr.html" data-reactid="178">clojure.tools.analyzer.passes.jvm.analyze-host-expr</a></div><div data-reactid="179"><a href="../clj/clojure.tools.analyzer.passes.jvm.annotate-host-info.html" data-reactid="180">clojure.tools.analyzer.passes.jvm.annotate-host-info</a></div><div data-reactid="181"><a href="../clj/clojure.tools.analyzer.passes.jvm.annotate-loops.html" data-reactid="182">clojure.tools.analyzer.passes.jvm.annotate-loops</a></div><div data-reactid="183"><a href="../clj/clojure.tools.analyzer.passes.jvm.annotate-tag.html" data-reactid="184">clojure.tools.analyzer.passes.jvm.annotate-tag</a></div><div data-reactid="185"><a href="../clj/clojure.tools.analyzer.passes.jvm.box.html" data-reactid="186">clojure.tools.analyzer.passes.jvm.box</a></div><div data-reactid="187"><a href="../clj/clojure.tools.analyzer.passes.jvm.classify-invoke.html" data-reactid="188">clojure.tools.analyzer.passes.jvm.classify-invoke</a></div><div data-reactid="189"><a href="../clj/clojure.tools.analyzer.passes.jvm.constant-lifter.html" data-reactid="190">clojure.tools.analyzer.passes.jvm.constant-lifter</a></div><div data-reactid="191"><a href="../clj/clojure.tools.analyzer.passes.jvm.emit-form.html" data-reactid="192">clojure.tools.analyzer.passes.jvm.emit-form</a></div><div data-reactid="193"><a href="../clj/clojure.tools.analyzer.passes.jvm.fix-case-test.html" data-reactid="194">clojure.tools.analyzer.passes.jvm.fix-case-test</a></div><div data-reactid="195"><a href="../clj/clojure.tools.analyzer.passes.jvm.infer-tag.html" data-reactid="196">clojure.tools.analyzer.passes.jvm.infer-tag</a></div><div data-reactid="197"><a href="../clj/clojure.tools.analyzer.passes.jvm.validate.html" data-reactid="198">clojure.tools.analyzer.passes.jvm.validate</a></div><div data-reactid="199"><a href="../clj/clojure.tools.analyzer.passes.jvm.validate-loop-locals.html" data-reactid="200">clojure.tools.analyzer.passes.jvm.validate-loop-locals</a></div><div data-reactid="201"><a href="../clj/clojure.tools.analyzer.passes.jvm.validate-recur.html" data-reactid="202">clojure.tools.analyzer.passes.jvm.validate-recur</a></div><div data-reactid="203"><a href="../clj/clojure.tools.analyzer.passes.jvm.warn-on-reflection.html" data-reactid="204">clojure.tools.analyzer.passes.jvm.warn-on-reflection</a></div><div data-reactid="205"><a href="../clj/clojure.tools.analyzer.passes.source-info.html" data-reactid="206">clojure.tools.analyzer.passes.source-info</a></div><div data-reactid="207"><a href="../clj/clojure.tools.analyzer.passes.trim.html" data-reactid="208">clojure.tools.analyzer.passes.trim</a></div><div data-reactid="209"><a href="../clj/clojure.tools.analyzer.passes.uniquify.html" data-reactid="210">clojure.tools.analyzer.passes.uniquify</a></div><div data-reactid="211"><a href="../clj/clojure.tools.analyzer.passes.warn-earmuff.html" data-reactid="212">clojure.tools.analyzer.passes.warn-earmuff</a></div><div data-reactid="213"><a href="../clj/clojure.tools.analyzer.utils.html" data-reactid="214">clojure.tools.analyzer.utils</a></div><div data-reactid="215"><a href="../clj/clojure.tools.cli.html" data-reactid="216">clojure.tools.cli</a></div><div data-reactid="217"><a href="../clj/clojure.tools.namespace.dependency.html" data-reactid="218">clojure.tools.namespace.dependency</a></div><div data-reactid="219"><a href="../clj/clojure.tools.namespace.file.html" data-reactid="220">clojure.tools.namespace.file</a></div><div data-reactid="221"><a href="../clj/clojure.tools.namespace.find.html" data-reactid="222">clojure.tools.namespace.find</a></div><div data-reactid="223"><a href="../clj/clojure.tools.namespace.parse.html" data-reactid="224">clojure.tools.namespace.parse</a></div><div data-reactid="225"><a href="../clj/clojure.tools.namespace.track.html" data-reactid="226">clojure.tools.namespace.track</a></div><div data-reactid="227"><a href="../clj/clojure.tools.reader.html" data-reactid="228">clojure.tools.reader</a></div><div data-reactid="229"><a href="../clj/clojure.tools.reader.default-data-readers.html" data-reactid="230">clojure.tools.reader.default-data-readers</a></div><div data-reactid="231"><a href="../clj/clojure.tools.reader.impl.commons.html" data-reactid="232">clojure.tools.reader.impl.commons</a></div><div data-reactid="233"><a href="../clj/clojure.tools.reader.impl.errors.html" data-reactid="234">clojure.tools.reader.impl.errors</a></div><div data-reactid="235"><a href="../clj/clojure.tools.reader.impl.inspect.html" data-reactid="236">clojure.tools.reader.impl.inspect</a></div><div data-reactid="237"><a href="../clj/clojure.tools.reader.impl.utils.html" data-reactid="238">clojure.tools.reader.impl.utils</a></div><div data-reactid="239"><a href="../clj/clojure.tools.reader.reader-types.html" data-reactid="240">clojure.tools.reader.reader-types</a></div><div data-reactid="241"><a href="../clj/clojure.walk.html" data-reactid="242">clojure.walk</a></div><div data-reactid="243"><div class="tag" data-reactid="244">CLJS</div><a href="../cljs/clojure.walk.html" data-reactid="245">clojure.walk</a></div><div data-reactid="246"><a href="../clj/dynadoc.aliases.html" data-reactid="247">dynadoc.aliases</a></div><div data-reactid="248"><a href="../clj/dynadoc.common.html" data-reactid="249">dynadoc.common</a></div><div data-reactid="250"><a href="../clj/dynadoc.core.html" data-reactid="251">dynadoc.core</a></div><div data-reactid="252"><div class="tag" data-reactid="253">CLJS</div><a href="../cljs/dynadoc.core.html" data-reactid="254">dynadoc.core</a></div><div data-reactid="255"><a href="../clj/dynadoc.example.html" data-reactid="256">dynadoc.example</a></div><div data-reactid="257"><div class="tag" data-reactid="258">CLJS</div><a href="../cljs/dynadoc.state.html" data-reactid="259">dynadoc.state</a></div><div data-reactid="260"><a href="../clj/dynadoc.static.html" data-reactid="261">dynadoc.static</a></div><div data-reactid="262"><a href="../clj/dynadoc.utils.html" data-reactid="263">dynadoc.utils</a></div><div data-reactid="264"><a href="../clj/dynadoc.watch.html" data-reactid="265">dynadoc.watch</a></div><div data-reactid="266"><a href="../clj/eval-soup.clojail.html" data-reactid="267">eval-soup.clojail</a></div><div data-reactid="268"><a href="../clj/eval-soup.core.html" data-reactid="269">eval-soup.core</a></div><div data-reactid="270"><div class="tag" data-reactid="271">CLJS</div><a href="../cljs/eval-soup.core.html" data-reactid="272">eval-soup.core</a></div><div data-reactid="273"><a href="../clj/hawk.core.html" data-reactid="274">hawk.core</a></div><div data-reactid="275"><a href="../clj/hawk.watcher.html" data-reactid="276">hawk.watcher</a></div><div data-reactid="277"><a href="../clj/html-soup.core.html" data-reactid="278">html-soup.core</a></div><div data-reactid="279"><a href="../clj/ns-tracker.core.html" data-reactid="280">ns-tracker.core</a></div><div data-reactid="281"><a href="../clj/ns-tracker.dependency.html" data-reactid="282">ns-tracker.dependency</a></div><div data-reactid="283"><a href="../clj/ns-tracker.nsdeps.html" data-reactid="284">ns-tracker.nsdeps</a></div><div data-reactid="285"><a href="../clj/ns-tracker.parse.html" data-reactid="286">ns-tracker.parse</a></div><div data-reactid="287"><div class="tag" data-reactid="288">CLJS</div><a href="../cljs/oakcljs.tools.reader.html" data-reactid="289">oakcljs.tools.reader</a></div><div data-reactid="290"><div class="tag" data-reactid="291">CLJS</div><a href="../cljs/oakcljs.tools.reader.impl.commons.html" data-reactid="292">oakcljs.tools.reader.impl.commons</a></div><div data-reactid="293"><div class="tag" data-reactid="294">CLJS</div><a href="../cljs/oakcljs.tools.reader.impl.errors.html" data-reactid="295">oakcljs.tools.reader.impl.errors</a></div><div data-reactid="296"><div class="tag" data-reactid="297">CLJS</div><a href="../cljs/oakcljs.tools.reader.impl.inspect.html" data-reactid="298">oakcljs.tools.reader.impl.inspect</a></div><div data-reactid="299"><div class="tag" data-reactid="300">CLJS</div><a href="../cljs/oakcljs.tools.reader.impl.utils.html" data-reactid="301">oakcljs.tools.reader.impl.utils</a></div><div data-reactid="302"><div class="tag" data-reactid="303">CLJS</div><a href="../cljs/oakcljs.tools.reader.reader-types.html" data-reactid="304">oakcljs.tools.reader.reader-types</a></div><div data-reactid="305"><a href="../clj/oakclojure.tools.reader.html" data-reactid="306">oakclojure.tools.reader</a></div><div data-reactid="307"><a href="../clj/oakclojure.tools.reader.default-data-readers.html" data-reactid="308">oakclojure.tools.reader.default-data-readers</a></div><div data-reactid="309"><a href="../clj/oakclojure.tools.reader.impl.commons.html" data-reactid="310">oakclojure.tools.reader.impl.commons</a></div><div data-reactid="311"><a href="../clj/oakclojure.tools.reader.impl.errors.html" data-reactid="312">oakclojure.tools.reader.impl.errors</a></div><div data-reactid="313"><a href="../clj/oakclojure.tools.reader.impl.inspect.html" data-reactid="314">oakclojure.tools.reader.impl.inspect</a></div><div data-reactid="315"><a href="../clj/oakclojure.tools.reader.impl.utils.html" data-reactid="316">oakclojure.tools.reader.impl.utils</a></div><div data-reactid="317"><a href="../clj/oakclojure.tools.reader.reader-types.html" data-reactid="318">oakclojure.tools.reader.reader-types</a></div><div data-reactid="319"><a href="../clj/org.httpkit.server.html" data-reactid="320">org.httpkit.server</a></div><div data-reactid="321"><div class="tag" data-reactid="322">CLJS</div><a href="../cljs/paren-soup.console.html" data-reactid="323">paren-soup.console</a></div><div data-reactid="324"><div class="tag" data-reactid="325">CLJS</div><a href="../cljs/paren-soup.core.html" data-reactid="326">paren-soup.core</a></div><div data-reactid="327"><div class="tag" data-reactid="328">CLJS</div><a href="../cljs/paren-soup.dom.html" data-reactid="329">paren-soup.dom</a></div><div data-reactid="330"><div class="tag" data-reactid="331">CLJS</div><a href="../cljs/paren-soup.instarepl.html" data-reactid="332">paren-soup.instarepl</a></div><div data-reactid="333"><div class="tag" data-reactid="334">CLJS</div><a href="../cljs/reagent.core.html" data-reactid="335">reagent.core</a></div><div data-reactid="336"><div class="tag" data-reactid="337">CLJS</div><a href="../cljs/reagent.debug.html" data-reactid="338">reagent.debug</a></div><div data-reactid="339"><div class="tag" data-reactid="340">CLJS</div><a href="../cljs/reagent.dom.html" data-reactid="341">reagent.dom</a></div><div data-reactid="342"><div class="tag" data-reactid="343">CLJS</div><a href="../cljs/reagent.impl.batching.html" data-reactid="344">reagent.impl.batching</a></div><div data-reactid="345"><div class="tag" data-reactid="346">CLJS</div><a href="../cljs/reagent.impl.component.html" data-reactid="347">reagent.impl.component</a></div><div data-reactid="348"><div class="tag" data-reactid="349">CLJS</div><a href="../cljs/reagent.impl.template.html" data-reactid="350">reagent.impl.template</a></div><div data-reactid="351"><div class="tag" data-reactid="352">CLJS</div><a href="../cljs/reagent.impl.util.html" data-reactid="353">reagent.impl.util</a></div><div data-reactid="354"><div class="tag" data-reactid="355">CLJS</div><a href="../cljs/reagent.ratom.html" data-reactid="356">reagent.ratom</a></div><div data-reactid="357"><a href="../clj/ring.middleware.content-type.html" data-reactid="358">ring.middleware.content-type</a></div><div data-reactid="359"><a href="../clj/ring.middleware.file.html" data-reactid="360">ring.middleware.file</a></div><div data-reactid="361"><a href="../clj/ring.middleware.head.html" data-reactid="362">ring.middleware.head</a></div><div data-reactid="363"><a href="../clj/ring.middleware.keyword-params.html" data-reactid="364">ring.middleware.keyword-params</a></div><div data-reactid="365"><a href="../clj/ring.middleware.params.html" data-reactid="366">ring.middleware.params</a></div><div data-reactid="367"><a href="../clj/ring.middleware.reload.html" data-reactid="368">ring.middleware.reload</a></div><div data-reactid="369"><a href="../clj/ring.middleware.resource.html" data-reactid="370">ring.middleware.resource</a></div><div data-reactid="371"><a href="../clj/ring.util.codec.html" data-reactid="372">ring.util.codec</a></div><div data-reactid="373"><a href="../clj/ring.util.io.html" data-reactid="374">ring.util.io</a></div><div data-reactid="375"><a href="../clj/ring.util.mime-type.html" data-reactid="376">ring.util.mime-type</a></div><div data-reactid="377"><a href="../clj/ring.util.parsing.html" data-reactid="378">ring.util.parsing</a></div><div data-reactid="379"><a href="../clj/ring.util.request.html" data-reactid="380">ring.util.request</a></div><div data-reactid="381"><a href="../clj/ring.util.response.html" data-reactid="382">ring.util.response</a></div><div data-reactid="383"><a href="../clj/ring.util.time.html" data-reactid="384">ring.util.time</a></div><div data-reactid="385"><a href="../clj/rum.core.html" data-reactid="386">rum.core</a></div><div data-reactid="387"><div class="tag" data-reactid="388">CLJS</div><a href="../cljs/rum.core.html" data-reactid="389">rum.core</a></div><div data-reactid="390"><a href="../clj/rum.cursor.html" data-reactid="391">rum.cursor</a></div><div data-reactid="392"><a href="../clj/rum.derived-atom.html" data-reactid="393">rum.derived-atom</a></div><div data-reactid="394"><a href="../clj/rum.server-render.html" data-reactid="395">rum.server-render</a></div><div data-reactid="396"><a href="../clj/rum.util.html" data-reactid="397">rum.util</a></div><div data-reactid="398"><a href="../clj/sablono.compiler.html" data-reactid="399">sablono.compiler</a></div><div data-reactid="400"><div class="tag" data-reactid="401">CLJS</div><a href="../cljs/sablono.core.html" data-reactid="402">sablono.core</a></div><div data-reactid="403"><a href="../clj/sablono.normalize.html" data-reactid="404">sablono.normalize</a></div><div data-reactid="405"><a href="../clj/sablono.util.html" data-reactid="406">sablono.util</a></div><div data-reactid="407"><a href="../clj/tag-soup.core.html" data-reactid="408">tag-soup.core</a></div></div></div><div style="left:300px;" class="vars" data-reactid="409"><!-- react-empty: 410 --><div data-reactid="411"><center data-reactid="412"><h1 data-reactid="413">clojure.core</h1></center><div class="section doc" data-reactid="414">Fundamental library of the Clojure language</div></div><div class="var-info" data-reactid="415"><a href="../clj/clojure.core/&#x27;a&#x27;.html" data-reactid="416"><h2 data-reactid="417">(*)</h2><h2 data-reactid="418">(* x)</h2><h2 data-reactid="419">(* x y)</h2><h2 data-reactid="420">(* x y &amp; more)</h2></a><div class="section doc" data-reactid="421">Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *&#x27;</div><div class="section" data-reactid="422"><a href="../clj/clojure.core/&#x27;a&#x27;.html" data-reactid="423"><h3 data-reactid="424">+ Source</h3></a></div></div><div class="var-info" data-reactid="425"><a href="../clj/clojure.core/&#x27;a&#x27;&#x27;.html" data-reactid="426"><h2 data-reactid="427">(*&#x27;)</h2><h2 data-reactid="428">(*&#x27; x)</h2><h2 data-reactid="429">(*&#x27; x y)</h2><h2 data-reactid="430">(*&#x27; x y &amp; more)</h2></a><div class="section doc" data-reactid="431">Returns the product of nums. (*&#x27;) returns 1. Supports arbitrary precision.
  See also: *</div><div class="section" data-reactid="432"><a href="../clj/clojure.core/&#x27;a&#x27;&#x27;.html" data-reactid="433"><h3 data-reactid="434">+ Source</h3></a></div></div><div class="var-info" data-reactid="435"><a href="../clj/clojure.core/&#x27;a&#x27;1.html" data-reactid="436"><h2 data-reactid="437">*1</h2></a><div class="section doc" data-reactid="438">bound in a repl thread to the most recent value printed</div><div class="section" data-reactid="439"><a href="../clj/clojure.core/&#x27;a&#x27;1.html" data-reactid="440"><h3 data-reactid="441">+ Source</h3></a></div></div><div class="var-info" data-reactid="442"><a href="../clj/clojure.core/&#x27;a&#x27;2.html" data-reactid="443"><h2 data-reactid="444">*2</h2></a><div class="section doc" data-reactid="445">bound in a repl thread to the second most recent value printed</div><div class="section" data-reactid="446"><a href="../clj/clojure.core/&#x27;a&#x27;2.html" data-reactid="447"><h3 data-reactid="448">+ Source</h3></a></div></div><div class="var-info" data-reactid="449"><a href="../clj/clojure.core/&#x27;a&#x27;3.html" data-reactid="450"><h2 data-reactid="451">*3</h2></a><div class="section doc" data-reactid="452">bound in a repl thread to the third most recent value printed</div><div class="section" data-reactid="453"><a href="../clj/clojure.core/&#x27;a&#x27;3.html" data-reactid="454"><h3 data-reactid="455">+ Source</h3></a></div></div><div class="var-info" data-reactid="456"><a href="../clj/clojure.core/&#x27;a&#x27;agent&#x27;a&#x27;.html" data-reactid="457"><h2 data-reactid="458">*agent*</h2></a><div class="section doc" data-reactid="459">The agent currently running an action on this thread, else nil</div></div><div class="var-info" data-reactid="460"><a href="../clj/clojure.core/&#x27;a&#x27;allow-unresolved-vars&#x27;a&#x27;.html" data-reactid="461"><h2 data-reactid="462">*allow-unresolved-vars*</h2></a></div><div class="var-info" data-reactid="463"><a href="../clj/clojure.core/&#x27;a&#x27;assert&#x27;a&#x27;.html" data-reactid="464"><h2 data-reactid="465">*assert*</h2></a></div><div class="var-info" data-reactid="466"><a href="../clj/clojure.core/&#x27;a&#x27;clojure-version&#x27;a&#x27;.html" data-reactid="467"><h2 data-reactid="468">*clojure-version*</h2></a><div class="section doc" data-reactid="469">The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;</div><div class="section" data-reactid="470"><a href="../clj/clojure.core/&#x27;a&#x27;clojure-version&#x27;a&#x27;.html" data-reactid="471"><h3 data-reactid="472">+ Source</h3></a></div></div><div class="var-info" data-reactid="473"><a href="../clj/clojure.core/&#x27;a&#x27;command-line-args&#x27;a&#x27;.html" data-reactid="474"><h2 data-reactid="475">*command-line-args*</h2></a><div class="section doc" data-reactid="476">A sequence of the supplied command line arguments, or nil if
  none were supplied</div></div><div class="var-info" data-reactid="477"><a href="../clj/clojure.core/&#x27;a&#x27;compile-files&#x27;a&#x27;.html" data-reactid="478"><h2 data-reactid="479">*compile-files*</h2></a><div class="section doc" data-reactid="480">Set to true when compiling files, false otherwise.</div></div><div class="var-info" data-reactid="481"><a href="../clj/clojure.core/&#x27;a&#x27;compile-path&#x27;a&#x27;.html" data-reactid="482"><h2 data-reactid="483">*compile-path*</h2></a><div class="section doc" data-reactid="484">Specifies the directory where &#x27;compile&#x27; will write out .class
  files. This directory must be in the classpath for &#x27;compile&#x27; to
  work.

  Defaults to &quot;classes&quot;</div></div><div class="var-info" data-reactid="485"><a href="../clj/clojure.core/&#x27;a&#x27;compiler-options&#x27;a&#x27;.html" data-reactid="486"><h2 data-reactid="487">*compiler-options*</h2></a><div class="section doc" data-reactid="488">A map of keys to options.
  Note, when binding dynamically make sure to merge with previous value.
  Supported options:
  :elide-meta - a collection of metadata keys to elide during compilation.
  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger
  Alpha, subject to change.</div></div><div class="var-info" data-reactid="489"><a href="../clj/clojure.core/&#x27;a&#x27;data-readers&#x27;a&#x27;.html" data-reactid="490"><h2 data-reactid="491">*data-readers*</h2></a><div class="section doc" data-reactid="492">Map from reader tag symbols to data reader Vars.

  When Clojure starts, it searches for files named &#x27;data_readers.clj&#x27;
  and &#x27;data_readers.cljc&#x27; at the root of the classpath. Each such file
  must contain a literal map of symbols, like this:

      {foo/bar my.project.foo/bar
       foo/baz my.project/baz}

  The first symbol in each pair is a tag that will be recognized by
  the Clojure reader. The second symbol in the pair is the
  fully-qualified name of a Var which will be invoked by the reader to
  parse the form following the tag. For example, given the
  data_readers.clj file above, the Clojure reader would parse this
  form:

      #foo/bar [1 2 3]

  by invoking the Var #&#x27;my.project.foo/bar on the vector [1 2 3]. The
  data reader function is invoked on the form AFTER it has been read
  as a normal Clojure data structure by the reader.

  Reader tags without namespace qualifiers are reserved for
  Clojure. Default reader tags are defined in
  clojure.core/default-data-readers but may be overridden in
  data_readers.clj, data_readers.cljc, or by rebinding this Var.</div><div class="section" data-reactid="493"><a href="../clj/clojure.core/&#x27;a&#x27;data-readers&#x27;a&#x27;.html" data-reactid="494"><h3 data-reactid="495">+ Source</h3></a></div></div><div class="var-info" data-reactid="496"><a href="../clj/clojure.core/&#x27;a&#x27;default-data-reader-fn&#x27;a&#x27;.html" data-reactid="497"><h2 data-reactid="498">*default-data-reader-fn*</h2></a><div class="section doc" data-reactid="499">When no data reader is found for a tag and *default-data-reader-fn*
  is non-nil, it will be called with two arguments,
  the tag and the value.  If *default-data-reader-fn* is nil (the
  default), an exception will be thrown for the unknown tag.</div><div class="section" data-reactid="500"><a href="../clj/clojure.core/&#x27;a&#x27;default-data-reader-fn&#x27;a&#x27;.html" data-reactid="501"><h3 data-reactid="502">+ Source</h3></a></div></div><div class="var-info" data-reactid="503"><a href="../clj/clojure.core/&#x27;a&#x27;e.html" data-reactid="504"><h2 data-reactid="505">*e</h2></a><div class="section doc" data-reactid="506">bound in a repl thread to the most recent exception caught by the repl</div><div class="section" data-reactid="507"><a href="../clj/clojure.core/&#x27;a&#x27;e.html" data-reactid="508"><h3 data-reactid="509">+ Source</h3></a></div></div><div class="var-info" data-reactid="510"><a href="../clj/clojure.core/&#x27;a&#x27;err&#x27;a&#x27;.html" data-reactid="511"><h2 data-reactid="512">*err*</h2></a><div class="section doc" data-reactid="513">A java.io.Writer object representing standard error for print operations.

  Defaults to System/err, wrapped in a PrintWriter</div></div><div class="var-info" data-reactid="514"><a href="../clj/clojure.core/&#x27;a&#x27;file&#x27;a&#x27;.html" data-reactid="515"><h2 data-reactid="516">*file*</h2></a><div class="section doc" data-reactid="517">The path of the file being evaluated, as a String.

  When there is no file, e.g. in the REPL, the value is not defined.</div></div><div class="var-info" data-reactid="518"><a href="../clj/clojure.core/&#x27;a&#x27;flush-on-newline&#x27;a&#x27;.html" data-reactid="519"><h2 data-reactid="520">*flush-on-newline*</h2></a><div class="section doc" data-reactid="521">When set to true, output will be flushed whenever a newline is printed.

  Defaults to true.</div></div><div class="var-info" data-reactid="522"><a href="../clj/clojure.core/&#x27;a&#x27;fn-loader&#x27;a&#x27;.html" data-reactid="523"><h2 data-reactid="524">*fn-loader*</h2></a></div><div class="var-info" data-reactid="525"><a href="../clj/clojure.core/&#x27;a&#x27;in&#x27;a&#x27;.html" data-reactid="526"><h2 data-reactid="527">*in*</h2></a><div class="section doc" data-reactid="528">A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader</div></div><div class="var-info" data-reactid="529"><a href="../clj/clojure.core/&#x27;a&#x27;math-context&#x27;a&#x27;.html" data-reactid="530"><h2 data-reactid="531">*math-context*</h2></a></div><div class="var-info" data-reactid="532"><a href="../clj/clojure.core/&#x27;a&#x27;ns&#x27;a&#x27;.html" data-reactid="533"><h2 data-reactid="534">*ns*</h2></a><div class="section doc" data-reactid="535">A clojure.lang.Namespace object representing the current namespace.</div></div><div class="var-info" data-reactid="536"><a href="../clj/clojure.core/&#x27;a&#x27;out&#x27;a&#x27;.html" data-reactid="537"><h2 data-reactid="538">*out*</h2></a><div class="section doc" data-reactid="539">A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter</div></div><div class="var-info" data-reactid="540"><a href="../clj/clojure.core/&#x27;a&#x27;print-dup&#x27;a&#x27;.html" data-reactid="541"><h2 data-reactid="542">*print-dup*</h2></a><div class="section doc" data-reactid="543">When set to logical true, objects will be printed in a way that preserves
  their type when read in later.

  Defaults to false.</div></div><div class="var-info" data-reactid="544"><a href="../clj/clojure.core/&#x27;a&#x27;print-length&#x27;a&#x27;.html" data-reactid="545"><h2 data-reactid="546">*print-length*</h2></a><div class="section doc" data-reactid="547">*print-length* controls how many items of each collection the
  printer will print. If it is bound to logical false, there is no
  limit. Otherwise, it must be bound to an integer indicating the maximum
  number of items of each collection to print. If a collection contains
  more items, the printer will print items up to the limit followed by
  &#x27;...&#x27; to represent the remaining items. The root binding is nil
  indicating no limit.</div><div class="section" data-reactid="548"><a href="../clj/clojure.core/&#x27;a&#x27;print-length&#x27;a&#x27;.html" data-reactid="549"><h3 data-reactid="550">+ Source</h3></a></div></div><div class="var-info" data-reactid="551"><a href="../clj/clojure.core/&#x27;a&#x27;print-level&#x27;a&#x27;.html" data-reactid="552"><h2 data-reactid="553">*print-level*</h2></a><div class="section doc" data-reactid="554">*print-level* controls how many levels deep the printer will
  print nested objects. If it is bound to logical false, there is no
  limit. Otherwise, it must be bound to an integer indicating the maximum
  level to print. Each argument to print is at level 0; if an argument is a
  collection, its items are at level 1; and so on. If an object is a
  collection and is at a level greater than or equal to the value bound to
  *print-level*, the printer prints &#x27;#&#x27; to represent it. The root binding
  is nil indicating no limit.</div><div class="section" data-reactid="555"><a href="../clj/clojure.core/&#x27;a&#x27;print-level&#x27;a&#x27;.html" data-reactid="556"><h3 data-reactid="557">+ Source</h3></a></div></div><div class="var-info" data-reactid="558"><a href="../clj/clojure.core/&#x27;a&#x27;print-meta&#x27;a&#x27;.html" data-reactid="559"><h2 data-reactid="560">*print-meta*</h2></a><div class="section doc" data-reactid="561">If set to logical true, when printing an object, its metadata will also
  be printed in a form that can be read back by the reader.

  Defaults to false.</div></div><div class="var-info" data-reactid="562"><a href="../clj/clojure.core/&#x27;a&#x27;print-namespace-maps&#x27;a&#x27;.html" data-reactid="563"><h2 data-reactid="564">*print-namespace-maps*</h2></a><div class="section doc" data-reactid="565">*print-namespace-maps* controls whether the printer will print
  namespace map literal syntax. It defaults to false, but the REPL binds
  to true.</div><div class="section" data-reactid="566"><a href="../clj/clojure.core/&#x27;a&#x27;print-namespace-maps&#x27;a&#x27;.html" data-reactid="567"><h3 data-reactid="568">+ Source</h3></a></div></div><div class="var-info" data-reactid="569"><a href="../clj/clojure.core/&#x27;a&#x27;print-readably&#x27;a&#x27;.html" data-reactid="570"><h2 data-reactid="571">*print-readably*</h2></a><div class="section doc" data-reactid="572">When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true</div></div><div class="var-info" data-reactid="573"><a href="../clj/clojure.core/&#x27;a&#x27;read-eval&#x27;a&#x27;.html" data-reactid="574"><h2 data-reactid="575">*read-eval*</h2></a><div class="section doc" data-reactid="576">Defaults to true (or value specified by system property, see below)
  ***This setting implies that the full power of the reader is in play,
  including syntax that can cause code to execute. It should never be
  used with untrusted sources. See also: clojure.edn/read.***

  When set to logical false in the thread-local binding,
  the eval reader (#=) and record/type literal syntax are disabled in read/load.
  Example (will fail): (binding [*read-eval* false] (read-string &quot;#=(* 2 21)&quot;))

  The default binding can be controlled by the system property
  &#x27;clojure.read.eval&#x27; System properties can be set on the command line
  like this:

  java -Dclojure.read.eval=false ...

  The system property can also be set to &#x27;unknown&#x27; via
  -Dclojure.read.eval=unknown, in which case the default binding
  is :unknown and all reads will fail in contexts where *read-eval*
  has not been explicitly bound to either true or false. This setting
  can be a useful diagnostic tool to ensure that all of your reads
  occur in considered contexts. You can also accomplish this in a
  particular scope by binding *read-eval* to :unknown
  </div></div><div class="var-info" data-reactid="577"><a href="../clj/clojure.core/&#x27;a&#x27;reader-resolver&#x27;a&#x27;.html" data-reactid="578"><h2 data-reactid="579">*reader-resolver*</h2></a></div><div class="var-info" data-reactid="580"><a href="../clj/clojure.core/&#x27;a&#x27;source-path&#x27;a&#x27;.html" data-reactid="581"><h2 data-reactid="582">*source-path*</h2></a></div><div class="var-info" data-reactid="583"><a href="../clj/clojure.core/&#x27;a&#x27;suppress-read&#x27;a&#x27;.html" data-reactid="584"><h2 data-reactid="585">*suppress-read*</h2></a></div><div class="var-info" data-reactid="586"><a href="../clj/clojure.core/&#x27;a&#x27;unchecked-math&#x27;a&#x27;.html" data-reactid="587"><h2 data-reactid="588">*unchecked-math*</h2></a><div class="section doc" data-reactid="589">While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.</div></div><div class="var-info" data-reactid="590"><a href="../clj/clojure.core/&#x27;a&#x27;use-context-classloader&#x27;a&#x27;.html" data-reactid="591"><h2 data-reactid="592">*use-context-classloader*</h2></a></div><div class="var-info" data-reactid="593"><a href="../clj/clojure.core/&#x27;a&#x27;verbose-defrecords&#x27;a&#x27;.html" data-reactid="594"><h2 data-reactid="595">*verbose-defrecords*</h2></a><div class="section" data-reactid="596"><a href="../clj/clojure.core/&#x27;a&#x27;verbose-defrecords&#x27;a&#x27;.html" data-reactid="597"><h3 data-reactid="598">+ Source</h3></a></div></div><div class="var-info" data-reactid="599"><a href="../clj/clojure.core/&#x27;a&#x27;warn-on-reflection&#x27;a&#x27;.html" data-reactid="600"><h2 data-reactid="601">*warn-on-reflection*</h2></a><div class="section doc" data-reactid="602">When set to true, the compiler will emit warnings when reflection is
  needed to resolve Java method calls or field accesses.

  Defaults to false.</div></div><div class="var-info" data-reactid="603"><a href="../clj/clojure.core/+.html" data-reactid="604"><h2 data-reactid="605">(+)</h2><h2 data-reactid="606">(+ x)</h2><h2 data-reactid="607">(+ x y)</h2><h2 data-reactid="608">(+ x y &amp; more)</h2></a><div class="section doc" data-reactid="609">Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&#x27;</div><div class="section" data-reactid="610"><a href="../clj/clojure.core/+.html" data-reactid="611"><h3 data-reactid="612">+ Source</h3></a></div></div><div class="var-info" data-reactid="613"><a href="../clj/clojure.core/+&#x27;.html" data-reactid="614"><h2 data-reactid="615">(+&#x27;)</h2><h2 data-reactid="616">(+&#x27; x)</h2><h2 data-reactid="617">(+&#x27; x y)</h2><h2 data-reactid="618">(+&#x27; x y &amp; more)</h2></a><div class="section doc" data-reactid="619">Returns the sum of nums. (+&#x27;) returns 0. Supports arbitrary precision.
  See also: +</div><div class="section" data-reactid="620"><a href="../clj/clojure.core/+&#x27;.html" data-reactid="621"><h3 data-reactid="622">+ Source</h3></a></div></div><div class="var-info" data-reactid="623"><a href="../clj/clojure.core/-.html" data-reactid="624"><h2 data-reactid="625">(- x)</h2><h2 data-reactid="626">(- x y)</h2><h2 data-reactid="627">(- x y &amp; more)</h2></a><div class="section doc" data-reactid="628">If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&#x27;</div><div class="section" data-reactid="629"><a href="../clj/clojure.core/-.html" data-reactid="630"><h3 data-reactid="631">+ Source</h3></a></div></div><div class="var-info" data-reactid="632"><a href="../clj/clojure.core/-&#x27;.html" data-reactid="633"><h2 data-reactid="634">(-&#x27; x)</h2><h2 data-reactid="635">(-&#x27; x y)</h2><h2 data-reactid="636">(-&#x27; x y &amp; more)</h2></a><div class="section doc" data-reactid="637">If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -</div><div class="section" data-reactid="638"><a href="../clj/clojure.core/-&#x27;.html" data-reactid="639"><h3 data-reactid="640">+ Source</h3></a></div></div><div class="var-info" data-reactid="641"><a href="../clj/clojure.core/-&#x27;g&#x27;.html" data-reactid="642"><h2 data-reactid="643">(-&gt; x &amp; forms)</h2></a><div class="section doc" data-reactid="644">Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.</div><div class="section" data-reactid="645"><a href="../clj/clojure.core/-&#x27;g&#x27;.html" data-reactid="646"><h3 data-reactid="647">+ Source</h3></a></div></div><div class="var-info" data-reactid="648"><a href="../clj/clojure.core/-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="649"><h2 data-reactid="650">(-&gt;&gt; x &amp; forms)</h2></a><div class="section doc" data-reactid="651">Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.</div><div class="section" data-reactid="652"><a href="../clj/clojure.core/-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="653"><h3 data-reactid="654">+ Source</h3></a></div></div><div class="var-info" data-reactid="655"><a href="../clj/clojure.core/-&#x27;g&#x27;ArrayChunk.html" data-reactid="656"><h2 data-reactid="657">(-&gt;ArrayChunk am arr off end)</h2></a><div class="section doc" data-reactid="658">Positional factory function for class clojure.core.ArrayChunk.</div><div class="section" data-reactid="659"><a href="../clj/clojure.core/-&#x27;g&#x27;ArrayChunk.html" data-reactid="660"><h3 data-reactid="661">+ Source</h3></a></div></div><div class="var-info" data-reactid="662"><a href="../clj/clojure.core/-&#x27;g&#x27;Eduction.html" data-reactid="663"><h2 data-reactid="664">(-&gt;Eduction xform coll)</h2></a><div class="section doc" data-reactid="665">Positional factory function for class clojure.core.Eduction.</div><div class="section" data-reactid="666"><a href="../clj/clojure.core/-&#x27;g&#x27;Eduction.html" data-reactid="667"><h3 data-reactid="668">+ Source</h3></a></div></div><div class="var-info" data-reactid="669"><a href="../clj/clojure.core/-&#x27;g&#x27;Vec.html" data-reactid="670"><h2 data-reactid="671">(-&gt;Vec am cnt shift root tail _meta)</h2></a><div class="section doc" data-reactid="672">Positional factory function for class clojure.core.Vec.</div><div class="section" data-reactid="673"><a href="../clj/clojure.core/-&#x27;g&#x27;Vec.html" data-reactid="674"><h3 data-reactid="675">+ Source</h3></a></div></div><div class="var-info" data-reactid="676"><a href="../clj/clojure.core/-&#x27;g&#x27;VecNode.html" data-reactid="677"><h2 data-reactid="678">(-&gt;VecNode edit arr)</h2></a><div class="section doc" data-reactid="679">Positional factory function for class clojure.core.VecNode.</div><div class="section" data-reactid="680"><a href="../clj/clojure.core/-&#x27;g&#x27;VecNode.html" data-reactid="681"><h3 data-reactid="682">+ Source</h3></a></div></div><div class="var-info" data-reactid="683"><a href="../clj/clojure.core/-&#x27;g&#x27;VecSeq.html" data-reactid="684"><h2 data-reactid="685">(-&gt;VecSeq am vec anode i offset)</h2></a><div class="section doc" data-reactid="686">Positional factory function for class clojure.core.VecSeq.</div><div class="section" data-reactid="687"><a href="../clj/clojure.core/-&#x27;g&#x27;VecSeq.html" data-reactid="688"><h3 data-reactid="689">+ Source</h3></a></div></div><div class="var-info" data-reactid="690"><a href="../clj/clojure.core/-cache-protocol-fn.html" data-reactid="691"><h2 data-reactid="692">(-cache-protocol-fn pf x c interf)</h2></a><div class="section" data-reactid="693"><a href="../clj/clojure.core/-cache-protocol-fn.html" data-reactid="694"><h3 data-reactid="695">+ Source</h3></a></div></div><div class="var-info" data-reactid="696"><a href="../clj/clojure.core/-reset-methods.html" data-reactid="697"><h2 data-reactid="698">(-reset-methods protocol)</h2></a><div class="section" data-reactid="699"><a href="../clj/clojure.core/-reset-methods.html" data-reactid="700"><h3 data-reactid="701">+ Source</h3></a></div></div><div class="var-info" data-reactid="702"><a href="../clj/clojure.core/...html" data-reactid="703"><h2 data-reactid="704">(.. x form)</h2><h2 data-reactid="705">(.. x form &amp; more)</h2></a><div class="section doc" data-reactid="706">form =&gt; fieldName-symbol or (instanceMethodName-symbol args*)

  Expands into a member access (.) of the first member on the first
  argument, followed by the next member on the result, etc. For
  instance:

  (.. System (getProperties) (get &quot;os.name&quot;))

  expands to:

  (. (. System (getProperties)) (get &quot;os.name&quot;))

  but is easier to write, read, and understand.</div><div class="section" data-reactid="707"><a href="../clj/clojure.core/...html" data-reactid="708"><h3 data-reactid="709">+ Source</h3></a></div></div><div class="var-info" data-reactid="710"><a href="../clj/clojure.core//.html" data-reactid="711"><h2 data-reactid="712">(/ x)</h2><h2 data-reactid="713">(/ x y)</h2><h2 data-reactid="714">(/ x y &amp; more)</h2></a><div class="section doc" data-reactid="715">If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.</div><div class="section" data-reactid="716"><a href="../clj/clojure.core//.html" data-reactid="717"><h3 data-reactid="718">+ Source</h3></a></div></div><div class="var-info" data-reactid="719"><a href="../clj/clojure.core/&#x27;l&#x27;.html" data-reactid="720"><h2 data-reactid="721">(&lt; x)</h2><h2 data-reactid="722">(&lt; x y)</h2><h2 data-reactid="723">(&lt; x y &amp; more)</h2></a><div class="section doc" data-reactid="724">Returns non-nil if nums are in monotonically increasing order,
  otherwise false.</div><div class="section" data-reactid="725"><a href="../clj/clojure.core/&#x27;l&#x27;.html" data-reactid="726"><h3 data-reactid="727">+ Source</h3></a></div></div><div class="var-info" data-reactid="728"><a href="../clj/clojure.core/&#x27;l&#x27;=.html" data-reactid="729"><h2 data-reactid="730">(&lt;= x)</h2><h2 data-reactid="731">(&lt;= x y)</h2><h2 data-reactid="732">(&lt;= x y &amp; more)</h2></a><div class="section doc" data-reactid="733">Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false.</div><div class="section" data-reactid="734"><a href="../clj/clojure.core/&#x27;l&#x27;=.html" data-reactid="735"><h3 data-reactid="736">+ Source</h3></a></div></div><div class="var-info" data-reactid="737"><a href="../clj/clojure.core/=.html" data-reactid="738"><h2 data-reactid="739">(= x)</h2><h2 data-reactid="740">(= x y)</h2><h2 data-reactid="741">(= x y &amp; more)</h2></a><div class="section doc" data-reactid="742">Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&#x27;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.</div><div class="section" data-reactid="743"><a href="../clj/clojure.core/=.html" data-reactid="744"><h3 data-reactid="745">+ Source</h3></a></div></div><div class="var-info" data-reactid="746"><a href="../clj/clojure.core/==.html" data-reactid="747"><h2 data-reactid="748">(== x)</h2><h2 data-reactid="749">(== x y)</h2><h2 data-reactid="750">(== x y &amp; more)</h2></a><div class="section doc" data-reactid="751">Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false</div><div class="section" data-reactid="752"><a href="../clj/clojure.core/==.html" data-reactid="753"><h3 data-reactid="754">+ Source</h3></a></div></div><div class="var-info" data-reactid="755"><a href="../clj/clojure.core/&#x27;g&#x27;.html" data-reactid="756"><h2 data-reactid="757">(&gt; x)</h2><h2 data-reactid="758">(&gt; x y)</h2><h2 data-reactid="759">(&gt; x y &amp; more)</h2></a><div class="section doc" data-reactid="760">Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.</div><div class="section" data-reactid="761"><a href="../clj/clojure.core/&#x27;g&#x27;.html" data-reactid="762"><h3 data-reactid="763">+ Source</h3></a></div></div><div class="var-info" data-reactid="764"><a href="../clj/clojure.core/&#x27;g&#x27;=.html" data-reactid="765"><h2 data-reactid="766">(&gt;= x)</h2><h2 data-reactid="767">(&gt;= x y)</h2><h2 data-reactid="768">(&gt;= x y &amp; more)</h2></a><div class="section doc" data-reactid="769">Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.</div><div class="section" data-reactid="770"><a href="../clj/clojure.core/&#x27;g&#x27;=.html" data-reactid="771"><h3 data-reactid="772">+ Source</h3></a></div></div><div class="var-info" data-reactid="773"><a href="../clj/clojure.core/EMPTY-NODE.html" data-reactid="774"><h2 data-reactid="775">EMPTY-NODE</h2></a><div class="section" data-reactid="776"><a href="../clj/clojure.core/EMPTY-NODE.html" data-reactid="777"><h3 data-reactid="778">+ Source</h3></a></div></div><div class="var-info" data-reactid="779"><a href="../clj/clojure.core/Inst.html" data-reactid="780"><h2 data-reactid="781">Inst</h2></a><div class="section" data-reactid="782"><a href="../clj/clojure.core/Inst.html" data-reactid="783"><h3 data-reactid="784">+ Source</h3></a></div></div><div class="var-info" data-reactid="785"><a href="../clj/clojure.core/StackTraceElement-&#x27;g&#x27;vec.html" data-reactid="786"><h2 data-reactid="787">(StackTraceElement-&gt;vec o)</h2></a><div class="section doc" data-reactid="788">Constructs a data representation for a StackTraceElement</div><div class="section" data-reactid="789"><a href="../clj/clojure.core/StackTraceElement-&#x27;g&#x27;vec.html" data-reactid="790"><h3 data-reactid="791">+ Source</h3></a></div></div><div class="var-info" data-reactid="792"><a href="../clj/clojure.core/Throwable-&#x27;g&#x27;map.html" data-reactid="793"><h2 data-reactid="794">(Throwable-&gt;map o)</h2></a><div class="section doc" data-reactid="795">Constructs a data representation for a Throwable.</div><div class="section" data-reactid="796"><a href="../clj/clojure.core/Throwable-&#x27;g&#x27;map.html" data-reactid="797"><h3 data-reactid="798">+ Source</h3></a></div></div><div class="var-info" data-reactid="799"><a href="../clj/clojure.core/accessor.html" data-reactid="800"><h2 data-reactid="801">(accessor s key)</h2></a><div class="section doc" data-reactid="802">Returns a fn that, given an instance of a structmap with the basis,
  returns the value at the key.  The key must be in the basis. The
  returned function should be (slightly) more efficient than using
  get, but such use of accessors should be limited to known
  performance-critical areas.</div><div class="section" data-reactid="803"><a href="../clj/clojure.core/accessor.html" data-reactid="804"><h3 data-reactid="805">+ Source</h3></a></div></div><div class="var-info" data-reactid="806"><a href="../clj/clojure.core/aclone.html" data-reactid="807"><h2 data-reactid="808">(aclone array)</h2></a><div class="section doc" data-reactid="809">Returns a clone of the Java array. Works on arrays of known
  types.</div><div class="section" data-reactid="810"><a href="../clj/clojure.core/aclone.html" data-reactid="811"><h3 data-reactid="812">+ Source</h3></a></div></div><div class="var-info" data-reactid="813"><a href="../clj/clojure.core/add-classpath.html" data-reactid="814"><h2 data-reactid="815">(add-classpath url)</h2></a><div class="section doc" data-reactid="816">DEPRECATED 

  Adds the url (String or URL object) to the classpath per
  URLClassLoader.addURL</div><div class="section" data-reactid="817"><a href="../clj/clojure.core/add-classpath.html" data-reactid="818"><h3 data-reactid="819">+ Source</h3></a></div></div><div class="var-info" data-reactid="820"><a href="../clj/clojure.core/add-watch.html" data-reactid="821"><h2 data-reactid="822">(add-watch reference key fn)</h2></a><div class="section doc" data-reactid="823">Adds a watch function to an agent/atom/var/ref reference. The watch
  fn must be a fn of 4 args: a key, the reference, its old-state, its
  new-state. Whenever the reference&#x27;s state might have been changed,
  any registered watches will have their functions called. The watch fn
  will be called synchronously, on the agent&#x27;s thread if an agent,
  before any pending sends if agent or ref. Note that an atom&#x27;s or
  ref&#x27;s state may have changed again prior to the fn call, so use
  old/new-state rather than derefing the reference. Note also that watch
  fns may be called from multiple threads simultaneously. Var watchers
  are triggered only by root binding changes, not thread-local
  set!s. Keys must be unique per reference, and can be used to remove
  the watch with remove-watch, but are otherwise considered opaque by
  the watch mechanism.</div><div class="section" data-reactid="824"><a href="../clj/clojure.core/add-watch.html" data-reactid="825"><h3 data-reactid="826">+ Source</h3></a></div></div><div class="var-info" data-reactid="827"><a href="../clj/clojure.core/agent.html" data-reactid="828"><h2 data-reactid="829">(agent state &amp; options)</h2></a><div class="section doc" data-reactid="830">Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.</div><div class="section" data-reactid="831"><a href="../clj/clojure.core/agent.html" data-reactid="832"><h3 data-reactid="833">+ Source</h3></a></div></div><div class="var-info" data-reactid="834"><a href="../clj/clojure.core/agent-error.html" data-reactid="835"><h2 data-reactid="836">(agent-error a)</h2></a><div class="section doc" data-reactid="837">Returns the exception thrown during an asynchronous action of the
  agent if the agent is failed.  Returns nil if the agent is not
  failed.</div><div class="section" data-reactid="838"><a href="../clj/clojure.core/agent-error.html" data-reactid="839"><h3 data-reactid="840">+ Source</h3></a></div></div><div class="var-info" data-reactid="841"><a href="../clj/clojure.core/agent-errors.html" data-reactid="842"><h2 data-reactid="843">(agent-errors a)</h2></a><div class="section doc" data-reactid="844">DEPRECATED: Use &#x27;agent-error&#x27; instead.
  Returns a sequence of the exceptions thrown during asynchronous
  actions of the agent.</div><div class="section" data-reactid="845"><a href="../clj/clojure.core/agent-errors.html" data-reactid="846"><h3 data-reactid="847">+ Source</h3></a></div></div><div class="var-info" data-reactid="848"><a href="../clj/clojure.core/aget.html" data-reactid="849"><h2 data-reactid="850">(aget array idx)</h2><h2 data-reactid="851">(aget array idx &amp; idxs)</h2></a><div class="section doc" data-reactid="852">Returns the value at the index/indices. Works on Java arrays of all
  types.</div><div class="section" data-reactid="853"><a href="../clj/clojure.core/aget.html" data-reactid="854"><h3 data-reactid="855">+ Source</h3></a></div></div><div class="var-info" data-reactid="856"><a href="../clj/clojure.core/alength.html" data-reactid="857"><h2 data-reactid="858">(alength array)</h2></a><div class="section doc" data-reactid="859">Returns the length of the Java array. Works on arrays of all
  types.</div><div class="section" data-reactid="860"><a href="../clj/clojure.core/alength.html" data-reactid="861"><h3 data-reactid="862">+ Source</h3></a></div></div><div class="var-info" data-reactid="863"><a href="../clj/clojure.core/alias.html" data-reactid="864"><h2 data-reactid="865">(alias alias namespace-sym)</h2></a><div class="section doc" data-reactid="866">Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.</div><div class="section" data-reactid="867"><a href="../clj/clojure.core/alias.html" data-reactid="868"><h3 data-reactid="869">+ Source</h3></a></div></div><div class="var-info" data-reactid="870"><a href="../clj/clojure.core/all-ns.html" data-reactid="871"><h2 data-reactid="872">(all-ns)</h2></a><div class="section doc" data-reactid="873">Returns a sequence of all namespaces.</div><div class="section" data-reactid="874"><a href="../clj/clojure.core/all-ns.html" data-reactid="875"><h3 data-reactid="876">+ Source</h3></a></div></div><div class="var-info" data-reactid="877"><a href="../clj/clojure.core/alter.html" data-reactid="878"><h2 data-reactid="879">(alter ref fun &amp; args)</h2></a><div class="section doc" data-reactid="880">Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.</div><div class="section" data-reactid="881"><a href="../clj/clojure.core/alter.html" data-reactid="882"><h3 data-reactid="883">+ Source</h3></a></div></div><div class="var-info" data-reactid="884"><a href="../clj/clojure.core/alter-meta&#x27;e&#x27;.html" data-reactid="885"><h2 data-reactid="886">(alter-meta! iref f &amp; args)</h2></a><div class="section doc" data-reactid="887">Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects</div><div class="section" data-reactid="888"><a href="../clj/clojure.core/alter-meta&#x27;e&#x27;.html" data-reactid="889"><h3 data-reactid="890">+ Source</h3></a></div></div><div class="var-info" data-reactid="891"><a href="../clj/clojure.core/alter-var-root.html" data-reactid="892"><h2 data-reactid="893">(alter-var-root v f &amp; args)</h2></a><div class="section doc" data-reactid="894">Atomically alters the root binding of var v by applying f to its
  current value plus any args</div><div class="section" data-reactid="895"><a href="../clj/clojure.core/alter-var-root.html" data-reactid="896"><h3 data-reactid="897">+ Source</h3></a></div></div><div class="var-info" data-reactid="898"><a href="../clj/clojure.core/amap.html" data-reactid="899"><h2 data-reactid="900">(amap a idx ret expr)</h2></a><div class="section doc" data-reactid="901">Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.</div><div class="section" data-reactid="902"><a href="../clj/clojure.core/amap.html" data-reactid="903"><h3 data-reactid="904">+ Source</h3></a></div></div><div class="var-info" data-reactid="905"><a href="../clj/clojure.core/ancestors.html" data-reactid="906"><h2 data-reactid="907">(ancestors tag)</h2><h2 data-reactid="908">(ancestors h tag)</h2></a><div class="section doc" data-reactid="909">Returns the immediate and indirect parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy</div><div class="section" data-reactid="910"><a href="../clj/clojure.core/ancestors.html" data-reactid="911"><h3 data-reactid="912">+ Source</h3></a></div></div><div class="var-info" data-reactid="913"><a href="../clj/clojure.core/and.html" data-reactid="914"><h2 data-reactid="915">(and)</h2><h2 data-reactid="916">(and x)</h2><h2 data-reactid="917">(and x &amp; next)</h2></a><div class="section doc" data-reactid="918">Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&#x27;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.</div><div class="section" data-reactid="919"><a href="../clj/clojure.core/and.html" data-reactid="920"><h3 data-reactid="921">+ Source</h3></a></div></div><div class="var-info" data-reactid="922"><a href="../clj/clojure.core/any&#x27;q&#x27;.html" data-reactid="923"><h2 data-reactid="924">(any? x)</h2></a><div class="section doc" data-reactid="925">Returns true given any argument.</div><div class="section" data-reactid="926"><a href="../clj/clojure.core/any&#x27;q&#x27;.html" data-reactid="927"><h3 data-reactid="928">+ Source</h3></a></div></div><div class="var-info" data-reactid="929"><a href="../clj/clojure.core/apply.html" data-reactid="930"><h2 data-reactid="931">(apply f args)</h2><h2 data-reactid="932">(apply f x args)</h2><h2 data-reactid="933">(apply f x y args)</h2><h2 data-reactid="934">(apply f x y z args)</h2><h2 data-reactid="935">(apply f a b c d &amp; args)</h2></a><div class="section doc" data-reactid="936">Applies fn f to the argument list formed by prepending intervening arguments to args.</div><div class="section" data-reactid="937"><a href="../clj/clojure.core/apply.html" data-reactid="938"><h3 data-reactid="939">+ Source</h3></a></div></div><div class="var-info" data-reactid="940"><a href="../clj/clojure.core/areduce.html" data-reactid="941"><h2 data-reactid="942">(areduce a idx ret init expr)</h2></a><div class="section doc" data-reactid="943">Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the 
  evaluation of expr at each step, returning ret.</div><div class="section" data-reactid="944"><a href="../clj/clojure.core/areduce.html" data-reactid="945"><h3 data-reactid="946">+ Source</h3></a></div></div><div class="var-info" data-reactid="947"><a href="../clj/clojure.core/array-map.html" data-reactid="948"><h2 data-reactid="949">(array-map)</h2><h2 data-reactid="950">(array-map &amp; keyvals)</h2></a><div class="section doc" data-reactid="951">Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc.</div><div class="section" data-reactid="952"><a href="../clj/clojure.core/array-map.html" data-reactid="953"><h3 data-reactid="954">+ Source</h3></a></div></div><div class="var-info" data-reactid="955"><a href="../clj/clojure.core/as-&#x27;g&#x27;.html" data-reactid="956"><h2 data-reactid="957">(as-&gt; expr name &amp; forms)</h2></a><div class="section doc" data-reactid="958">Binds name to expr, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form.</div><div class="section" data-reactid="959"><a href="../clj/clojure.core/as-&#x27;g&#x27;.html" data-reactid="960"><h3 data-reactid="961">+ Source</h3></a></div></div><div class="var-info" data-reactid="962"><a href="../clj/clojure.core/aset.html" data-reactid="963"><h2 data-reactid="964">(aset array idx val)</h2><h2 data-reactid="965">(aset array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="966">Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.</div><div class="section" data-reactid="967"><a href="../clj/clojure.core/aset.html" data-reactid="968"><h3 data-reactid="969">+ Source</h3></a></div></div><div class="var-info" data-reactid="970"><a href="../clj/clojure.core/aset-boolean.html" data-reactid="971"><h2 data-reactid="972">(aset-boolean array idx val)</h2><h2 data-reactid="973">(aset-boolean array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="974">Sets the value at the index/indices. Works on arrays of boolean. Returns val.</div><div class="section" data-reactid="975"><a href="../clj/clojure.core/aset-boolean.html" data-reactid="976"><h3 data-reactid="977">+ Source</h3></a></div></div><div class="var-info" data-reactid="978"><a href="../clj/clojure.core/aset-byte.html" data-reactid="979"><h2 data-reactid="980">(aset-byte array idx val)</h2><h2 data-reactid="981">(aset-byte array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="982">Sets the value at the index/indices. Works on arrays of byte. Returns val.</div><div class="section" data-reactid="983"><a href="../clj/clojure.core/aset-byte.html" data-reactid="984"><h3 data-reactid="985">+ Source</h3></a></div></div><div class="var-info" data-reactid="986"><a href="../clj/clojure.core/aset-char.html" data-reactid="987"><h2 data-reactid="988">(aset-char array idx val)</h2><h2 data-reactid="989">(aset-char array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="990">Sets the value at the index/indices. Works on arrays of char. Returns val.</div><div class="section" data-reactid="991"><a href="../clj/clojure.core/aset-char.html" data-reactid="992"><h3 data-reactid="993">+ Source</h3></a></div></div><div class="var-info" data-reactid="994"><a href="../clj/clojure.core/aset-double.html" data-reactid="995"><h2 data-reactid="996">(aset-double array idx val)</h2><h2 data-reactid="997">(aset-double array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="998">Sets the value at the index/indices. Works on arrays of double. Returns val.</div><div class="section" data-reactid="999"><a href="../clj/clojure.core/aset-double.html" data-reactid="1000"><h3 data-reactid="1001">+ Source</h3></a></div></div><div class="var-info" data-reactid="1002"><a href="../clj/clojure.core/aset-float.html" data-reactid="1003"><h2 data-reactid="1004">(aset-float array idx val)</h2><h2 data-reactid="1005">(aset-float array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="1006">Sets the value at the index/indices. Works on arrays of float. Returns val.</div><div class="section" data-reactid="1007"><a href="../clj/clojure.core/aset-float.html" data-reactid="1008"><h3 data-reactid="1009">+ Source</h3></a></div></div><div class="var-info" data-reactid="1010"><a href="../clj/clojure.core/aset-int.html" data-reactid="1011"><h2 data-reactid="1012">(aset-int array idx val)</h2><h2 data-reactid="1013">(aset-int array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="1014">Sets the value at the index/indices. Works on arrays of int. Returns val.</div><div class="section" data-reactid="1015"><a href="../clj/clojure.core/aset-int.html" data-reactid="1016"><h3 data-reactid="1017">+ Source</h3></a></div></div><div class="var-info" data-reactid="1018"><a href="../clj/clojure.core/aset-long.html" data-reactid="1019"><h2 data-reactid="1020">(aset-long array idx val)</h2><h2 data-reactid="1021">(aset-long array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="1022">Sets the value at the index/indices. Works on arrays of long. Returns val.</div><div class="section" data-reactid="1023"><a href="../clj/clojure.core/aset-long.html" data-reactid="1024"><h3 data-reactid="1025">+ Source</h3></a></div></div><div class="var-info" data-reactid="1026"><a href="../clj/clojure.core/aset-short.html" data-reactid="1027"><h2 data-reactid="1028">(aset-short array idx val)</h2><h2 data-reactid="1029">(aset-short array idx idx2 &amp; idxv)</h2></a><div class="section doc" data-reactid="1030">Sets the value at the index/indices. Works on arrays of short. Returns val.</div><div class="section" data-reactid="1031"><a href="../clj/clojure.core/aset-short.html" data-reactid="1032"><h3 data-reactid="1033">+ Source</h3></a></div></div><div class="var-info" data-reactid="1034"><a href="../clj/clojure.core/assert.html" data-reactid="1035"><h2 data-reactid="1036">(assert x)</h2><h2 data-reactid="1037">(assert x message)</h2></a><div class="section doc" data-reactid="1038">Evaluates expr and throws an exception if it does not evaluate to
  logical true.</div><div class="section" data-reactid="1039"><a href="../clj/clojure.core/assert.html" data-reactid="1040"><h3 data-reactid="1041">+ Source</h3></a></div></div><div class="var-info" data-reactid="1042"><a href="../clj/clojure.core/assoc.html" data-reactid="1043"><h2 data-reactid="1044">(assoc map key val)</h2><h2 data-reactid="1045">(assoc map key val &amp; kvs)</h2></a><div class="section doc" data-reactid="1046">assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).</div><div class="section" data-reactid="1047"><a href="../clj/clojure.core/assoc.html" data-reactid="1048"><h3 data-reactid="1049">+ Source</h3></a></div></div><div class="var-info" data-reactid="1050"><a href="../clj/clojure.core/assoc&#x27;e&#x27;.html" data-reactid="1051"><h2 data-reactid="1052">(assoc! coll key val)</h2><h2 data-reactid="1053">(assoc! coll key val &amp; kvs)</h2></a><div class="section doc" data-reactid="1054">When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.</div><div class="section" data-reactid="1055"><a href="../clj/clojure.core/assoc&#x27;e&#x27;.html" data-reactid="1056"><h3 data-reactid="1057">+ Source</h3></a></div></div><div class="var-info" data-reactid="1058"><a href="../clj/clojure.core/assoc-in.html" data-reactid="1059"><h2 data-reactid="1060">(assoc-in m [k &amp; ks] v)</h2></a><div class="section doc" data-reactid="1061">Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created.</div><div class="section" data-reactid="1062"><a href="../clj/clojure.core/assoc-in.html" data-reactid="1063"><h3 data-reactid="1064">+ Source</h3></a></div></div><div class="var-info" data-reactid="1065"><a href="../clj/clojure.core/associative&#x27;q&#x27;.html" data-reactid="1066"><h2 data-reactid="1067">(associative? coll)</h2></a><div class="section doc" data-reactid="1068">Returns true if coll implements Associative</div><div class="section" data-reactid="1069"><a href="../clj/clojure.core/associative&#x27;q&#x27;.html" data-reactid="1070"><h3 data-reactid="1071">+ Source</h3></a></div></div><div class="var-info" data-reactid="1072"><a href="../clj/clojure.core/atom.html" data-reactid="1073"><h2 data-reactid="1074">(atom x)</h2><h2 data-reactid="1075">(atom x &amp; options)</h2></a><div class="section doc" data-reactid="1076">Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.</div><div class="section" data-reactid="1077"><a href="../clj/clojure.core/atom.html" data-reactid="1078"><h3 data-reactid="1079">+ Source</h3></a></div></div><div class="var-info" data-reactid="1080"><a href="../clj/clojure.core/await.html" data-reactid="1081"><h2 data-reactid="1082">(await &amp; agents)</h2></a><div class="section doc" data-reactid="1083">Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true or shutdown-agents was called.</div><div class="section" data-reactid="1084"><a href="../clj/clojure.core/await.html" data-reactid="1085"><h3 data-reactid="1086">+ Source</h3></a></div></div><div class="var-info" data-reactid="1087"><a href="../clj/clojure.core/await-for.html" data-reactid="1088"><h2 data-reactid="1089">(await-for timeout-ms &amp; agents)</h2></a><div class="section doc" data-reactid="1090">Blocks the current thread until all actions dispatched thus
  far (from this thread or agent) to the agents have occurred, or the
  timeout (in milliseconds) has elapsed. Returns logical false if
  returning due to timeout, logical true otherwise.</div><div class="section" data-reactid="1091"><a href="../clj/clojure.core/await-for.html" data-reactid="1092"><h3 data-reactid="1093">+ Source</h3></a></div></div><div class="var-info" data-reactid="1094"><a href="../clj/clojure.core/await1.html" data-reactid="1095"><h2 data-reactid="1096">(await1 a)</h2></a><div class="section" data-reactid="1097"><a href="../clj/clojure.core/await1.html" data-reactid="1098"><h3 data-reactid="1099">+ Source</h3></a></div></div><div class="var-info" data-reactid="1100"><a href="../clj/clojure.core/bases.html" data-reactid="1101"><h2 data-reactid="1102">(bases c)</h2></a><div class="section doc" data-reactid="1103">Returns the immediate superclass and direct interfaces of c, if any</div><div class="section" data-reactid="1104"><a href="../clj/clojure.core/bases.html" data-reactid="1105"><h3 data-reactid="1106">+ Source</h3></a></div></div><div class="var-info" data-reactid="1107"><a href="../clj/clojure.core/bean.html" data-reactid="1108"><h2 data-reactid="1109">(bean x)</h2></a><div class="section doc" data-reactid="1110">Takes a Java object and returns a read-only implementation of the
  map abstraction based upon its JavaBean properties.</div><div class="section" data-reactid="1111"><a href="../clj/clojure.core/bean.html" data-reactid="1112"><h3 data-reactid="1113">+ Source</h3></a></div></div><div class="var-info" data-reactid="1114"><a href="../clj/clojure.core/bigdec.html" data-reactid="1115"><h2 data-reactid="1116">(bigdec x)</h2></a><div class="section doc" data-reactid="1117">Coerce to BigDecimal</div><div class="section" data-reactid="1118"><a href="../clj/clojure.core/bigdec.html" data-reactid="1119"><h3 data-reactid="1120">+ Source</h3></a></div></div><div class="var-info" data-reactid="1121"><a href="../clj/clojure.core/bigint.html" data-reactid="1122"><h2 data-reactid="1123">(bigint x)</h2></a><div class="section doc" data-reactid="1124">Coerce to BigInt</div><div class="section" data-reactid="1125"><a href="../clj/clojure.core/bigint.html" data-reactid="1126"><h3 data-reactid="1127">+ Source</h3></a></div></div><div class="var-info" data-reactid="1128"><a href="../clj/clojure.core/biginteger.html" data-reactid="1129"><h2 data-reactid="1130">(biginteger x)</h2></a><div class="section doc" data-reactid="1131">Coerce to BigInteger</div><div class="section" data-reactid="1132"><a href="../clj/clojure.core/biginteger.html" data-reactid="1133"><h3 data-reactid="1134">+ Source</h3></a></div></div><div class="var-info" data-reactid="1135"><a href="../clj/clojure.core/binding.html" data-reactid="1136"><h2 data-reactid="1137">(binding bindings &amp; body)</h2></a><div class="section doc" data-reactid="1138">binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.</div><div class="section" data-reactid="1139"><a href="../clj/clojure.core/binding.html" data-reactid="1140"><h3 data-reactid="1141">+ Source</h3></a></div></div><div class="var-info" data-reactid="1142"><a href="../clj/clojure.core/bit-and.html" data-reactid="1143"><h2 data-reactid="1144">(bit-and x y)</h2><h2 data-reactid="1145">(bit-and x y &amp; more)</h2></a><div class="section doc" data-reactid="1146">Bitwise and</div><div class="section" data-reactid="1147"><a href="../clj/clojure.core/bit-and.html" data-reactid="1148"><h3 data-reactid="1149">+ Source</h3></a></div></div><div class="var-info" data-reactid="1150"><a href="../clj/clojure.core/bit-and-not.html" data-reactid="1151"><h2 data-reactid="1152">(bit-and-not x y)</h2><h2 data-reactid="1153">(bit-and-not x y &amp; more)</h2></a><div class="section doc" data-reactid="1154">Bitwise and with complement</div><div class="section" data-reactid="1155"><a href="../clj/clojure.core/bit-and-not.html" data-reactid="1156"><h3 data-reactid="1157">+ Source</h3></a></div></div><div class="var-info" data-reactid="1158"><a href="../clj/clojure.core/bit-clear.html" data-reactid="1159"><h2 data-reactid="1160">(bit-clear x n)</h2></a><div class="section doc" data-reactid="1161">Clear bit at index n</div><div class="section" data-reactid="1162"><a href="../clj/clojure.core/bit-clear.html" data-reactid="1163"><h3 data-reactid="1164">+ Source</h3></a></div></div><div class="var-info" data-reactid="1165"><a href="../clj/clojure.core/bit-flip.html" data-reactid="1166"><h2 data-reactid="1167">(bit-flip x n)</h2></a><div class="section doc" data-reactid="1168">Flip bit at index n</div><div class="section" data-reactid="1169"><a href="../clj/clojure.core/bit-flip.html" data-reactid="1170"><h3 data-reactid="1171">+ Source</h3></a></div></div><div class="var-info" data-reactid="1172"><a href="../clj/clojure.core/bit-not.html" data-reactid="1173"><h2 data-reactid="1174">(bit-not x)</h2></a><div class="section doc" data-reactid="1175">Bitwise complement</div><div class="section" data-reactid="1176"><a href="../clj/clojure.core/bit-not.html" data-reactid="1177"><h3 data-reactid="1178">+ Source</h3></a></div></div><div class="var-info" data-reactid="1179"><a href="../clj/clojure.core/bit-or.html" data-reactid="1180"><h2 data-reactid="1181">(bit-or x y)</h2><h2 data-reactid="1182">(bit-or x y &amp; more)</h2></a><div class="section doc" data-reactid="1183">Bitwise or</div><div class="section" data-reactid="1184"><a href="../clj/clojure.core/bit-or.html" data-reactid="1185"><h3 data-reactid="1186">+ Source</h3></a></div></div><div class="var-info" data-reactid="1187"><a href="../clj/clojure.core/bit-set.html" data-reactid="1188"><h2 data-reactid="1189">(bit-set x n)</h2></a><div class="section doc" data-reactid="1190">Set bit at index n</div><div class="section" data-reactid="1191"><a href="../clj/clojure.core/bit-set.html" data-reactid="1192"><h3 data-reactid="1193">+ Source</h3></a></div></div><div class="var-info" data-reactid="1194"><a href="../clj/clojure.core/bit-shift-left.html" data-reactid="1195"><h2 data-reactid="1196">(bit-shift-left x n)</h2></a><div class="section doc" data-reactid="1197">Bitwise shift left</div><div class="section" data-reactid="1198"><a href="../clj/clojure.core/bit-shift-left.html" data-reactid="1199"><h3 data-reactid="1200">+ Source</h3></a></div></div><div class="var-info" data-reactid="1201"><a href="../clj/clojure.core/bit-shift-right.html" data-reactid="1202"><h2 data-reactid="1203">(bit-shift-right x n)</h2></a><div class="section doc" data-reactid="1204">Bitwise shift right</div><div class="section" data-reactid="1205"><a href="../clj/clojure.core/bit-shift-right.html" data-reactid="1206"><h3 data-reactid="1207">+ Source</h3></a></div></div><div class="var-info" data-reactid="1208"><a href="../clj/clojure.core/bit-test.html" data-reactid="1209"><h2 data-reactid="1210">(bit-test x n)</h2></a><div class="section doc" data-reactid="1211">Test bit at index n</div><div class="section" data-reactid="1212"><a href="../clj/clojure.core/bit-test.html" data-reactid="1213"><h3 data-reactid="1214">+ Source</h3></a></div></div><div class="var-info" data-reactid="1215"><a href="../clj/clojure.core/bit-xor.html" data-reactid="1216"><h2 data-reactid="1217">(bit-xor x y)</h2><h2 data-reactid="1218">(bit-xor x y &amp; more)</h2></a><div class="section doc" data-reactid="1219">Bitwise exclusive or</div><div class="section" data-reactid="1220"><a href="../clj/clojure.core/bit-xor.html" data-reactid="1221"><h3 data-reactid="1222">+ Source</h3></a></div></div><div class="var-info" data-reactid="1223"><a href="../clj/clojure.core/boolean.html" data-reactid="1224"><h2 data-reactid="1225">(boolean x)</h2></a><div class="section doc" data-reactid="1226">Coerce to boolean</div><div class="section" data-reactid="1227"><a href="../clj/clojure.core/boolean.html" data-reactid="1228"><h3 data-reactid="1229">+ Source</h3></a></div></div><div class="var-info" data-reactid="1230"><a href="../clj/clojure.core/boolean-array.html" data-reactid="1231"><h2 data-reactid="1232">(boolean-array size-or-seq)</h2><h2 data-reactid="1233">(boolean-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="1234">Creates an array of booleans</div><div class="section" data-reactid="1235"><a href="../clj/clojure.core/boolean-array.html" data-reactid="1236"><h3 data-reactid="1237">+ Source</h3></a></div></div><div class="var-info" data-reactid="1238"><a href="../clj/clojure.core/boolean&#x27;q&#x27;.html" data-reactid="1239"><h2 data-reactid="1240">(boolean? x)</h2></a><div class="section doc" data-reactid="1241">Return true if x is a Boolean</div><div class="section" data-reactid="1242"><a href="../clj/clojure.core/boolean&#x27;q&#x27;.html" data-reactid="1243"><h3 data-reactid="1244">+ Source</h3></a></div></div><div class="var-info" data-reactid="1245"><a href="../clj/clojure.core/booleans.html" data-reactid="1246"><h2 data-reactid="1247">(booleans xs)</h2></a><div class="section doc" data-reactid="1248">Casts to boolean[]</div><div class="section" data-reactid="1249"><a href="../clj/clojure.core/booleans.html" data-reactid="1250"><h3 data-reactid="1251">+ Source</h3></a></div></div><div class="var-info" data-reactid="1252"><a href="../clj/clojure.core/bound-fn.html" data-reactid="1253"><h2 data-reactid="1254">(bound-fn &amp; fntail)</h2></a><div class="section doc" data-reactid="1255">Returns a function defined by the given fntail, which will install the
  same bindings in effect as in the thread at the time bound-fn was called.
  This may be used to define a helper function which runs on a different
  thread, but needs the same bindings in place.</div><div class="section" data-reactid="1256"><a href="../clj/clojure.core/bound-fn.html" data-reactid="1257"><h3 data-reactid="1258">+ Source</h3></a></div></div><div class="var-info" data-reactid="1259"><a href="../clj/clojure.core/bound-fn&#x27;a&#x27;.html" data-reactid="1260"><h2 data-reactid="1261">(bound-fn* f)</h2></a><div class="section doc" data-reactid="1262">Returns a function, which will install the same bindings in effect as in
  the thread at the time bound-fn* was called and then call f with any given
  arguments. This may be used to define a helper function which runs on a
  different thread, but needs the same bindings in place.</div><div class="section" data-reactid="1263"><a href="../clj/clojure.core/bound-fn&#x27;a&#x27;.html" data-reactid="1264"><h3 data-reactid="1265">+ Source</h3></a></div></div><div class="var-info" data-reactid="1266"><a href="../clj/clojure.core/bound&#x27;q&#x27;.html" data-reactid="1267"><h2 data-reactid="1268">(bound? &amp; vars)</h2></a><div class="section doc" data-reactid="1269">Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref&#x27;ing the provided vars will succeed. Returns true if no vars are provided.</div><div class="section" data-reactid="1270"><a href="../clj/clojure.core/bound&#x27;q&#x27;.html" data-reactid="1271"><h3 data-reactid="1272">+ Source</h3></a></div></div><div class="var-info" data-reactid="1273"><a href="../clj/clojure.core/bounded-count.html" data-reactid="1274"><h2 data-reactid="1275">(bounded-count n coll)</h2></a><div class="section doc" data-reactid="1276">If coll is counted? returns its count, else will count at most the first n
  elements of coll using its seq</div><div class="section" data-reactid="1277"><a href="../clj/clojure.core/bounded-count.html" data-reactid="1278"><h3 data-reactid="1279">+ Source</h3></a></div></div><div class="var-info" data-reactid="1280"><a href="../clj/clojure.core/butlast.html" data-reactid="1281"><h2 data-reactid="1282">(butlast coll)</h2></a><div class="section doc" data-reactid="1283">Return a seq of all but the last item in coll, in linear time</div><div class="section" data-reactid="1284"><a href="../clj/clojure.core/butlast.html" data-reactid="1285"><h3 data-reactid="1286">+ Source</h3></a></div></div><div class="var-info" data-reactid="1287"><a href="../clj/clojure.core/byte.html" data-reactid="1288"><h2 data-reactid="1289">(byte x)</h2></a><div class="section doc" data-reactid="1290">Coerce to byte</div><div class="section" data-reactid="1291"><a href="../clj/clojure.core/byte.html" data-reactid="1292"><h3 data-reactid="1293">+ Source</h3></a></div></div><div class="var-info" data-reactid="1294"><a href="../clj/clojure.core/byte-array.html" data-reactid="1295"><h2 data-reactid="1296">(byte-array size-or-seq)</h2><h2 data-reactid="1297">(byte-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="1298">Creates an array of bytes</div><div class="section" data-reactid="1299"><a href="../clj/clojure.core/byte-array.html" data-reactid="1300"><h3 data-reactid="1301">+ Source</h3></a></div></div><div class="var-info" data-reactid="1302"><a href="../clj/clojure.core/bytes.html" data-reactid="1303"><h2 data-reactid="1304">(bytes xs)</h2></a><div class="section doc" data-reactid="1305">Casts to bytes[]</div><div class="section" data-reactid="1306"><a href="../clj/clojure.core/bytes.html" data-reactid="1307"><h3 data-reactid="1308">+ Source</h3></a></div></div><div class="var-info" data-reactid="1309"><a href="../clj/clojure.core/bytes&#x27;q&#x27;.html" data-reactid="1310"><h2 data-reactid="1311">(bytes? x)</h2></a><div class="section doc" data-reactid="1312">Return true if x is a byte array</div><div class="section" data-reactid="1313"><a href="../clj/clojure.core/bytes&#x27;q&#x27;.html" data-reactid="1314"><h3 data-reactid="1315">+ Source</h3></a></div></div><div class="var-info" data-reactid="1316"><a href="../clj/clojure.core/case.html" data-reactid="1317"><h2 data-reactid="1318">(case e &amp; clauses)</h2></a><div class="section doc" data-reactid="1319">Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.</div><div class="section" data-reactid="1320"><a href="../clj/clojure.core/case.html" data-reactid="1321"><h3 data-reactid="1322">+ Source</h3></a></div></div><div class="var-info" data-reactid="1323"><a href="../clj/clojure.core/cast.html" data-reactid="1324"><h2 data-reactid="1325">(cast c x)</h2></a><div class="section doc" data-reactid="1326">Throws a ClassCastException if x is not a c, else returns x.</div><div class="section" data-reactid="1327"><a href="../clj/clojure.core/cast.html" data-reactid="1328"><h3 data-reactid="1329">+ Source</h3></a></div></div><div class="var-info" data-reactid="1330"><a href="../clj/clojure.core/cat.html" data-reactid="1331"><h2 data-reactid="1332">(cat rf)</h2></a><div class="section doc" data-reactid="1333">A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.</div><div class="section" data-reactid="1334"><a href="../clj/clojure.core/cat.html" data-reactid="1335"><h3 data-reactid="1336">+ Source</h3></a></div></div><div class="var-info" data-reactid="1337"><a href="../clj/clojure.core/char.html" data-reactid="1338"><h2 data-reactid="1339">(char x)</h2></a><div class="section doc" data-reactid="1340">Coerce to char</div><div class="section" data-reactid="1341"><a href="../clj/clojure.core/char.html" data-reactid="1342"><h3 data-reactid="1343">+ Source</h3></a></div></div><div class="var-info" data-reactid="1344"><a href="../clj/clojure.core/char-array.html" data-reactid="1345"><h2 data-reactid="1346">(char-array size-or-seq)</h2><h2 data-reactid="1347">(char-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="1348">Creates an array of chars</div><div class="section" data-reactid="1349"><a href="../clj/clojure.core/char-array.html" data-reactid="1350"><h3 data-reactid="1351">+ Source</h3></a></div></div><div class="var-info" data-reactid="1352"><a href="../clj/clojure.core/char-escape-string.html" data-reactid="1353"><h2 data-reactid="1354">char-escape-string</h2></a><div class="section doc" data-reactid="1355">Returns escape string for char or nil if none</div><div class="section" data-reactid="1356"><a href="../clj/clojure.core/char-escape-string.html" data-reactid="1357"><h3 data-reactid="1358">+ Source</h3></a></div></div><div class="var-info" data-reactid="1359"><a href="../clj/clojure.core/char-name-string.html" data-reactid="1360"><h2 data-reactid="1361">char-name-string</h2></a><div class="section doc" data-reactid="1362">Returns name string for char or nil if none</div><div class="section" data-reactid="1363"><a href="../clj/clojure.core/char-name-string.html" data-reactid="1364"><h3 data-reactid="1365">+ Source</h3></a></div></div><div class="var-info" data-reactid="1366"><a href="../clj/clojure.core/char&#x27;q&#x27;.html" data-reactid="1367"><h2 data-reactid="1368">(char? x)</h2></a><div class="section doc" data-reactid="1369">Return true if x is a Character</div><div class="section" data-reactid="1370"><a href="../clj/clojure.core/char&#x27;q&#x27;.html" data-reactid="1371"><h3 data-reactid="1372">+ Source</h3></a></div></div><div class="var-info" data-reactid="1373"><a href="../clj/clojure.core/chars.html" data-reactid="1374"><h2 data-reactid="1375">(chars xs)</h2></a><div class="section doc" data-reactid="1376">Casts to chars[]</div><div class="section" data-reactid="1377"><a href="../clj/clojure.core/chars.html" data-reactid="1378"><h3 data-reactid="1379">+ Source</h3></a></div></div><div class="var-info" data-reactid="1380"><a href="../clj/clojure.core/chunk.html" data-reactid="1381"><h2 data-reactid="1382">(chunk b)</h2></a><div class="section" data-reactid="1383"><a href="../clj/clojure.core/chunk.html" data-reactid="1384"><h3 data-reactid="1385">+ Source</h3></a></div></div><div class="var-info" data-reactid="1386"><a href="../clj/clojure.core/chunk-append.html" data-reactid="1387"><h2 data-reactid="1388">(chunk-append b x)</h2></a><div class="section" data-reactid="1389"><a href="../clj/clojure.core/chunk-append.html" data-reactid="1390"><h3 data-reactid="1391">+ Source</h3></a></div></div><div class="var-info" data-reactid="1392"><a href="../clj/clojure.core/chunk-buffer.html" data-reactid="1393"><h2 data-reactid="1394">(chunk-buffer capacity)</h2></a><div class="section" data-reactid="1395"><a href="../clj/clojure.core/chunk-buffer.html" data-reactid="1396"><h3 data-reactid="1397">+ Source</h3></a></div></div><div class="var-info" data-reactid="1398"><a href="../clj/clojure.core/chunk-cons.html" data-reactid="1399"><h2 data-reactid="1400">(chunk-cons chunk rest)</h2></a><div class="section" data-reactid="1401"><a href="../clj/clojure.core/chunk-cons.html" data-reactid="1402"><h3 data-reactid="1403">+ Source</h3></a></div></div><div class="var-info" data-reactid="1404"><a href="../clj/clojure.core/chunk-first.html" data-reactid="1405"><h2 data-reactid="1406">(chunk-first s)</h2></a><div class="section" data-reactid="1407"><a href="../clj/clojure.core/chunk-first.html" data-reactid="1408"><h3 data-reactid="1409">+ Source</h3></a></div></div><div class="var-info" data-reactid="1410"><a href="../clj/clojure.core/chunk-next.html" data-reactid="1411"><h2 data-reactid="1412">(chunk-next s)</h2></a><div class="section" data-reactid="1413"><a href="../clj/clojure.core/chunk-next.html" data-reactid="1414"><h3 data-reactid="1415">+ Source</h3></a></div></div><div class="var-info" data-reactid="1416"><a href="../clj/clojure.core/chunk-rest.html" data-reactid="1417"><h2 data-reactid="1418">(chunk-rest s)</h2></a><div class="section" data-reactid="1419"><a href="../clj/clojure.core/chunk-rest.html" data-reactid="1420"><h3 data-reactid="1421">+ Source</h3></a></div></div><div class="var-info" data-reactid="1422"><a href="../clj/clojure.core/chunked-seq&#x27;q&#x27;.html" data-reactid="1423"><h2 data-reactid="1424">(chunked-seq? s)</h2></a><div class="section" data-reactid="1425"><a href="../clj/clojure.core/chunked-seq&#x27;q&#x27;.html" data-reactid="1426"><h3 data-reactid="1427">+ Source</h3></a></div></div><div class="var-info" data-reactid="1428"><a href="../clj/clojure.core/class.html" data-reactid="1429"><h2 data-reactid="1430">(class x)</h2></a><div class="section doc" data-reactid="1431">Returns the Class of x</div><div class="section" data-reactid="1432"><a href="../clj/clojure.core/class.html" data-reactid="1433"><h3 data-reactid="1434">+ Source</h3></a></div></div><div class="var-info" data-reactid="1435"><a href="../clj/clojure.core/class&#x27;q&#x27;.html" data-reactid="1436"><h2 data-reactid="1437">(class? x)</h2></a><div class="section doc" data-reactid="1438">Returns true if x is an instance of Class</div><div class="section" data-reactid="1439"><a href="../clj/clojure.core/class&#x27;q&#x27;.html" data-reactid="1440"><h3 data-reactid="1441">+ Source</h3></a></div></div><div class="var-info" data-reactid="1442"><a href="../clj/clojure.core/clear-agent-errors.html" data-reactid="1443"><h2 data-reactid="1444">(clear-agent-errors a)</h2></a><div class="section doc" data-reactid="1445">DEPRECATED: Use &#x27;restart-agent&#x27; instead.
  Clears any exceptions thrown during asynchronous actions of the
  agent, allowing subsequent actions to occur.</div><div class="section" data-reactid="1446"><a href="../clj/clojure.core/clear-agent-errors.html" data-reactid="1447"><h3 data-reactid="1448">+ Source</h3></a></div></div><div class="var-info" data-reactid="1449"><a href="../clj/clojure.core/clojure-version.html" data-reactid="1450"><h2 data-reactid="1451">(clojure-version)</h2></a><div class="section doc" data-reactid="1452">Returns clojure version as a printable string.</div><div class="section" data-reactid="1453"><a href="../clj/clojure.core/clojure-version.html" data-reactid="1454"><h3 data-reactid="1455">+ Source</h3></a></div></div><div class="var-info" data-reactid="1456"><a href="../clj/clojure.core/coll&#x27;q&#x27;.html" data-reactid="1457"><h2 data-reactid="1458">(coll? x)</h2></a><div class="section doc" data-reactid="1459">Returns true if x implements IPersistentCollection</div><div class="section" data-reactid="1460"><a href="../clj/clojure.core/coll&#x27;q&#x27;.html" data-reactid="1461"><h3 data-reactid="1462">+ Source</h3></a></div></div><div class="var-info" data-reactid="1463"><a href="../clj/clojure.core/comment.html" data-reactid="1464"><h2 data-reactid="1465">(comment &amp; body)</h2></a><div class="section doc" data-reactid="1466">Ignores body, yields nil</div><div class="section" data-reactid="1467"><a href="../clj/clojure.core/comment.html" data-reactid="1468"><h3 data-reactid="1469">+ Source</h3></a></div></div><div class="var-info" data-reactid="1470"><a href="../clj/clojure.core/commute.html" data-reactid="1471"><h2 data-reactid="1472">(commute ref fun &amp; args)</h2></a><div class="section doc" data-reactid="1473">Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.</div><div class="section" data-reactid="1474"><a href="../clj/clojure.core/commute.html" data-reactid="1475"><h3 data-reactid="1476">+ Source</h3></a></div></div><div class="var-info" data-reactid="1477"><a href="../clj/clojure.core/comp.html" data-reactid="1478"><h2 data-reactid="1479">(comp)</h2><h2 data-reactid="1480">(comp f)</h2><h2 data-reactid="1481">(comp f g)</h2><h2 data-reactid="1482">(comp f g &amp; fs)</h2></a><div class="section doc" data-reactid="1483">Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.</div><div class="section" data-reactid="1484"><a href="../clj/clojure.core/comp.html" data-reactid="1485"><h3 data-reactid="1486">+ Source</h3></a></div></div><div class="var-info" data-reactid="1487"><a href="../clj/clojure.core/comparator.html" data-reactid="1488"><h2 data-reactid="1489">(comparator pred)</h2></a><div class="section doc" data-reactid="1490">Returns an implementation of java.util.Comparator based upon pred.</div><div class="section" data-reactid="1491"><a href="../clj/clojure.core/comparator.html" data-reactid="1492"><h3 data-reactid="1493">+ Source</h3></a></div></div><div class="var-info" data-reactid="1494"><a href="../clj/clojure.core/compare.html" data-reactid="1495"><h2 data-reactid="1496">(compare x y)</h2></a><div class="section doc" data-reactid="1497">Comparator. Returns a negative number, zero, or a positive number
  when x is logically &#x27;less than&#x27;, &#x27;equal to&#x27;, or &#x27;greater than&#x27;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable</div><div class="section" data-reactid="1498"><a href="../clj/clojure.core/compare.html" data-reactid="1499"><h3 data-reactid="1500">+ Source</h3></a></div></div><div class="var-info" data-reactid="1501"><a href="../clj/clojure.core/compare-and-set&#x27;e&#x27;.html" data-reactid="1502"><h2 data-reactid="1503">(compare-and-set! atom oldval newval)</h2></a><div class="section doc" data-reactid="1504">Atomically sets the value of atom to newval if and only if the
  current value of the atom is identical to oldval. Returns true if
  set happened, else false</div><div class="section" data-reactid="1505"><a href="../clj/clojure.core/compare-and-set&#x27;e&#x27;.html" data-reactid="1506"><h3 data-reactid="1507">+ Source</h3></a></div></div><div class="var-info" data-reactid="1508"><a href="../clj/clojure.core/compile.html" data-reactid="1509"><h2 data-reactid="1510">(compile lib)</h2></a><div class="section doc" data-reactid="1511">Compiles the namespace named by the symbol lib into a set of
  classfiles. The source for the lib must be in a proper
  classpath-relative directory. The output files will go into the
  directory specified by *compile-path*, and that directory too must
  be in the classpath.</div><div class="section" data-reactid="1512"><a href="../clj/clojure.core/compile.html" data-reactid="1513"><h3 data-reactid="1514">+ Source</h3></a></div></div><div class="var-info" data-reactid="1515"><a href="../clj/clojure.core/complement.html" data-reactid="1516"><h2 data-reactid="1517">(complement f)</h2></a><div class="section doc" data-reactid="1518">Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.</div><div class="section" data-reactid="1519"><a href="../clj/clojure.core/complement.html" data-reactid="1520"><h3 data-reactid="1521">+ Source</h3></a></div></div><div class="var-info" data-reactid="1522"><a href="../clj/clojure.core/completing.html" data-reactid="1523"><h2 data-reactid="1524">(completing f)</h2><h2 data-reactid="1525">(completing f cf)</h2></a><div class="section doc" data-reactid="1526">Takes a reducing function f of 2 args and returns a fn suitable for
  transduce by adding an arity-1 signature that calls cf (default -
  identity) on the result argument.</div><div class="section" data-reactid="1527"><a href="../clj/clojure.core/completing.html" data-reactid="1528"><h3 data-reactid="1529">+ Source</h3></a></div></div><div class="var-info" data-reactid="1530"><a href="../clj/clojure.core/concat.html" data-reactid="1531"><h2 data-reactid="1532">(concat)</h2><h2 data-reactid="1533">(concat x)</h2><h2 data-reactid="1534">(concat x y)</h2><h2 data-reactid="1535">(concat x y &amp; zs)</h2></a><div class="section doc" data-reactid="1536">Returns a lazy seq representing the concatenation of the elements in the supplied colls.</div><div class="section" data-reactid="1537"><a href="../clj/clojure.core/concat.html" data-reactid="1538"><h3 data-reactid="1539">+ Source</h3></a></div></div><div class="var-info" data-reactid="1540"><a href="../clj/clojure.core/cond.html" data-reactid="1541"><h2 data-reactid="1542">(cond &amp; clauses)</h2></a><div class="section doc" data-reactid="1543">Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&#x27;t evaluate any of the
  other tests or exprs. (cond) returns nil.</div><div class="section" data-reactid="1544"><a href="../clj/clojure.core/cond.html" data-reactid="1545"><h3 data-reactid="1546">+ Source</h3></a></div></div><div class="var-info" data-reactid="1547"><a href="../clj/clojure.core/cond-&#x27;g&#x27;.html" data-reactid="1548"><h2 data-reactid="1549">(cond-&gt; expr &amp; clauses)</h2></a><div class="section doc" data-reactid="1550">Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression.</div><div class="section" data-reactid="1551"><a href="../clj/clojure.core/cond-&#x27;g&#x27;.html" data-reactid="1552"><h3 data-reactid="1553">+ Source</h3></a></div></div><div class="var-info" data-reactid="1554"><a href="../clj/clojure.core/cond-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="1555"><h2 data-reactid="1556">(cond-&gt;&gt; expr &amp; clauses)</h2></a><div class="section doc" data-reactid="1557">Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression.</div><div class="section" data-reactid="1558"><a href="../clj/clojure.core/cond-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="1559"><h3 data-reactid="1560">+ Source</h3></a></div></div><div class="var-info" data-reactid="1561"><a href="../clj/clojure.core/condp.html" data-reactid="1562"><h2 data-reactid="1563">(condp pred expr &amp; clauses)</h2></a><div class="section doc" data-reactid="1564">Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :&gt;&gt; result-fn

  Note :&gt;&gt; is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.</div><div class="section" data-reactid="1565"><a href="../clj/clojure.core/condp.html" data-reactid="1566"><h3 data-reactid="1567">+ Source</h3></a></div></div><div class="var-info" data-reactid="1568"><a href="../clj/clojure.core/conj.html" data-reactid="1569"><h2 data-reactid="1570">(conj coll x)</h2><h2 data-reactid="1571">(conj coll x &amp; xs)</h2></a><div class="section doc" data-reactid="1572">conj[oin]. Returns a new collection with the xs
    &#x27;added&#x27;. (conj nil item) returns (item).  The &#x27;addition&#x27; may
    happen at different &#x27;places&#x27; depending on the concrete type.</div><div class="section" data-reactid="1573"><a href="../clj/clojure.core/conj.html" data-reactid="1574"><h3 data-reactid="1575">+ Source</h3></a></div></div><div class="var-info" data-reactid="1576"><a href="../clj/clojure.core/conj&#x27;e&#x27;.html" data-reactid="1577"><h2 data-reactid="1578">(conj!)</h2><h2 data-reactid="1579">(conj! coll)</h2><h2 data-reactid="1580">(conj! coll x)</h2></a><div class="section doc" data-reactid="1581">Adds x to the transient collection, and return coll. The &#x27;addition&#x27;
  may happen at different &#x27;places&#x27; depending on the concrete type.</div><div class="section" data-reactid="1582"><a href="../clj/clojure.core/conj&#x27;e&#x27;.html" data-reactid="1583"><h3 data-reactid="1584">+ Source</h3></a></div></div><div class="var-info" data-reactid="1585"><a href="../clj/clojure.core/cons.html" data-reactid="1586"><h2 data-reactid="1587">(cons x seq)</h2></a><div class="section doc" data-reactid="1588">Returns a new seq where x is the first element and seq is
    the rest.</div><div class="section" data-reactid="1589"><a href="../clj/clojure.core/cons.html" data-reactid="1590"><h3 data-reactid="1591">+ Source</h3></a></div></div><div class="var-info" data-reactid="1592"><a href="../clj/clojure.core/constantly.html" data-reactid="1593"><h2 data-reactid="1594">(constantly x)</h2></a><div class="section doc" data-reactid="1595">Returns a function that takes any number of arguments and returns x.</div><div class="section" data-reactid="1596"><a href="../clj/clojure.core/constantly.html" data-reactid="1597"><h3 data-reactid="1598">+ Source</h3></a></div></div><div class="var-info" data-reactid="1599"><a href="../clj/clojure.core/construct-proxy.html" data-reactid="1600"><h2 data-reactid="1601">(construct-proxy c &amp; ctor-args)</h2></a><div class="section doc" data-reactid="1602">Takes a proxy class and any arguments for its superclass ctor and
  creates and returns an instance of the proxy.</div><div class="section" data-reactid="1603"><a href="../clj/clojure.core/construct-proxy.html" data-reactid="1604"><h3 data-reactid="1605">+ Source</h3></a></div></div><div class="var-info" data-reactid="1606"><a href="../clj/clojure.core/contains&#x27;q&#x27;.html" data-reactid="1607"><h2 data-reactid="1608">(contains? coll key)</h2></a><div class="section doc" data-reactid="1609">Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &#x27;contains?&#x27; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &#x27;some&#x27;.</div><div class="section" data-reactid="1610"><a href="../clj/clojure.core/contains&#x27;q&#x27;.html" data-reactid="1611"><h3 data-reactid="1612">+ Source</h3></a></div></div><div class="var-info" data-reactid="1613"><a href="../clj/clojure.core/count.html" data-reactid="1614"><h2 data-reactid="1615">(count coll)</h2></a><div class="section doc" data-reactid="1616">Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps</div><div class="section" data-reactid="1617"><a href="../clj/clojure.core/count.html" data-reactid="1618"><h3 data-reactid="1619">+ Source</h3></a></div></div><div class="var-info" data-reactid="1620"><a href="../clj/clojure.core/counted&#x27;q&#x27;.html" data-reactid="1621"><h2 data-reactid="1622">(counted? coll)</h2></a><div class="section doc" data-reactid="1623">Returns true if coll implements count in constant time</div><div class="section" data-reactid="1624"><a href="../clj/clojure.core/counted&#x27;q&#x27;.html" data-reactid="1625"><h3 data-reactid="1626">+ Source</h3></a></div></div><div class="var-info" data-reactid="1627"><a href="../clj/clojure.core/create-ns.html" data-reactid="1628"><h2 data-reactid="1629">(create-ns sym)</h2></a><div class="section doc" data-reactid="1630">Create a new namespace named by the symbol if one doesn&#x27;t already
  exist, returns it or the already-existing namespace of the same
  name.</div><div class="section" data-reactid="1631"><a href="../clj/clojure.core/create-ns.html" data-reactid="1632"><h3 data-reactid="1633">+ Source</h3></a></div></div><div class="var-info" data-reactid="1634"><a href="../clj/clojure.core/create-struct.html" data-reactid="1635"><h2 data-reactid="1636">(create-struct &amp; keys)</h2></a><div class="section doc" data-reactid="1637">Returns a structure basis object.</div><div class="section" data-reactid="1638"><a href="../clj/clojure.core/create-struct.html" data-reactid="1639"><h3 data-reactid="1640">+ Source</h3></a></div></div><div class="var-info" data-reactid="1641"><a href="../clj/clojure.core/cycle.html" data-reactid="1642"><h2 data-reactid="1643">(cycle coll)</h2></a><div class="section doc" data-reactid="1644">Returns a lazy (infinite!) sequence of repetitions of the items in coll.</div><div class="section" data-reactid="1645"><a href="../clj/clojure.core/cycle.html" data-reactid="1646"><h3 data-reactid="1647">+ Source</h3></a></div></div><div class="var-info" data-reactid="1648"><a href="../clj/clojure.core/dec.html" data-reactid="1649"><h2 data-reactid="1650">(dec x)</h2></a><div class="section doc" data-reactid="1651">Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&#x27;</div><div class="section" data-reactid="1652"><a href="../clj/clojure.core/dec.html" data-reactid="1653"><h3 data-reactid="1654">+ Source</h3></a></div></div><div class="var-info" data-reactid="1655"><a href="../clj/clojure.core/dec&#x27;.html" data-reactid="1656"><h2 data-reactid="1657">(dec&#x27; x)</h2></a><div class="section doc" data-reactid="1658">Returns a number one less than num. Supports arbitrary precision.
  See also: dec</div><div class="section" data-reactid="1659"><a href="../clj/clojure.core/dec&#x27;.html" data-reactid="1660"><h3 data-reactid="1661">+ Source</h3></a></div></div><div class="var-info" data-reactid="1662"><a href="../clj/clojure.core/decimal&#x27;q&#x27;.html" data-reactid="1663"><h2 data-reactid="1664">(decimal? n)</h2></a><div class="section doc" data-reactid="1665">Returns true if n is a BigDecimal</div><div class="section" data-reactid="1666"><a href="../clj/clojure.core/decimal&#x27;q&#x27;.html" data-reactid="1667"><h3 data-reactid="1668">+ Source</h3></a></div></div><div class="var-info" data-reactid="1669"><a href="../clj/clojure.core/declare.html" data-reactid="1670"><h2 data-reactid="1671">(declare &amp; names)</h2></a><div class="section doc" data-reactid="1672">defs the supplied var names with no bindings, useful for making forward declarations.</div><div class="section" data-reactid="1673"><a href="../clj/clojure.core/declare.html" data-reactid="1674"><h3 data-reactid="1675">+ Source</h3></a></div></div><div class="var-info" data-reactid="1676"><a href="../clj/clojure.core/dedupe.html" data-reactid="1677"><h2 data-reactid="1678">(dedupe)</h2><h2 data-reactid="1679">(dedupe coll)</h2></a><div class="section doc" data-reactid="1680">Returns a lazy sequence removing consecutive duplicates in coll.
  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="1681"><a href="../clj/clojure.core/dedupe.html" data-reactid="1682"><h3 data-reactid="1683">+ Source</h3></a></div></div><div class="var-info" data-reactid="1684"><a href="../clj/clojure.core/default-data-readers.html" data-reactid="1685"><h2 data-reactid="1686">default-data-readers</h2></a><div class="section doc" data-reactid="1687">Default map of data reader functions provided by Clojure. May be
  overridden by binding *data-readers*.</div><div class="section" data-reactid="1688"><a href="../clj/clojure.core/default-data-readers.html" data-reactid="1689"><h3 data-reactid="1690">+ Source</h3></a></div></div><div class="var-info" data-reactid="1691"><a href="../clj/clojure.core/definline.html" data-reactid="1692"><h2 data-reactid="1693">(definline name &amp; decl)</h2></a><div class="section doc" data-reactid="1694">Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.</div><div class="section" data-reactid="1695"><a href="../clj/clojure.core/definline.html" data-reactid="1696"><h3 data-reactid="1697">+ Source</h3></a></div></div><div class="var-info" data-reactid="1698"><a href="../clj/clojure.core/definterface.html" data-reactid="1699"><h2 data-reactid="1700">(definterface name &amp; sigs)</h2></a><div class="section doc" data-reactid="1701">Creates a new Java interface with the given name and method sigs.
  The method return types and parameter types may be specified with type hints,
  defaulting to Object if omitted.

  (definterface MyInterface
    (^int method1 [x])
    (^Bar method2 [^Baz b ^Quux q]))</div><div class="section" data-reactid="1702"><a href="../clj/clojure.core/definterface.html" data-reactid="1703"><h3 data-reactid="1704">+ Source</h3></a></div></div><div class="var-info" data-reactid="1705"><a href="../clj/clojure.core/defmacro.html" data-reactid="1706"><h2 data-reactid="1707">(defmacro name doc-string? attr-map? [params*] body)</h2><h2 data-reactid="1708">(defmacro name doc-string? attr-map? ([params*] body) + attr-map?)</h2></a><div class="section doc" data-reactid="1709">Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.</div><div class="section" data-reactid="1710"><a href="../clj/clojure.core/defmacro.html" data-reactid="1711"><h3 data-reactid="1712">+ Source</h3></a></div></div><div class="var-info" data-reactid="1713"><a href="../clj/clojure.core/defmethod.html" data-reactid="1714"><h2 data-reactid="1715">(defmethod multifn dispatch-val &amp; fn-tail)</h2></a><div class="section doc" data-reactid="1716">Creates and installs a new method of multimethod associated with dispatch-value. </div><div class="section" data-reactid="1717"><a href="../clj/clojure.core/defmethod.html" data-reactid="1718"><h3 data-reactid="1719">+ Source</h3></a></div></div><div class="var-info" data-reactid="1720"><a href="../clj/clojure.core/defmulti.html" data-reactid="1721"><h2 data-reactid="1722">(defmulti name docstring? attr-map? dispatch-fn &amp; options)</h2></a><div class="section doc" data-reactid="1723">Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure&#x27;s multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #&#x27;
  or the var special form).</div><div class="section" data-reactid="1724"><a href="../clj/clojure.core/defmulti.html" data-reactid="1725"><h3 data-reactid="1726">+ Source</h3></a></div></div><div class="var-info" data-reactid="1727"><a href="../clj/clojure.core/defn.html" data-reactid="1728"><h2 data-reactid="1729">(defn name doc-string? attr-map? [params*] prepost-map? body)</h2><h2 data-reactid="1730">(defn name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</h2></a><div class="section doc" data-reactid="1731">Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.</div><div class="section" data-reactid="1732"><a href="../clj/clojure.core/defn.html" data-reactid="1733"><h3 data-reactid="1734">+ Spec</h3></a></div><div class="section" data-reactid="1735"><a href="../clj/clojure.core/defn.html" data-reactid="1736"><h3 data-reactid="1737">+ Source</h3></a></div></div><div class="var-info" data-reactid="1738"><a href="../clj/clojure.core/defn-.html" data-reactid="1739"><h2 data-reactid="1740">(defn- name &amp; decls)</h2></a><div class="section doc" data-reactid="1741">same as defn, yielding non-public def</div><div class="section" data-reactid="1742"><a href="../clj/clojure.core/defn-.html" data-reactid="1743"><h3 data-reactid="1744">+ Spec</h3></a></div><div class="section" data-reactid="1745"><a href="../clj/clojure.core/defn-.html" data-reactid="1746"><h3 data-reactid="1747">+ Source</h3></a></div></div><div class="var-info" data-reactid="1748"><a href="../clj/clojure.core/defonce.html" data-reactid="1749"><h2 data-reactid="1750">(defonce name expr)</h2></a><div class="section doc" data-reactid="1751">defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated</div><div class="section" data-reactid="1752"><a href="../clj/clojure.core/defonce.html" data-reactid="1753"><h3 data-reactid="1754">+ Source</h3></a></div></div><div class="var-info" data-reactid="1755"><a href="../clj/clojure.core/defprotocol.html" data-reactid="1756"><h2 data-reactid="1757">(defprotocol name &amp; opts+sigs)</h2></a><div class="section doc" data-reactid="1758">A protocol is a named set of named methods and their signatures:
  (defprotocol AProtocolName

    ;optional doc string
    &quot;A doc string for AProtocol abstraction&quot;

  ;method signatures
    (bar [this a b] &quot;bar docs&quot;)
    (baz [this a] [this a b] [this a b c] &quot;baz docs&quot;))

  No implementations are provided. Docs can be specified for the
  protocol overall and for each method. The above yields a set of
  polymorphic functions and a protocol object. All are
  namespace-qualified by the ns enclosing the definition The resulting
  functions dispatch on the type of their first argument, which is
  required and corresponds to the implicit target object (&#x27;this&#x27; in 
  Java parlance). defprotocol is dynamic, has no special compile-time 
  effect, and defines no new types or classes. Implementations of 
  the protocol methods can be provided using extend.

  defprotocol will automatically generate a corresponding interface,
  with the same name as the protocol, i.e. given a protocol:
  my.ns/Protocol, an interface: my.ns.Protocol. The interface will
  have methods corresponding to the protocol functions, and the
  protocol will automatically work with instances of the interface.

  Note that you should not use this interface with deftype or
  reify, as they support the protocol directly:

  (defprotocol P 
    (foo [this]) 
    (bar-me [this] [this y]))

  (deftype Foo [a b c] 
   P
    (foo [this] a)
    (bar-me [this] b)
    (bar-me [this y] (+ c y)))
  
  (bar-me (Foo. 1 2 3) 42)
  =&gt; 45

  (foo 
    (let [x 42]
      (reify P 
        (foo [this] 17)
        (bar-me [this] x)
        (bar-me [this y] x))))
  =&gt; 17</div><div class="section" data-reactid="1759"><a href="../clj/clojure.core/defprotocol.html" data-reactid="1760"><h3 data-reactid="1761">+ Source</h3></a></div></div><div class="var-info" data-reactid="1762"><a href="../clj/clojure.core/defrecord.html" data-reactid="1763"><h2 data-reactid="1764">(defrecord name [&amp; fields] &amp; opts+specs)</h2></a><div class="section doc" data-reactid="1765">(defrecord name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the record class will cause the
             namespace in which the record was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces.

  The class will have the (immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directly.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object (&#x27;this&#x27; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  The class will have implementations of several (clojure.lang)
  interfaces generated automatically: IObj (metadata support) and
  IPersistentMap, and all of their superinterfaces.

  In addition, defrecord will define type-and-value-based =,
  and will defined Java .hashCode and .equals consistent with the
  contract for java.util.Map.

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  Two constructors will be defined, one taking the designated fields
  followed by a metadata map (nil for none) and an extension field
  map (nil for none), and one taking only the fields (using nil for
  meta and extension fields). Note that the field names __meta,
  __extmap, __hash and __hasheq are currently reserved and should not
  be used when defining your own records.

  Given (defrecord TypeName ...), two factory functions will be
  defined: -&gt;TypeName, taking positional parameters for the fields,
  and map-&gt;TypeName, taking a map of keywords to field values.</div><div class="section" data-reactid="1766"><a href="../clj/clojure.core/defrecord.html" data-reactid="1767"><h3 data-reactid="1768">+ Source</h3></a></div></div><div class="var-info" data-reactid="1769"><a href="../clj/clojure.core/defstruct.html" data-reactid="1770"><h2 data-reactid="1771">(defstruct name &amp; keys)</h2></a><div class="section doc" data-reactid="1772">Same as (def name (create-struct keys...))</div><div class="section" data-reactid="1773"><a href="../clj/clojure.core/defstruct.html" data-reactid="1774"><h3 data-reactid="1775">+ Source</h3></a></div></div><div class="var-info" data-reactid="1776"><a href="../clj/clojure.core/deftype.html" data-reactid="1777"><h2 data-reactid="1778">(deftype name [&amp; fields] &amp; opts+specs)</h2></a><div class="section doc" data-reactid="1779">(deftype name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the type class will cause the
             namespace in which the type was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces. 

  The class will have the (by default, immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directly. Fields can be qualified
  with the metadata :volatile-mutable true or :unsynchronized-mutable
  true, at which point (set! afield aval) will be supported in method
  bodies. Note well that mutable fields are extremely difficult to use
  correctly, and are present only to facilitate the building of higher
  level constructs, such as Clojure&#x27;s reference types, in Clojure
  itself. They are for experts only - if the semantics and
  implications of :volatile-mutable or :unsynchronized-mutable are not
  immediately apparent to you, you should not be using them.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object (&#x27;this&#x27; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  One constructor will be defined, taking the designated fields.  Note
  that the field names __meta, __extmap, __hash and __hasheq are currently
  reserved and should not be used when defining your own types.

  Given (deftype TypeName ...), a factory function called -&gt;TypeName
  will be defined, taking positional parameters for the fields</div><div class="section" data-reactid="1780"><a href="../clj/clojure.core/deftype.html" data-reactid="1781"><h3 data-reactid="1782">+ Source</h3></a></div></div><div class="var-info" data-reactid="1783"><a href="../clj/clojure.core/delay.html" data-reactid="1784"><h2 data-reactid="1785">(delay &amp; body)</h2></a><div class="section doc" data-reactid="1786">Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?</div><div class="section" data-reactid="1787"><a href="../clj/clojure.core/delay.html" data-reactid="1788"><h3 data-reactid="1789">+ Source</h3></a></div></div><div class="var-info" data-reactid="1790"><a href="../clj/clojure.core/delay&#x27;q&#x27;.html" data-reactid="1791"><h2 data-reactid="1792">(delay? x)</h2></a><div class="section doc" data-reactid="1793">returns true if x is a Delay created with delay</div><div class="section" data-reactid="1794"><a href="../clj/clojure.core/delay&#x27;q&#x27;.html" data-reactid="1795"><h3 data-reactid="1796">+ Source</h3></a></div></div><div class="var-info" data-reactid="1797"><a href="../clj/clojure.core/deliver.html" data-reactid="1798"><h2 data-reactid="1799">(deliver promise val)</h2></a><div class="section doc" data-reactid="1800">Delivers the supplied value to the promise, releasing any pending
  derefs. A subsequent call to deliver on a promise will have no effect.</div><div class="section" data-reactid="1801"><a href="../clj/clojure.core/deliver.html" data-reactid="1802"><h3 data-reactid="1803">+ Source</h3></a></div></div><div class="var-info" data-reactid="1804"><a href="../clj/clojure.core/denominator.html" data-reactid="1805"><h2 data-reactid="1806">(denominator r)</h2></a><div class="section doc" data-reactid="1807">Returns the denominator part of a Ratio.</div><div class="section" data-reactid="1808"><a href="../clj/clojure.core/denominator.html" data-reactid="1809"><h3 data-reactid="1810">+ Source</h3></a></div></div><div class="var-info" data-reactid="1811"><a href="../clj/clojure.core/deref.html" data-reactid="1812"><h2 data-reactid="1813">(deref ref)</h2><h2 data-reactid="1814">(deref ref timeout-ms timeout-val)</h2></a><div class="section doc" data-reactid="1815">Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.</div><div class="section" data-reactid="1816"><a href="../clj/clojure.core/deref.html" data-reactid="1817"><h3 data-reactid="1818">+ Source</h3></a></div></div><div class="var-info" data-reactid="1819"><a href="../clj/clojure.core/derive.html" data-reactid="1820"><h2 data-reactid="1821">(derive tag parent)</h2><h2 data-reactid="1822">(derive h tag parent)</h2></a><div class="section doc" data-reactid="1823">Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.</div><div class="section" data-reactid="1824"><a href="../clj/clojure.core/derive.html" data-reactid="1825"><h3 data-reactid="1826">+ Source</h3></a></div></div><div class="var-info" data-reactid="1827"><a href="../clj/clojure.core/descendants.html" data-reactid="1828"><h2 data-reactid="1829">(descendants tag)</h2><h2 data-reactid="1830">(descendants h tag)</h2></a><div class="section doc" data-reactid="1831">Returns the immediate and indirect children of tag, through a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy. Note: does not work on Java type inheritance
  relationships.</div><div class="section" data-reactid="1832"><a href="../clj/clojure.core/descendants.html" data-reactid="1833"><h3 data-reactid="1834">+ Source</h3></a></div></div><div class="var-info" data-reactid="1835"><a href="../clj/clojure.core/destructure.html" data-reactid="1836"><h2 data-reactid="1837">(destructure bindings)</h2></a><div class="section" data-reactid="1838"><a href="../clj/clojure.core/destructure.html" data-reactid="1839"><h3 data-reactid="1840">+ Source</h3></a></div></div><div class="var-info" data-reactid="1841"><a href="../clj/clojure.core/disj.html" data-reactid="1842"><h2 data-reactid="1843">(disj set)</h2><h2 data-reactid="1844">(disj set key)</h2><h2 data-reactid="1845">(disj set key &amp; ks)</h2></a><div class="section doc" data-reactid="1846">disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).</div><div class="section" data-reactid="1847"><a href="../clj/clojure.core/disj.html" data-reactid="1848"><h3 data-reactid="1849">+ Source</h3></a></div></div><div class="var-info" data-reactid="1850"><a href="../clj/clojure.core/disj&#x27;e&#x27;.html" data-reactid="1851"><h2 data-reactid="1852">(disj! set)</h2><h2 data-reactid="1853">(disj! set key)</h2><h2 data-reactid="1854">(disj! set key &amp; ks)</h2></a><div class="section doc" data-reactid="1855">disj[oin]. Returns a transient set of the same (hashed/sorted) type, that
  does not contain key(s).</div><div class="section" data-reactid="1856"><a href="../clj/clojure.core/disj&#x27;e&#x27;.html" data-reactid="1857"><h3 data-reactid="1858">+ Source</h3></a></div></div><div class="var-info" data-reactid="1859"><a href="../clj/clojure.core/dissoc.html" data-reactid="1860"><h2 data-reactid="1861">(dissoc map)</h2><h2 data-reactid="1862">(dissoc map key)</h2><h2 data-reactid="1863">(dissoc map key &amp; ks)</h2></a><div class="section doc" data-reactid="1864">dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).</div><div class="section" data-reactid="1865"><a href="../clj/clojure.core/dissoc.html" data-reactid="1866"><h3 data-reactid="1867">+ Source</h3></a></div></div><div class="var-info" data-reactid="1868"><a href="../clj/clojure.core/dissoc&#x27;e&#x27;.html" data-reactid="1869"><h2 data-reactid="1870">(dissoc! map key)</h2><h2 data-reactid="1871">(dissoc! map key &amp; ks)</h2></a><div class="section doc" data-reactid="1872">Returns a transient map that doesn&#x27;t contain a mapping for key(s).</div><div class="section" data-reactid="1873"><a href="../clj/clojure.core/dissoc&#x27;e&#x27;.html" data-reactid="1874"><h3 data-reactid="1875">+ Source</h3></a></div></div><div class="var-info" data-reactid="1876"><a href="../clj/clojure.core/distinct.html" data-reactid="1877"><h2 data-reactid="1878">(distinct)</h2><h2 data-reactid="1879">(distinct coll)</h2></a><div class="section doc" data-reactid="1880">Returns a lazy sequence of the elements of coll with duplicates removed.
  Returns a stateful transducer when no collection is provided.</div><div class="section" data-reactid="1881"><a href="../clj/clojure.core/distinct.html" data-reactid="1882"><h3 data-reactid="1883">+ Source</h3></a></div></div><div class="var-info" data-reactid="1884"><a href="../clj/clojure.core/distinct&#x27;q&#x27;.html" data-reactid="1885"><h2 data-reactid="1886">(distinct? x)</h2><h2 data-reactid="1887">(distinct? x y)</h2><h2 data-reactid="1888">(distinct? x y &amp; more)</h2></a><div class="section doc" data-reactid="1889">Returns true if no two of the arguments are =</div><div class="section" data-reactid="1890"><a href="../clj/clojure.core/distinct&#x27;q&#x27;.html" data-reactid="1891"><h3 data-reactid="1892">+ Source</h3></a></div></div><div class="var-info" data-reactid="1893"><a href="../clj/clojure.core/doall.html" data-reactid="1894"><h2 data-reactid="1895">(doall coll)</h2><h2 data-reactid="1896">(doall n coll)</h2></a><div class="section doc" data-reactid="1897">When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.</div><div class="section" data-reactid="1898"><a href="../clj/clojure.core/doall.html" data-reactid="1899"><h3 data-reactid="1900">+ Source</h3></a></div></div><div class="var-info" data-reactid="1901"><a href="../clj/clojure.core/dorun.html" data-reactid="1902"><h2 data-reactid="1903">(dorun coll)</h2><h2 data-reactid="1904">(dorun n coll)</h2></a><div class="section doc" data-reactid="1905">When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil.</div><div class="section" data-reactid="1906"><a href="../clj/clojure.core/dorun.html" data-reactid="1907"><h3 data-reactid="1908">+ Source</h3></a></div></div><div class="var-info" data-reactid="1909"><a href="../clj/clojure.core/doseq.html" data-reactid="1910"><h2 data-reactid="1911">(doseq seq-exprs &amp; body)</h2></a><div class="section doc" data-reactid="1912">Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.</div><div class="section" data-reactid="1913"><a href="../clj/clojure.core/doseq.html" data-reactid="1914"><h3 data-reactid="1915">+ Source</h3></a></div></div><div class="var-info" data-reactid="1916"><a href="../clj/clojure.core/dosync.html" data-reactid="1917"><h2 data-reactid="1918">(dosync &amp; exprs)</h2></a><div class="section doc" data-reactid="1919">Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.</div><div class="section" data-reactid="1920"><a href="../clj/clojure.core/dosync.html" data-reactid="1921"><h3 data-reactid="1922">+ Source</h3></a></div></div><div class="var-info" data-reactid="1923"><a href="../clj/clojure.core/dotimes.html" data-reactid="1924"><h2 data-reactid="1925">(dotimes bindings &amp; body)</h2></a><div class="section doc" data-reactid="1926">bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.</div><div class="section" data-reactid="1927"><a href="../clj/clojure.core/dotimes.html" data-reactid="1928"><h3 data-reactid="1929">+ Source</h3></a></div></div><div class="var-info" data-reactid="1930"><a href="../clj/clojure.core/doto.html" data-reactid="1931"><h2 data-reactid="1932">(doto x &amp; forms)</h2></a><div class="section doc" data-reactid="1933">Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments.  The forms
  are evaluated in order.  Returns x.

  (doto (new java.util.HashMap) (.put &quot;a&quot; 1) (.put &quot;b&quot; 2))</div><div class="section" data-reactid="1934"><a href="../clj/clojure.core/doto.html" data-reactid="1935"><h3 data-reactid="1936">+ Source</h3></a></div></div><div class="var-info" data-reactid="1937"><a href="../clj/clojure.core/double.html" data-reactid="1938"><h2 data-reactid="1939">(double x)</h2></a><div class="section doc" data-reactid="1940">Coerce to double</div><div class="section" data-reactid="1941"><a href="../clj/clojure.core/double.html" data-reactid="1942"><h3 data-reactid="1943">+ Source</h3></a></div></div><div class="var-info" data-reactid="1944"><a href="../clj/clojure.core/double-array.html" data-reactid="1945"><h2 data-reactid="1946">(double-array size-or-seq)</h2><h2 data-reactid="1947">(double-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="1948">Creates an array of doubles</div><div class="section" data-reactid="1949"><a href="../clj/clojure.core/double-array.html" data-reactid="1950"><h3 data-reactid="1951">+ Source</h3></a></div></div><div class="var-info" data-reactid="1952"><a href="../clj/clojure.core/double&#x27;q&#x27;.html" data-reactid="1953"><h2 data-reactid="1954">(double? x)</h2></a><div class="section doc" data-reactid="1955">Return true if x is a Double</div><div class="section" data-reactid="1956"><a href="../clj/clojure.core/double&#x27;q&#x27;.html" data-reactid="1957"><h3 data-reactid="1958">+ Source</h3></a></div></div><div class="var-info" data-reactid="1959"><a href="../clj/clojure.core/doubles.html" data-reactid="1960"><h2 data-reactid="1961">(doubles xs)</h2></a><div class="section doc" data-reactid="1962">Casts to double[]</div><div class="section" data-reactid="1963"><a href="../clj/clojure.core/doubles.html" data-reactid="1964"><h3 data-reactid="1965">+ Source</h3></a></div></div><div class="var-info" data-reactid="1966"><a href="../clj/clojure.core/drop.html" data-reactid="1967"><h2 data-reactid="1968">(drop n)</h2><h2 data-reactid="1969">(drop n coll)</h2></a><div class="section doc" data-reactid="1970">Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.</div><div class="section" data-reactid="1971"><a href="../clj/clojure.core/drop.html" data-reactid="1972"><h3 data-reactid="1973">+ Source</h3></a></div></div><div class="var-info" data-reactid="1974"><a href="../clj/clojure.core/drop-last.html" data-reactid="1975"><h2 data-reactid="1976">(drop-last coll)</h2><h2 data-reactid="1977">(drop-last n coll)</h2></a><div class="section doc" data-reactid="1978">Return a lazy sequence of all but the last n (default 1) items in coll</div><div class="section" data-reactid="1979"><a href="../clj/clojure.core/drop-last.html" data-reactid="1980"><h3 data-reactid="1981">+ Source</h3></a></div></div><div class="var-info" data-reactid="1982"><a href="../clj/clojure.core/drop-while.html" data-reactid="1983"><h2 data-reactid="1984">(drop-while pred)</h2><h2 data-reactid="1985">(drop-while pred coll)</h2></a><div class="section doc" data-reactid="1986">Returns a lazy sequence of the items in coll starting from the
  first item for which (pred item) returns logical false.  Returns a
  stateful transducer when no collection is provided.</div><div class="section" data-reactid="1987"><a href="../clj/clojure.core/drop-while.html" data-reactid="1988"><h3 data-reactid="1989">+ Source</h3></a></div></div><div class="var-info" data-reactid="1990"><a href="../clj/clojure.core/eduction.html" data-reactid="1991"><h2 data-reactid="1992">(eduction xform* coll)</h2></a><div class="section doc" data-reactid="1993">Returns a reducible/iterable application of the transducers
  to the items in coll. Transducers are applied in order as if
  combined with comp. Note that these applications will be
  performed every time reduce/iterator is called.</div><div class="section" data-reactid="1994"><a href="../clj/clojure.core/eduction.html" data-reactid="1995"><h3 data-reactid="1996">+ Source</h3></a></div></div><div class="var-info" data-reactid="1997"><a href="../clj/clojure.core/empty.html" data-reactid="1998"><h2 data-reactid="1999">(empty coll)</h2></a><div class="section doc" data-reactid="2000">Returns an empty collection of the same category as coll, or nil</div><div class="section" data-reactid="2001"><a href="../clj/clojure.core/empty.html" data-reactid="2002"><h3 data-reactid="2003">+ Source</h3></a></div></div><div class="var-info" data-reactid="2004"><a href="../clj/clojure.core/empty&#x27;q&#x27;.html" data-reactid="2005"><h2 data-reactid="2006">(empty? coll)</h2></a><div class="section doc" data-reactid="2007">Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))</div><div class="section" data-reactid="2008"><a href="../clj/clojure.core/empty&#x27;q&#x27;.html" data-reactid="2009"><h3 data-reactid="2010">+ Source</h3></a></div></div><div class="var-info" data-reactid="2011"><a href="../clj/clojure.core/ensure.html" data-reactid="2012"><h2 data-reactid="2013">(ensure ref)</h2></a><div class="section doc" data-reactid="2014">Must be called in a transaction. Protects the ref from modification
  by other transactions.  Returns the in-transaction-value of
  ref. Allows for more concurrency than (ref-set ref @ref)</div><div class="section" data-reactid="2015"><a href="../clj/clojure.core/ensure.html" data-reactid="2016"><h3 data-reactid="2017">+ Source</h3></a></div></div><div class="var-info" data-reactid="2018"><a href="../clj/clojure.core/ensure-reduced.html" data-reactid="2019"><h2 data-reactid="2020">(ensure-reduced x)</h2></a><div class="section doc" data-reactid="2021">If x is already reduced?, returns it, else returns (reduced x)</div><div class="section" data-reactid="2022"><a href="../clj/clojure.core/ensure-reduced.html" data-reactid="2023"><h3 data-reactid="2024">+ Source</h3></a></div></div><div class="var-info" data-reactid="2025"><a href="../clj/clojure.core/enumeration-seq.html" data-reactid="2026"><h2 data-reactid="2027">(enumeration-seq e)</h2></a><div class="section doc" data-reactid="2028">Returns a seq on a java.util.Enumeration</div><div class="section" data-reactid="2029"><a href="../clj/clojure.core/enumeration-seq.html" data-reactid="2030"><h3 data-reactid="2031">+ Source</h3></a></div></div><div class="var-info" data-reactid="2032"><a href="../clj/clojure.core/error-handler.html" data-reactid="2033"><h2 data-reactid="2034">(error-handler a)</h2></a><div class="section doc" data-reactid="2035">Returns the error-handler of agent a, or nil if there is none.
  See set-error-handler!</div><div class="section" data-reactid="2036"><a href="../clj/clojure.core/error-handler.html" data-reactid="2037"><h3 data-reactid="2038">+ Source</h3></a></div></div><div class="var-info" data-reactid="2039"><a href="../clj/clojure.core/error-mode.html" data-reactid="2040"><h2 data-reactid="2041">(error-mode a)</h2></a><div class="section doc" data-reactid="2042">Returns the error-mode of agent a.  See set-error-mode!</div><div class="section" data-reactid="2043"><a href="../clj/clojure.core/error-mode.html" data-reactid="2044"><h3 data-reactid="2045">+ Source</h3></a></div></div><div class="var-info" data-reactid="2046"><a href="../clj/clojure.core/eval.html" data-reactid="2047"><h2 data-reactid="2048">(eval form)</h2></a><div class="section doc" data-reactid="2049">Evaluates the form data structure (not text!) and returns the result.</div><div class="section" data-reactid="2050"><a href="../clj/clojure.core/eval.html" data-reactid="2051"><h3 data-reactid="2052">+ Source</h3></a></div></div><div class="var-info" data-reactid="2053"><a href="../clj/clojure.core/even&#x27;q&#x27;.html" data-reactid="2054"><h2 data-reactid="2055">(even? n)</h2></a><div class="section doc" data-reactid="2056">Returns true if n is even, throws an exception if n is not an integer</div><div class="section" data-reactid="2057"><a href="../clj/clojure.core/even&#x27;q&#x27;.html" data-reactid="2058"><h3 data-reactid="2059">+ Source</h3></a></div></div><div class="var-info" data-reactid="2060"><a href="../clj/clojure.core/every-pred.html" data-reactid="2061"><h2 data-reactid="2062">(every-pred p)</h2><h2 data-reactid="2063">(every-pred p1 p2)</h2><h2 data-reactid="2064">(every-pred p1 p2 p3)</h2><h2 data-reactid="2065">(every-pred p1 p2 p3 &amp; ps)</h2></a><div class="section doc" data-reactid="2066">Takes a set of predicates and returns a function f that returns true if all of its
  composing predicates return a logical true value against all of its arguments, else it returns
  false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical false result against the original predicates.</div><div class="section" data-reactid="2067"><a href="../clj/clojure.core/every-pred.html" data-reactid="2068"><h3 data-reactid="2069">+ Source</h3></a></div></div><div class="var-info" data-reactid="2070"><a href="../clj/clojure.core/every&#x27;q&#x27;.html" data-reactid="2071"><h2 data-reactid="2072">(every? pred coll)</h2></a><div class="section doc" data-reactid="2073">Returns true if (pred x) is logical true for every x in coll, else
  false.</div><div class="section" data-reactid="2074"><a href="../clj/clojure.core/every&#x27;q&#x27;.html" data-reactid="2075"><h3 data-reactid="2076">+ Source</h3></a></div></div><div class="var-info" data-reactid="2077"><a href="../clj/clojure.core/ex-data.html" data-reactid="2078"><h2 data-reactid="2079">(ex-data ex)</h2></a><div class="section doc" data-reactid="2080">Returns exception data (a map) if ex is an IExceptionInfo.
   Otherwise returns nil.</div><div class="section" data-reactid="2081"><a href="../clj/clojure.core/ex-data.html" data-reactid="2082"><h3 data-reactid="2083">+ Source</h3></a></div></div><div class="var-info" data-reactid="2084"><a href="../clj/clojure.core/ex-info.html" data-reactid="2085"><h2 data-reactid="2086">(ex-info msg map)</h2><h2 data-reactid="2087">(ex-info msg map cause)</h2></a><div class="section doc" data-reactid="2088">Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.</div><div class="section" data-reactid="2089"><a href="../clj/clojure.core/ex-info.html" data-reactid="2090"><h3 data-reactid="2091">+ Source</h3></a></div></div><div class="var-info" data-reactid="2092"><a href="../clj/clojure.core/extend.html" data-reactid="2093"><h2 data-reactid="2094">(extend atype &amp; proto+mmaps)</h2></a><div class="section doc" data-reactid="2095">Implementations of protocol methods can be provided using the extend construct:

  (extend AType
    AProtocol
     {:foo an-existing-fn
      :bar (fn [a b] ...)
      :baz (fn ([a]...) ([a b] ...)...)}
    BProtocol 
      {...} 
    ...)
 
  extend takes a type/class (or interface, see below), and one or more
  protocol + method map pairs. It will extend the polymorphism of the
  protocol&#x27;s methods to call the supplied methods when an AType is
  provided as the first argument. 

  Method maps are maps of the keyword-ized method names to ordinary
  fns. This facilitates easy reuse of existing fns and fn maps, for
  code reuse/mixins without derivation or composition. You can extend
  an interface to a protocol. This is primarily to facilitate interop
  with the host (e.g. Java) but opens the door to incidental multiple
  inheritance of implementation since a class can inherit from more
  than one interface, both of which extend the protocol. It is TBD how
  to specify which impl to use. You can extend a protocol on nil.

  If you are supplying the definitions explicitly (i.e. not reusing
  exsting functions or mixin maps), you may find it more convenient to
  use the extend-type or extend-protocol macros.

  Note that multiple independent extend clauses can exist for the same
  type, not all protocols need be defined in a single extend call.

  See also:
  extends?, satisfies?, extenders</div><div class="section" data-reactid="2096"><a href="../clj/clojure.core/extend.html" data-reactid="2097"><h3 data-reactid="2098">+ Source</h3></a></div></div><div class="var-info" data-reactid="2099"><a href="../clj/clojure.core/extend-protocol.html" data-reactid="2100"><h2 data-reactid="2101">(extend-protocol p &amp; specs)</h2></a><div class="section doc" data-reactid="2102">Useful when you want to provide several implementations of the same
  protocol all at once. Takes a single protocol and the implementation
  of that protocol for one or more types. Expands into calls to
  extend-type:

  (extend-protocol Protocol
    AType
      (foo [x] ...)
      (bar [x y] ...)
    BType
      (foo [x] ...)
      (bar [x y] ...)
    AClass
      (foo [x] ...)
      (bar [x y] ...)
    nil
      (foo [x] ...)
      (bar [x y] ...))

  expands into:

  (do
   (clojure.core/extend-type AType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type BType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type AClass Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type nil Protocol 
     (foo [x] ...) 
     (bar [x y] ...)))</div><div class="section" data-reactid="2103"><a href="../clj/clojure.core/extend-protocol.html" data-reactid="2104"><h3 data-reactid="2105">+ Source</h3></a></div></div><div class="var-info" data-reactid="2106"><a href="../clj/clojure.core/extend-type.html" data-reactid="2107"><h2 data-reactid="2108">(extend-type t &amp; specs)</h2></a><div class="section doc" data-reactid="2109">A macro that expands into an extend call. Useful when you are
  supplying the definitions explicitly inline, extend-type
  automatically creates the maps required by extend.  Propagates the
  class as a type hint on the first argument of all fns.

  (extend-type MyType 
    Countable
      (cnt [c] ...)
    Foo
      (bar [x y] ...)
      (baz ([x] ...) ([x y &amp; zs] ...)))

  expands into:

  (extend MyType
   Countable
     {:cnt (fn [c] ...)}
   Foo
     {:baz (fn ([x] ...) ([x y &amp; zs] ...))
      :bar (fn [x y] ...)})</div><div class="section" data-reactid="2110"><a href="../clj/clojure.core/extend-type.html" data-reactid="2111"><h3 data-reactid="2112">+ Source</h3></a></div></div><div class="var-info" data-reactid="2113"><a href="../clj/clojure.core/extenders.html" data-reactid="2114"><h2 data-reactid="2115">(extenders protocol)</h2></a><div class="section doc" data-reactid="2116">Returns a collection of the types explicitly extending protocol</div><div class="section" data-reactid="2117"><a href="../clj/clojure.core/extenders.html" data-reactid="2118"><h3 data-reactid="2119">+ Source</h3></a></div></div><div class="var-info" data-reactid="2120"><a href="../clj/clojure.core/extends&#x27;q&#x27;.html" data-reactid="2121"><h2 data-reactid="2122">(extends? protocol atype)</h2></a><div class="section doc" data-reactid="2123">Returns true if atype extends protocol</div><div class="section" data-reactid="2124"><a href="../clj/clojure.core/extends&#x27;q&#x27;.html" data-reactid="2125"><h3 data-reactid="2126">+ Source</h3></a></div></div><div class="var-info" data-reactid="2127"><a href="../clj/clojure.core/false&#x27;q&#x27;.html" data-reactid="2128"><h2 data-reactid="2129">(false? x)</h2></a><div class="section doc" data-reactid="2130">Returns true if x is the value false, false otherwise.</div><div class="section" data-reactid="2131"><a href="../clj/clojure.core/false&#x27;q&#x27;.html" data-reactid="2132"><h3 data-reactid="2133">+ Source</h3></a></div></div><div class="var-info" data-reactid="2134"><a href="../clj/clojure.core/ffirst.html" data-reactid="2135"><h2 data-reactid="2136">(ffirst x)</h2></a><div class="section doc" data-reactid="2137">Same as (first (first x))</div><div class="section" data-reactid="2138"><a href="../clj/clojure.core/ffirst.html" data-reactid="2139"><h3 data-reactid="2140">+ Source</h3></a></div></div><div class="var-info" data-reactid="2141"><a href="../clj/clojure.core/file-seq.html" data-reactid="2142"><h2 data-reactid="2143">(file-seq dir)</h2></a><div class="section doc" data-reactid="2144">A tree seq on java.io.Files</div><div class="section" data-reactid="2145"><a href="../clj/clojure.core/file-seq.html" data-reactid="2146"><h3 data-reactid="2147">+ Source</h3></a></div></div><div class="var-info" data-reactid="2148"><a href="../clj/clojure.core/filter.html" data-reactid="2149"><h2 data-reactid="2150">(filter pred)</h2><h2 data-reactid="2151">(filter pred coll)</h2></a><div class="section doc" data-reactid="2152">Returns a lazy sequence of the items in coll for which
  (pred item) returns logical true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="2153"><a href="../clj/clojure.core/filter.html" data-reactid="2154"><h3 data-reactid="2155">+ Source</h3></a></div></div><div class="var-info" data-reactid="2156"><a href="../clj/clojure.core/filterv.html" data-reactid="2157"><h2 data-reactid="2158">(filterv pred coll)</h2></a><div class="section doc" data-reactid="2159">Returns a vector of the items in coll for which
  (pred item) returns logical true. pred must be free of side-effects.</div><div class="section" data-reactid="2160"><a href="../clj/clojure.core/filterv.html" data-reactid="2161"><h3 data-reactid="2162">+ Source</h3></a></div></div><div class="var-info" data-reactid="2163"><a href="../clj/clojure.core/find.html" data-reactid="2164"><h2 data-reactid="2165">(find map key)</h2></a><div class="section doc" data-reactid="2166">Returns the map entry for key, or nil if key not present.</div><div class="section" data-reactid="2167"><a href="../clj/clojure.core/find.html" data-reactid="2168"><h3 data-reactid="2169">+ Source</h3></a></div></div><div class="var-info" data-reactid="2170"><a href="../clj/clojure.core/find-keyword.html" data-reactid="2171"><h2 data-reactid="2172">(find-keyword name)</h2><h2 data-reactid="2173">(find-keyword ns name)</h2></a><div class="section doc" data-reactid="2174">Returns a Keyword with the given namespace and name if one already
  exists.  This function will not intern a new keyword. If the keyword
  has not already been interned, it will return nil.  Do not use :
  in the keyword strings, it will be added automatically.</div><div class="section" data-reactid="2175"><a href="../clj/clojure.core/find-keyword.html" data-reactid="2176"><h3 data-reactid="2177">+ Source</h3></a></div></div><div class="var-info" data-reactid="2178"><a href="../clj/clojure.core/find-ns.html" data-reactid="2179"><h2 data-reactid="2180">(find-ns sym)</h2></a><div class="section doc" data-reactid="2181">Returns the namespace named by the symbol or nil if it doesn&#x27;t exist.</div><div class="section" data-reactid="2182"><a href="../clj/clojure.core/find-ns.html" data-reactid="2183"><h3 data-reactid="2184">+ Source</h3></a></div></div><div class="var-info" data-reactid="2185"><a href="../clj/clojure.core/find-protocol-impl.html" data-reactid="2186"><h2 data-reactid="2187">(find-protocol-impl protocol x)</h2></a><div class="section" data-reactid="2188"><a href="../clj/clojure.core/find-protocol-impl.html" data-reactid="2189"><h3 data-reactid="2190">+ Source</h3></a></div></div><div class="var-info" data-reactid="2191"><a href="../clj/clojure.core/find-protocol-method.html" data-reactid="2192"><h2 data-reactid="2193">(find-protocol-method protocol methodk x)</h2></a><div class="section" data-reactid="2194"><a href="../clj/clojure.core/find-protocol-method.html" data-reactid="2195"><h3 data-reactid="2196">+ Source</h3></a></div></div><div class="var-info" data-reactid="2197"><a href="../clj/clojure.core/find-var.html" data-reactid="2198"><h2 data-reactid="2199">(find-var sym)</h2></a><div class="section doc" data-reactid="2200">Returns the global var named by the namespace-qualified symbol, or
  nil if no var with that name.</div><div class="section" data-reactid="2201"><a href="../clj/clojure.core/find-var.html" data-reactid="2202"><h3 data-reactid="2203">+ Source</h3></a></div></div><div class="var-info" data-reactid="2204"><a href="../clj/clojure.core/first.html" data-reactid="2205"><h2 data-reactid="2206">(first coll)</h2></a><div class="section doc" data-reactid="2207">Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.</div><div class="section" data-reactid="2208"><a href="../clj/clojure.core/first.html" data-reactid="2209"><h3 data-reactid="2210">+ Source</h3></a></div></div><div class="var-info" data-reactid="2211"><a href="../clj/clojure.core/flatten.html" data-reactid="2212"><h2 data-reactid="2213">(flatten x)</h2></a><div class="section doc" data-reactid="2214">Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence.</div><div class="section" data-reactid="2215"><a href="../clj/clojure.core/flatten.html" data-reactid="2216"><h3 data-reactid="2217">+ Source</h3></a></div></div><div class="var-info" data-reactid="2218"><a href="../clj/clojure.core/float.html" data-reactid="2219"><h2 data-reactid="2220">(float x)</h2></a><div class="section doc" data-reactid="2221">Coerce to float</div><div class="section" data-reactid="2222"><a href="../clj/clojure.core/float.html" data-reactid="2223"><h3 data-reactid="2224">+ Source</h3></a></div></div><div class="var-info" data-reactid="2225"><a href="../clj/clojure.core/float-array.html" data-reactid="2226"><h2 data-reactid="2227">(float-array size-or-seq)</h2><h2 data-reactid="2228">(float-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="2229">Creates an array of floats</div><div class="section" data-reactid="2230"><a href="../clj/clojure.core/float-array.html" data-reactid="2231"><h3 data-reactid="2232">+ Source</h3></a></div></div><div class="var-info" data-reactid="2233"><a href="../clj/clojure.core/float&#x27;q&#x27;.html" data-reactid="2234"><h2 data-reactid="2235">(float? n)</h2></a><div class="section doc" data-reactid="2236">Returns true if n is a floating point number</div><div class="section" data-reactid="2237"><a href="../clj/clojure.core/float&#x27;q&#x27;.html" data-reactid="2238"><h3 data-reactid="2239">+ Source</h3></a></div></div><div class="var-info" data-reactid="2240"><a href="../clj/clojure.core/floats.html" data-reactid="2241"><h2 data-reactid="2242">(floats xs)</h2></a><div class="section doc" data-reactid="2243">Casts to float[]</div><div class="section" data-reactid="2244"><a href="../clj/clojure.core/floats.html" data-reactid="2245"><h3 data-reactid="2246">+ Source</h3></a></div></div><div class="var-info" data-reactid="2247"><a href="../clj/clojure.core/flush.html" data-reactid="2248"><h2 data-reactid="2249">(flush)</h2></a><div class="section doc" data-reactid="2250">Flushes the output stream that is the current value of
  *out*</div><div class="section" data-reactid="2251"><a href="../clj/clojure.core/flush.html" data-reactid="2252"><h3 data-reactid="2253">+ Source</h3></a></div></div><div class="var-info" data-reactid="2254"><a href="../clj/clojure.core/fn.html" data-reactid="2255"><h2 data-reactid="2256">(fn &amp; sigs)</h2></a><div class="section doc" data-reactid="2257">params =&gt; positional-params* , or positional-params* &amp; next-param
  positional-param =&gt; binding-form
  next-param =&gt; binding-form
  name =&gt; symbol

  Defines a function</div><div class="section" data-reactid="2258"><a href="../clj/clojure.core/fn.html" data-reactid="2259"><h3 data-reactid="2260">+ Spec</h3></a></div><div class="section" data-reactid="2261"><a href="../clj/clojure.core/fn.html" data-reactid="2262"><h3 data-reactid="2263">+ Source</h3></a></div></div><div class="var-info" data-reactid="2264"><a href="../clj/clojure.core/fn&#x27;q&#x27;.html" data-reactid="2265"><h2 data-reactid="2266">(fn? x)</h2></a><div class="section doc" data-reactid="2267">Returns true if x implements Fn, i.e. is an object created via fn.</div><div class="section" data-reactid="2268"><a href="../clj/clojure.core/fn&#x27;q&#x27;.html" data-reactid="2269"><h3 data-reactid="2270">+ Source</h3></a></div></div><div class="var-info" data-reactid="2271"><a href="../clj/clojure.core/fnext.html" data-reactid="2272"><h2 data-reactid="2273">(fnext x)</h2></a><div class="section doc" data-reactid="2274">Same as (first (next x))</div><div class="section" data-reactid="2275"><a href="../clj/clojure.core/fnext.html" data-reactid="2276"><h3 data-reactid="2277">+ Source</h3></a></div></div><div class="var-info" data-reactid="2278"><a href="../clj/clojure.core/fnil.html" data-reactid="2279"><h2 data-reactid="2280">(fnil f x)</h2><h2 data-reactid="2281">(fnil f x y)</h2><h2 data-reactid="2282">(fnil f x y z)</h2></a><div class="section doc" data-reactid="2283">Takes a function f, and returns a function that calls f, replacing
  a nil first argument to f with the supplied value x. Higher arity
  versions can replace arguments in the second and third
  positions (y, z). Note that the function f can take any number of
  arguments, not just the one(s) being nil-patched.</div><div class="section" data-reactid="2284"><a href="../clj/clojure.core/fnil.html" data-reactid="2285"><h3 data-reactid="2286">+ Source</h3></a></div></div><div class="var-info" data-reactid="2287"><a href="../clj/clojure.core/for.html" data-reactid="2288"><h2 data-reactid="2289">(for seq-exprs body-expr)</h2></a><div class="section doc" data-reactid="2290">List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.

  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))</div><div class="section" data-reactid="2291"><a href="../clj/clojure.core/for.html" data-reactid="2292"><h3 data-reactid="2293">+ Source</h3></a></div></div><div class="var-info" data-reactid="2294"><a href="../clj/clojure.core/force.html" data-reactid="2295"><h2 data-reactid="2296">(force x)</h2></a><div class="section doc" data-reactid="2297">If x is a Delay, returns the (possibly cached) value of its expression, else returns x</div><div class="section" data-reactid="2298"><a href="../clj/clojure.core/force.html" data-reactid="2299"><h3 data-reactid="2300">+ Source</h3></a></div></div><div class="var-info" data-reactid="2301"><a href="../clj/clojure.core/format.html" data-reactid="2302"><h2 data-reactid="2303">(format fmt &amp; args)</h2></a><div class="section doc" data-reactid="2304">Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax</div><div class="section" data-reactid="2305"><a href="../clj/clojure.core/format.html" data-reactid="2306"><h3 data-reactid="2307">+ Source</h3></a></div></div><div class="var-info" data-reactid="2308"><a href="../clj/clojure.core/frequencies.html" data-reactid="2309"><h2 data-reactid="2310">(frequencies coll)</h2></a><div class="section doc" data-reactid="2311">Returns a map from distinct items in coll to the number of times
  they appear.</div><div class="section" data-reactid="2312"><a href="../clj/clojure.core/frequencies.html" data-reactid="2313"><h3 data-reactid="2314">+ Source</h3></a></div></div><div class="var-info" data-reactid="2315"><a href="../clj/clojure.core/future.html" data-reactid="2316"><h2 data-reactid="2317">(future &amp; body)</h2></a><div class="section doc" data-reactid="2318">Takes a body of expressions and yields a future object that will
  invoke the body in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant of
  deref with timeout is used. See also - realized?.</div><div class="section" data-reactid="2319"><a href="../clj/clojure.core/future.html" data-reactid="2320"><h3 data-reactid="2321">+ Source</h3></a></div></div><div class="var-info" data-reactid="2322"><a href="../clj/clojure.core/future-call.html" data-reactid="2323"><h2 data-reactid="2324">(future-call f)</h2></a><div class="section doc" data-reactid="2325">Takes a function of no args and yields a future object that will
  invoke the function in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant
  of deref with timeout is used. See also - realized?.</div><div class="section" data-reactid="2326"><a href="../clj/clojure.core/future-call.html" data-reactid="2327"><h3 data-reactid="2328">+ Source</h3></a></div></div><div class="var-info" data-reactid="2329"><a href="../clj/clojure.core/future-cancel.html" data-reactid="2330"><h2 data-reactid="2331">(future-cancel f)</h2></a><div class="section doc" data-reactid="2332">Cancels the future, if possible.</div><div class="section" data-reactid="2333"><a href="../clj/clojure.core/future-cancel.html" data-reactid="2334"><h3 data-reactid="2335">+ Source</h3></a></div></div><div class="var-info" data-reactid="2336"><a href="../clj/clojure.core/future-cancelled&#x27;q&#x27;.html" data-reactid="2337"><h2 data-reactid="2338">(future-cancelled? f)</h2></a><div class="section doc" data-reactid="2339">Returns true if future f is cancelled</div><div class="section" data-reactid="2340"><a href="../clj/clojure.core/future-cancelled&#x27;q&#x27;.html" data-reactid="2341"><h3 data-reactid="2342">+ Source</h3></a></div></div><div class="var-info" data-reactid="2343"><a href="../clj/clojure.core/future-done&#x27;q&#x27;.html" data-reactid="2344"><h2 data-reactid="2345">(future-done? f)</h2></a><div class="section doc" data-reactid="2346">Returns true if future f is done</div><div class="section" data-reactid="2347"><a href="../clj/clojure.core/future-done&#x27;q&#x27;.html" data-reactid="2348"><h3 data-reactid="2349">+ Source</h3></a></div></div><div class="var-info" data-reactid="2350"><a href="../clj/clojure.core/future&#x27;q&#x27;.html" data-reactid="2351"><h2 data-reactid="2352">(future? x)</h2></a><div class="section doc" data-reactid="2353">Returns true if x is a future</div><div class="section" data-reactid="2354"><a href="../clj/clojure.core/future&#x27;q&#x27;.html" data-reactid="2355"><h3 data-reactid="2356">+ Source</h3></a></div></div><div class="var-info" data-reactid="2357"><a href="../clj/clojure.core/gen-class.html" data-reactid="2358"><h2 data-reactid="2359">(gen-class &amp; options)</h2></a><div class="section doc" data-reactid="2360">When compiling, generates compiled bytecode for a class with the
  given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the *compile-path* directory.  When not compiling, does
  nothing. The gen-class construct contains no implementation, as the
  implementation will be dynamically sought by the generated class in
  functions in an implementing Clojure namespace. Given a generated
  class org.mydomain.MyClass with a method named mymethod, gen-class
  will generate an implementation that looks for a function named by 
  (str prefix mymethod) (default prefix: &quot;-&quot;) in a
  Clojure namespace specified by :impl-ns
  (defaults to the current namespace). All inherited methods,
  generated methods, and init and main functions (see :methods, :init,
  and :main below) will be found similarly prefixed. By default, the
  static initializer for the generated class will attempt to load the
  Clojure support code for the class as a resource from the classpath,
  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This
  behavior can be controlled by :load-impl-ns

  Note that methods with a maximum of 18 parameters are supported.

  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.

  Options should be a set of key/value pairs, all except for :name are optional:

  :name aname

  The package-qualified name of the class to be generated

  :extends aclass

  Specifies the superclass, the non-private methods of which will be
  overridden by the class. If not provided, defaults to Object.

  :implements [interface ...]

  One or more interfaces, the methods of which will be implemented by the class.

  :init name

  If supplied, names a function that will be called with the arguments
  to the constructor. Must return [ [superclass-constructor-args] state] 
  If not supplied, the constructor args are passed directly to
  the superclass constructor and the state will be nil

  :constructors {[param-types] [super-param-types], ...}

  By default, constructors are created for the generated class which
  match the signature(s) of the constructors for the superclass. This
  parameter may be used to explicitly specify constructors, each entry
  providing a mapping from a constructor signature to a superclass
  constructor signature. When you supply this, you must supply an :init
  specifier. 

  :post-init name

  If supplied, names a function that will be called with the object as
  the first argument, followed by the arguments to the constructor.
  It will be called every time an object of this class is created,
  immediately after all the inherited constructors have completed.
  Its return value is ignored.

  :methods [ [name [param-types] return-type], ...]

  The generated class automatically defines all of the non-private
  methods of its superclasses/interfaces. This parameter can be used
  to specify the signatures of additional methods of the generated
  class. Static methods can be specified with ^{:static true} in the
  signature&#x27;s metadata. Do not repeat superclass/interface signatures
  here.

  :main boolean

  If supplied and true, a static public main function will be generated. It will
  pass each string of the String[] argument as a separate argument to
  a function called (str prefix main).

  :factory name

  If supplied, a (set of) public static factory function(s) will be
  created with the given name, and the same signature(s) as the
  constructor(s).
  
  :state name

  If supplied, a public final instance field with the given name will be
  created. You must supply an :init function in order to provide a
  value for the state. Note that, though final, the state can be a ref
  or agent, supporting the creation of Java objects with transactional
  or asynchronous mutation semantics.

  :exposes {protected-field-name {:get name :set name}, ...}

  Since the implementations of the methods of the generated class
  occur in Clojure functions, they have no access to the inherited
  protected fields of the superclass. This parameter can be used to
  generate public getter/setter methods exposing the protected field(s)
  for use in the implementation.

  :exposes-methods {super-method-name exposed-name, ...}

  It is sometimes necessary to call the superclass&#x27; implementation of an
  overridden method.  Those methods may be exposed and referred in 
  the new method implementation by a local name.

  :prefix string

  Default: &quot;-&quot; Methods called e.g. Foo will be looked up in vars called
  prefixFoo in the implementing ns.

  :impl-ns name

  Default: the name of the current ns. Implementations of methods will be 
  looked up in this namespace.

  :load-impl-ns boolean

  Default: true. Causes the static initializer for the generated class
  to reference the load code for the implementing namespace. Should be
  true when implementing-ns is the default, false if you intend to
  load the code via some other method.</div><div class="section" data-reactid="2361"><a href="../clj/clojure.core/gen-class.html" data-reactid="2362"><h3 data-reactid="2363">+ Source</h3></a></div></div><div class="var-info" data-reactid="2364"><a href="../clj/clojure.core/gen-interface.html" data-reactid="2365"><h2 data-reactid="2366">(gen-interface &amp; options)</h2></a><div class="section doc" data-reactid="2367">When compiling, generates compiled bytecode for an interface with
  the given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the *compile-path* directory.  When not compiling, does nothing.
 
  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.
 
  Options should be a set of key/value pairs, all except for :name are
  optional:

  :name aname

  The package-qualified name of the class to be generated

  :extends [interface ...]

  One or more interfaces, which will be extended by this interface.

  :methods [ [name [param-types] return-type], ...]

  This parameter is used to specify the signatures of the methods of
  the generated interface.  Do not repeat superinterface signatures
  here.</div><div class="section" data-reactid="2368"><a href="../clj/clojure.core/gen-interface.html" data-reactid="2369"><h3 data-reactid="2370">+ Source</h3></a></div></div><div class="var-info" data-reactid="2371"><a href="../clj/clojure.core/gensym.html" data-reactid="2372"><h2 data-reactid="2373">(gensym)</h2><h2 data-reactid="2374">(gensym prefix-string)</h2></a><div class="section doc" data-reactid="2375">Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &#x27;G__&#x27;.</div><div class="section" data-reactid="2376"><a href="../clj/clojure.core/gensym.html" data-reactid="2377"><h3 data-reactid="2378">+ Source</h3></a></div></div><div class="var-info" data-reactid="2379"><a href="../clj/clojure.core/get.html" data-reactid="2380"><h2 data-reactid="2381">(get map key)</h2><h2 data-reactid="2382">(get map key not-found)</h2></a><div class="section doc" data-reactid="2383">Returns the value mapped to key, not-found or nil if key not present.</div><div class="section" data-reactid="2384"><a href="../clj/clojure.core/get.html" data-reactid="2385"><h3 data-reactid="2386">+ Source</h3></a></div></div><div class="var-info" data-reactid="2387"><a href="../clj/clojure.core/get-in.html" data-reactid="2388"><h2 data-reactid="2389">(get-in m ks)</h2><h2 data-reactid="2390">(get-in m ks not-found)</h2></a><div class="section doc" data-reactid="2391">Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied.</div><div class="section" data-reactid="2392"><a href="../clj/clojure.core/get-in.html" data-reactid="2393"><h3 data-reactid="2394">+ Source</h3></a></div></div><div class="var-info" data-reactid="2395"><a href="../clj/clojure.core/get-method.html" data-reactid="2396"><h2 data-reactid="2397">(get-method multifn dispatch-val)</h2></a><div class="section doc" data-reactid="2398">Given a multimethod and a dispatch value, returns the dispatch fn
  that would apply to that value, or nil if none apply and no default</div><div class="section" data-reactid="2399"><a href="../clj/clojure.core/get-method.html" data-reactid="2400"><h3 data-reactid="2401">+ Source</h3></a></div></div><div class="var-info" data-reactid="2402"><a href="../clj/clojure.core/get-proxy-class.html" data-reactid="2403"><h2 data-reactid="2404">(get-proxy-class &amp; bases)</h2></a><div class="section doc" data-reactid="2405">Takes an optional single class followed by zero or more
  interfaces. If not supplied class defaults to Object.  Creates an
  returns an instance of a proxy class derived from the supplied
  classes. The resulting value is cached and used for any subsequent
  requests for the same class set. Returns a Class object.</div><div class="section" data-reactid="2406"><a href="../clj/clojure.core/get-proxy-class.html" data-reactid="2407"><h3 data-reactid="2408">+ Source</h3></a></div></div><div class="var-info" data-reactid="2409"><a href="../clj/clojure.core/get-thread-bindings.html" data-reactid="2410"><h2 data-reactid="2411">(get-thread-bindings)</h2></a><div class="section doc" data-reactid="2412">Get a map with the Var/value pairs which is currently in effect for the
  current thread.</div><div class="section" data-reactid="2413"><a href="../clj/clojure.core/get-thread-bindings.html" data-reactid="2414"><h3 data-reactid="2415">+ Source</h3></a></div></div><div class="var-info" data-reactid="2416"><a href="../clj/clojure.core/get-validator.html" data-reactid="2417"><h2 data-reactid="2418">(get-validator iref)</h2></a><div class="section doc" data-reactid="2419">Gets the validator-fn for a var/ref/agent/atom.</div><div class="section" data-reactid="2420"><a href="../clj/clojure.core/get-validator.html" data-reactid="2421"><h3 data-reactid="2422">+ Source</h3></a></div></div><div class="var-info" data-reactid="2423"><a href="../clj/clojure.core/group-by.html" data-reactid="2424"><h2 data-reactid="2425">(group-by f coll)</h2></a><div class="section doc" data-reactid="2426">Returns a map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.</div><div class="section" data-reactid="2427"><a href="../clj/clojure.core/group-by.html" data-reactid="2428"><h3 data-reactid="2429">+ Source</h3></a></div></div><div class="var-info" data-reactid="2430"><a href="../clj/clojure.core/halt-when.html" data-reactid="2431"><h2 data-reactid="2432">(halt-when pred)</h2><h2 data-reactid="2433">(halt-when pred retf)</h2></a><div class="section doc" data-reactid="2434">Returns a transducer that ends transduction when pred returns true
  for an input. When retf is supplied it must be a fn of 2 arguments -
  it will be passed the (completed) result so far and the input that
  triggered the predicate, and its return value (if it does not throw
  an exception) will be the return value of the transducer. If retf
  is not supplied, the input that triggered the predicate will be
  returned. If the predicate never returns true the transduction is
  unaffected.</div><div class="section" data-reactid="2435"><a href="../clj/clojure.core/halt-when.html" data-reactid="2436"><h3 data-reactid="2437">+ Source</h3></a></div></div><div class="var-info" data-reactid="2438"><a href="../clj/clojure.core/hash.html" data-reactid="2439"><h2 data-reactid="2440">(hash x)</h2></a><div class="section doc" data-reactid="2441">Returns the hash code of its argument. Note this is the hash code
  consistent with =, and thus is different than .hashCode for Integer,
  Short, Byte and Clojure collections.</div><div class="section" data-reactid="2442"><a href="../clj/clojure.core/hash.html" data-reactid="2443"><h3 data-reactid="2444">+ Source</h3></a></div></div><div class="var-info" data-reactid="2445"><a href="../clj/clojure.core/hash-combine.html" data-reactid="2446"><h2 data-reactid="2447">(hash-combine x y)</h2></a><div class="section" data-reactid="2448"><a href="../clj/clojure.core/hash-combine.html" data-reactid="2449"><h3 data-reactid="2450">+ Source</h3></a></div></div><div class="var-info" data-reactid="2451"><a href="../clj/clojure.core/hash-map.html" data-reactid="2452"><h2 data-reactid="2453">(hash-map)</h2><h2 data-reactid="2454">(hash-map &amp; keyvals)</h2></a><div class="section doc" data-reactid="2455">keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.</div><div class="section" data-reactid="2456"><a href="../clj/clojure.core/hash-map.html" data-reactid="2457"><h3 data-reactid="2458">+ Source</h3></a></div></div><div class="var-info" data-reactid="2459"><a href="../clj/clojure.core/hash-ordered-coll.html" data-reactid="2460"><h2 data-reactid="2461">(hash-ordered-coll coll)</h2></a><div class="section doc" data-reactid="2462">Returns the hash code, consistent with =, for an external ordered
   collection implementing Iterable.
   See http://clojure.org/data_structures#hash for full algorithms.</div><div class="section" data-reactid="2463"><a href="../clj/clojure.core/hash-ordered-coll.html" data-reactid="2464"><h3 data-reactid="2465">+ Source</h3></a></div></div><div class="var-info" data-reactid="2466"><a href="../clj/clojure.core/hash-set.html" data-reactid="2467"><h2 data-reactid="2468">(hash-set)</h2><h2 data-reactid="2469">(hash-set &amp; keys)</h2></a><div class="section doc" data-reactid="2470">Returns a new hash set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.</div><div class="section" data-reactid="2471"><a href="../clj/clojure.core/hash-set.html" data-reactid="2472"><h3 data-reactid="2473">+ Source</h3></a></div></div><div class="var-info" data-reactid="2474"><a href="../clj/clojure.core/hash-unordered-coll.html" data-reactid="2475"><h2 data-reactid="2476">(hash-unordered-coll coll)</h2></a><div class="section doc" data-reactid="2477">Returns the hash code, consistent with =, for an external unordered
   collection implementing Iterable. For maps, the iterator should
   return map entries whose hash is computed as
     (hash-ordered-coll [k v]).
   See http://clojure.org/data_structures#hash for full algorithms.</div><div class="section" data-reactid="2478"><a href="../clj/clojure.core/hash-unordered-coll.html" data-reactid="2479"><h3 data-reactid="2480">+ Source</h3></a></div></div><div class="var-info" data-reactid="2481"><a href="../clj/clojure.core/ident&#x27;q&#x27;.html" data-reactid="2482"><h2 data-reactid="2483">(ident? x)</h2></a><div class="section doc" data-reactid="2484">Return true if x is a symbol or keyword</div><div class="section" data-reactid="2485"><a href="../clj/clojure.core/ident&#x27;q&#x27;.html" data-reactid="2486"><h3 data-reactid="2487">+ Source</h3></a></div></div><div class="var-info" data-reactid="2488"><a href="../clj/clojure.core/identical&#x27;q&#x27;.html" data-reactid="2489"><h2 data-reactid="2490">(identical? x y)</h2></a><div class="section doc" data-reactid="2491">Tests if 2 arguments are the same object</div><div class="section" data-reactid="2492"><a href="../clj/clojure.core/identical&#x27;q&#x27;.html" data-reactid="2493"><h3 data-reactid="2494">+ Source</h3></a></div></div><div class="var-info" data-reactid="2495"><a href="../clj/clojure.core/identity.html" data-reactid="2496"><h2 data-reactid="2497">(identity x)</h2></a><div class="section doc" data-reactid="2498">Returns its argument.</div><div class="section" data-reactid="2499"><a href="../clj/clojure.core/identity.html" data-reactid="2500"><h3 data-reactid="2501">+ Source</h3></a></div></div><div class="var-info" data-reactid="2502"><a href="../clj/clojure.core/if-let.html" data-reactid="2503"><h2 data-reactid="2504">(if-let bindings then)</h2><h2 data-reactid="2505">(if-let bindings then else &amp; oldform)</h2></a><div class="section doc" data-reactid="2506">bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else</div><div class="section" data-reactid="2507"><a href="../clj/clojure.core/if-let.html" data-reactid="2508"><h3 data-reactid="2509">+ Spec</h3></a></div><div class="section" data-reactid="2510"><a href="../clj/clojure.core/if-let.html" data-reactid="2511"><h3 data-reactid="2512">+ Source</h3></a></div></div><div class="var-info" data-reactid="2513"><a href="../clj/clojure.core/if-not.html" data-reactid="2514"><h2 data-reactid="2515">(if-not test then)</h2><h2 data-reactid="2516">(if-not test then else)</h2></a><div class="section doc" data-reactid="2517">Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.</div><div class="section" data-reactid="2518"><a href="../clj/clojure.core/if-not.html" data-reactid="2519"><h3 data-reactid="2520">+ Source</h3></a></div></div><div class="var-info" data-reactid="2521"><a href="../clj/clojure.core/if-some.html" data-reactid="2522"><h2 data-reactid="2523">(if-some bindings then)</h2><h2 data-reactid="2524">(if-some bindings then else &amp; oldform)</h2></a><div class="section doc" data-reactid="2525">bindings =&gt; binding-form test

   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else</div><div class="section" data-reactid="2526"><a href="../clj/clojure.core/if-some.html" data-reactid="2527"><h3 data-reactid="2528">+ Source</h3></a></div></div><div class="var-info" data-reactid="2529"><a href="../clj/clojure.core/ifn&#x27;q&#x27;.html" data-reactid="2530"><h2 data-reactid="2531">(ifn? x)</h2></a><div class="section doc" data-reactid="2532">Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn</div><div class="section" data-reactid="2533"><a href="../clj/clojure.core/ifn&#x27;q&#x27;.html" data-reactid="2534"><h3 data-reactid="2535">+ Source</h3></a></div></div><div class="var-info" data-reactid="2536"><a href="../clj/clojure.core/import.html" data-reactid="2537"><h2 data-reactid="2538">(import &amp; import-symbols-or-lists)</h2></a><div class="section doc" data-reactid="2539">import-list =&gt; (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.</div><div class="section" data-reactid="2540"><a href="../clj/clojure.core/import.html" data-reactid="2541"><h3 data-reactid="2542">+ Spec</h3></a></div><div class="section" data-reactid="2543"><a href="../clj/clojure.core/import.html" data-reactid="2544"><h3 data-reactid="2545">+ Source</h3></a></div></div><div class="var-info" data-reactid="2546"><a href="../clj/clojure.core/in-ns.html" data-reactid="2547"><h2 data-reactid="2548">(in-ns name)</h2></a><div class="section doc" data-reactid="2549">Sets *ns* to the namespace named by the symbol, creating it if needed.</div></div><div class="var-info" data-reactid="2550"><a href="../clj/clojure.core/inc.html" data-reactid="2551"><h2 data-reactid="2552">(inc x)</h2></a><div class="section doc" data-reactid="2553">Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&#x27;</div><div class="section" data-reactid="2554"><a href="../clj/clojure.core/inc.html" data-reactid="2555"><h3 data-reactid="2556">+ Source</h3></a></div></div><div class="var-info" data-reactid="2557"><a href="../clj/clojure.core/inc&#x27;.html" data-reactid="2558"><h2 data-reactid="2559">(inc&#x27; x)</h2></a><div class="section doc" data-reactid="2560">Returns a number one greater than num. Supports arbitrary precision.
  See also: inc</div><div class="section" data-reactid="2561"><a href="../clj/clojure.core/inc&#x27;.html" data-reactid="2562"><h3 data-reactid="2563">+ Source</h3></a></div></div><div class="var-info" data-reactid="2564"><a href="../clj/clojure.core/indexed&#x27;q&#x27;.html" data-reactid="2565"><h2 data-reactid="2566">(indexed? coll)</h2></a><div class="section doc" data-reactid="2567">Return true if coll implements Indexed, indicating efficient lookup by index</div><div class="section" data-reactid="2568"><a href="../clj/clojure.core/indexed&#x27;q&#x27;.html" data-reactid="2569"><h3 data-reactid="2570">+ Source</h3></a></div></div><div class="var-info" data-reactid="2571"><a href="../clj/clojure.core/init-proxy.html" data-reactid="2572"><h2 data-reactid="2573">(init-proxy proxy mappings)</h2></a><div class="section doc" data-reactid="2574">Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  sets the proxy&#x27;s fn map.  Returns the proxy.</div><div class="section" data-reactid="2575"><a href="../clj/clojure.core/init-proxy.html" data-reactid="2576"><h3 data-reactid="2577">+ Source</h3></a></div></div><div class="var-info" data-reactid="2578"><a href="../clj/clojure.core/inst-ms.html" data-reactid="2579"><h2 data-reactid="2580">(inst-ms inst)</h2></a><div class="section doc" data-reactid="2581">Return the number of milliseconds since January 1, 1970, 00:00:00 GMT</div><div class="section" data-reactid="2582"><a href="../clj/clojure.core/inst-ms.html" data-reactid="2583"><h3 data-reactid="2584">+ Source</h3></a></div></div><div class="var-info" data-reactid="2585"><a href="../clj/clojure.core/inst-ms&#x27;a&#x27;.html" data-reactid="2586"><h2 data-reactid="2587">(inst-ms* inst)</h2></a></div><div class="var-info" data-reactid="2588"><a href="../clj/clojure.core/inst&#x27;q&#x27;.html" data-reactid="2589"><h2 data-reactid="2590">(inst? x)</h2></a><div class="section doc" data-reactid="2591">Return true if x satisfies Inst</div><div class="section" data-reactid="2592"><a href="../clj/clojure.core/inst&#x27;q&#x27;.html" data-reactid="2593"><h3 data-reactid="2594">+ Source</h3></a></div></div><div class="var-info" data-reactid="2595"><a href="../clj/clojure.core/instance&#x27;q&#x27;.html" data-reactid="2596"><h2 data-reactid="2597">(instance? c x)</h2></a><div class="section doc" data-reactid="2598">Evaluates x and tests if it is an instance of the class
    c. Returns true or false</div><div class="section" data-reactid="2599"><a href="../clj/clojure.core/instance&#x27;q&#x27;.html" data-reactid="2600"><h3 data-reactid="2601">+ Source</h3></a></div></div><div class="var-info" data-reactid="2602"><a href="../clj/clojure.core/int.html" data-reactid="2603"><h2 data-reactid="2604">(int x)</h2></a><div class="section doc" data-reactid="2605">Coerce to int</div><div class="section" data-reactid="2606"><a href="../clj/clojure.core/int.html" data-reactid="2607"><h3 data-reactid="2608">+ Source</h3></a></div></div><div class="var-info" data-reactid="2609"><a href="../clj/clojure.core/int-array.html" data-reactid="2610"><h2 data-reactid="2611">(int-array size-or-seq)</h2><h2 data-reactid="2612">(int-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="2613">Creates an array of ints</div><div class="section" data-reactid="2614"><a href="../clj/clojure.core/int-array.html" data-reactid="2615"><h3 data-reactid="2616">+ Source</h3></a></div></div><div class="var-info" data-reactid="2617"><a href="../clj/clojure.core/int&#x27;q&#x27;.html" data-reactid="2618"><h2 data-reactid="2619">(int? x)</h2></a><div class="section doc" data-reactid="2620">Return true if x is a fixed precision integer</div><div class="section" data-reactid="2621"><a href="../clj/clojure.core/int&#x27;q&#x27;.html" data-reactid="2622"><h3 data-reactid="2623">+ Source</h3></a></div></div><div class="var-info" data-reactid="2624"><a href="../clj/clojure.core/integer&#x27;q&#x27;.html" data-reactid="2625"><h2 data-reactid="2626">(integer? n)</h2></a><div class="section doc" data-reactid="2627">Returns true if n is an integer</div><div class="section" data-reactid="2628"><a href="../clj/clojure.core/integer&#x27;q&#x27;.html" data-reactid="2629"><h3 data-reactid="2630">+ Source</h3></a></div></div><div class="var-info" data-reactid="2631"><a href="../clj/clojure.core/interleave.html" data-reactid="2632"><h2 data-reactid="2633">(interleave)</h2><h2 data-reactid="2634">(interleave c1)</h2><h2 data-reactid="2635">(interleave c1 c2)</h2><h2 data-reactid="2636">(interleave c1 c2 &amp; colls)</h2></a><div class="section doc" data-reactid="2637">Returns a lazy seq of the first item in each coll, then the second etc.</div><div class="section" data-reactid="2638"><a href="../clj/clojure.core/interleave.html" data-reactid="2639"><h3 data-reactid="2640">+ Source</h3></a></div></div><div class="var-info" data-reactid="2641"><a href="../clj/clojure.core/intern.html" data-reactid="2642"><h2 data-reactid="2643">(intern ns name)</h2><h2 data-reactid="2644">(intern ns name val)</h2></a><div class="section doc" data-reactid="2645">Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var.</div><div class="section" data-reactid="2646"><a href="../clj/clojure.core/intern.html" data-reactid="2647"><h3 data-reactid="2648">+ Source</h3></a></div></div><div class="var-info" data-reactid="2649"><a href="../clj/clojure.core/interpose.html" data-reactid="2650"><h2 data-reactid="2651">(interpose sep)</h2><h2 data-reactid="2652">(interpose sep coll)</h2></a><div class="section doc" data-reactid="2653">Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided.</div><div class="section" data-reactid="2654"><a href="../clj/clojure.core/interpose.html" data-reactid="2655"><h3 data-reactid="2656">+ Source</h3></a></div></div><div class="var-info" data-reactid="2657"><a href="../clj/clojure.core/into.html" data-reactid="2658"><h2 data-reactid="2659">(into)</h2><h2 data-reactid="2660">(into to)</h2><h2 data-reactid="2661">(into to from)</h2><h2 data-reactid="2662">(into to xform from)</h2></a><div class="section doc" data-reactid="2663">Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.</div><div class="section" data-reactid="2664"><a href="../clj/clojure.core/into.html" data-reactid="2665"><h3 data-reactid="2666">+ Source</h3></a></div></div><div class="var-info" data-reactid="2667"><a href="../clj/clojure.core/into-array.html" data-reactid="2668"><h2 data-reactid="2669">(into-array aseq)</h2><h2 data-reactid="2670">(into-array type aseq)</h2></a><div class="section doc" data-reactid="2671">Returns an array with components set to the values in aseq. The array&#x27;s
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE.</div><div class="section" data-reactid="2672"><a href="../clj/clojure.core/into-array.html" data-reactid="2673"><h3 data-reactid="2674">+ Source</h3></a></div></div><div class="var-info" data-reactid="2675"><a href="../clj/clojure.core/ints.html" data-reactid="2676"><h2 data-reactid="2677">(ints xs)</h2></a><div class="section doc" data-reactid="2678">Casts to int[]</div><div class="section" data-reactid="2679"><a href="../clj/clojure.core/ints.html" data-reactid="2680"><h3 data-reactid="2681">+ Source</h3></a></div></div><div class="var-info" data-reactid="2682"><a href="../clj/clojure.core/io&#x27;e&#x27;.html" data-reactid="2683"><h2 data-reactid="2684">(io! &amp; body)</h2></a><div class="section doc" data-reactid="2685">If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message.</div><div class="section" data-reactid="2686"><a href="../clj/clojure.core/io&#x27;e&#x27;.html" data-reactid="2687"><h3 data-reactid="2688">+ Source</h3></a></div></div><div class="var-info" data-reactid="2689"><a href="../clj/clojure.core/isa&#x27;q&#x27;.html" data-reactid="2690"><h2 data-reactid="2691">(isa? child parent)</h2><h2 data-reactid="2692">(isa? h child parent)</h2></a><div class="section doc" data-reactid="2693">Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy</div><div class="section" data-reactid="2694"><a href="../clj/clojure.core/isa&#x27;q&#x27;.html" data-reactid="2695"><h3 data-reactid="2696">+ Source</h3></a></div></div><div class="var-info" data-reactid="2697"><a href="../clj/clojure.core/iterate.html" data-reactid="2698"><h2 data-reactid="2699">(iterate f x)</h2></a><div class="section doc" data-reactid="2700">Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects</div><div class="section" data-reactid="2701"><a href="../clj/clojure.core/iterate.html" data-reactid="2702"><h3 data-reactid="2703">+ Source</h3></a></div></div><div class="var-info" data-reactid="2704"><a href="../clj/clojure.core/iterator-seq.html" data-reactid="2705"><h2 data-reactid="2706">(iterator-seq iter)</h2></a><div class="section doc" data-reactid="2707">Returns a seq on a java.util.Iterator. Note that most collections
  providing iterators implement Iterable and thus support seq directly.
  Seqs cache values, thus iterator-seq should not be used on any
  iterator that repeatedly returns the same mutable object.</div><div class="section" data-reactid="2708"><a href="../clj/clojure.core/iterator-seq.html" data-reactid="2709"><h3 data-reactid="2710">+ Source</h3></a></div></div><div class="var-info" data-reactid="2711"><a href="../clj/clojure.core/juxt.html" data-reactid="2712"><h2 data-reactid="2713">(juxt f)</h2><h2 data-reactid="2714">(juxt f g)</h2><h2 data-reactid="2715">(juxt f g h)</h2><h2 data-reactid="2716">(juxt f g h &amp; fs)</h2></a><div class="section doc" data-reactid="2717">Takes a set of functions and returns a fn that is the juxtaposition
  of those fns.  The returned fn takes a variable number of args, and
  returns a vector containing the result of applying each fn to the
  args (left-to-right).
  ((juxt a b c) x) =&gt; [(a x) (b x) (c x)]</div><div class="section" data-reactid="2718"><a href="../clj/clojure.core/juxt.html" data-reactid="2719"><h3 data-reactid="2720">+ Source</h3></a></div></div><div class="var-info" data-reactid="2721"><a href="../clj/clojure.core/keep.html" data-reactid="2722"><h2 data-reactid="2723">(keep f)</h2><h2 data-reactid="2724">(keep f coll)</h2></a><div class="section doc" data-reactid="2725">Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="2726"><a href="../clj/clojure.core/keep.html" data-reactid="2727"><h3 data-reactid="2728">+ Source</h3></a></div></div><div class="var-info" data-reactid="2729"><a href="../clj/clojure.core/keep-indexed.html" data-reactid="2730"><h2 data-reactid="2731">(keep-indexed f)</h2><h2 data-reactid="2732">(keep-indexed f coll)</h2></a><div class="section doc" data-reactid="2733">Returns a lazy sequence of the non-nil results of (f index item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a stateful transducer when no collection is
  provided.</div><div class="section" data-reactid="2734"><a href="../clj/clojure.core/keep-indexed.html" data-reactid="2735"><h3 data-reactid="2736">+ Source</h3></a></div></div><div class="var-info" data-reactid="2737"><a href="../clj/clojure.core/key.html" data-reactid="2738"><h2 data-reactid="2739">(key e)</h2></a><div class="section doc" data-reactid="2740">Returns the key of the map entry.</div><div class="section" data-reactid="2741"><a href="../clj/clojure.core/key.html" data-reactid="2742"><h3 data-reactid="2743">+ Source</h3></a></div></div><div class="var-info" data-reactid="2744"><a href="../clj/clojure.core/keys.html" data-reactid="2745"><h2 data-reactid="2746">(keys map)</h2></a><div class="section doc" data-reactid="2747">Returns a sequence of the map&#x27;s keys, in the same order as (seq map).</div><div class="section" data-reactid="2748"><a href="../clj/clojure.core/keys.html" data-reactid="2749"><h3 data-reactid="2750">+ Source</h3></a></div></div><div class="var-info" data-reactid="2751"><a href="../clj/clojure.core/keyword.html" data-reactid="2752"><h2 data-reactid="2753">(keyword name)</h2><h2 data-reactid="2754">(keyword ns name)</h2></a><div class="section doc" data-reactid="2755">Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically.</div><div class="section" data-reactid="2756"><a href="../clj/clojure.core/keyword.html" data-reactid="2757"><h3 data-reactid="2758">+ Source</h3></a></div></div><div class="var-info" data-reactid="2759"><a href="../clj/clojure.core/keyword&#x27;q&#x27;.html" data-reactid="2760"><h2 data-reactid="2761">(keyword? x)</h2></a><div class="section doc" data-reactid="2762">Return true if x is a Keyword</div><div class="section" data-reactid="2763"><a href="../clj/clojure.core/keyword&#x27;q&#x27;.html" data-reactid="2764"><h3 data-reactid="2765">+ Source</h3></a></div></div><div class="var-info" data-reactid="2766"><a href="../clj/clojure.core/last.html" data-reactid="2767"><h2 data-reactid="2768">(last coll)</h2></a><div class="section doc" data-reactid="2769">Return the last item in coll, in linear time</div><div class="section" data-reactid="2770"><a href="../clj/clojure.core/last.html" data-reactid="2771"><h3 data-reactid="2772">+ Source</h3></a></div></div><div class="var-info" data-reactid="2773"><a href="../clj/clojure.core/lazy-cat.html" data-reactid="2774"><h2 data-reactid="2775">(lazy-cat &amp; colls)</h2></a><div class="section doc" data-reactid="2776">Expands to code which yields a lazy sequence of the concatenation
  of the supplied colls.  Each coll expr is not evaluated until it is
  needed. 

  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))</div><div class="section" data-reactid="2777"><a href="../clj/clojure.core/lazy-cat.html" data-reactid="2778"><h3 data-reactid="2779">+ Source</h3></a></div></div><div class="var-info" data-reactid="2780"><a href="../clj/clojure.core/lazy-seq.html" data-reactid="2781"><h2 data-reactid="2782">(lazy-seq &amp; body)</h2></a><div class="section doc" data-reactid="2783">Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?</div><div class="section" data-reactid="2784"><a href="../clj/clojure.core/lazy-seq.html" data-reactid="2785"><h3 data-reactid="2786">+ Source</h3></a></div></div><div class="var-info" data-reactid="2787"><a href="../clj/clojure.core/let.html" data-reactid="2788"><h2 data-reactid="2789">(let bindings &amp; body)</h2></a><div class="section doc" data-reactid="2790">binding =&gt; binding-form init-expr

  Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein.</div><div class="section" data-reactid="2791"><a href="../clj/clojure.core/let.html" data-reactid="2792"><h3 data-reactid="2793">+ Spec</h3></a></div><div class="section" data-reactid="2794"><a href="../clj/clojure.core/let.html" data-reactid="2795"><h3 data-reactid="2796">+ Source</h3></a></div></div><div class="var-info" data-reactid="2797"><a href="../clj/clojure.core/letfn.html" data-reactid="2798"><h2 data-reactid="2799">(letfn fnspecs &amp; body)</h2></a><div class="section doc" data-reactid="2800">fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.</div><div class="section" data-reactid="2801"><a href="../clj/clojure.core/letfn.html" data-reactid="2802"><h3 data-reactid="2803">+ Source</h3></a></div></div><div class="var-info" data-reactid="2804"><a href="../clj/clojure.core/line-seq.html" data-reactid="2805"><h2 data-reactid="2806">(line-seq rdr)</h2></a><div class="section doc" data-reactid="2807">Returns the lines of text from rdr as a lazy sequence of strings.
  rdr must implement java.io.BufferedReader.</div><div class="section" data-reactid="2808"><a href="../clj/clojure.core/line-seq.html" data-reactid="2809"><h3 data-reactid="2810">+ Source</h3></a></div></div><div class="var-info" data-reactid="2811"><a href="../clj/clojure.core/list.html" data-reactid="2812"><h2 data-reactid="2813">(list &amp; items)</h2></a><div class="section doc" data-reactid="2814">Creates a new list containing the items.</div><div class="section" data-reactid="2815"><a href="../clj/clojure.core/list.html" data-reactid="2816"><h3 data-reactid="2817">+ Source</h3></a></div></div><div class="var-info" data-reactid="2818"><a href="../clj/clojure.core/list&#x27;a&#x27;.html" data-reactid="2819"><h2 data-reactid="2820">(list* args)</h2><h2 data-reactid="2821">(list* a args)</h2><h2 data-reactid="2822">(list* a b args)</h2><h2 data-reactid="2823">(list* a b c args)</h2><h2 data-reactid="2824">(list* a b c d &amp; more)</h2></a><div class="section doc" data-reactid="2825">Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.</div><div class="section" data-reactid="2826"><a href="../clj/clojure.core/list&#x27;a&#x27;.html" data-reactid="2827"><h3 data-reactid="2828">+ Source</h3></a></div></div><div class="var-info" data-reactid="2829"><a href="../clj/clojure.core/list&#x27;q&#x27;.html" data-reactid="2830"><h2 data-reactid="2831">(list? x)</h2></a><div class="section doc" data-reactid="2832">Returns true if x implements IPersistentList</div><div class="section" data-reactid="2833"><a href="../clj/clojure.core/list&#x27;q&#x27;.html" data-reactid="2834"><h3 data-reactid="2835">+ Source</h3></a></div></div><div class="var-info" data-reactid="2836"><a href="../clj/clojure.core/load.html" data-reactid="2837"><h2 data-reactid="2838">(load &amp; paths)</h2></a><div class="section doc" data-reactid="2839">Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.</div><div class="section" data-reactid="2840"><a href="../clj/clojure.core/load.html" data-reactid="2841"><h3 data-reactid="2842">+ Source</h3></a></div></div><div class="var-info" data-reactid="2843"><a href="../clj/clojure.core/load-file.html" data-reactid="2844"><h2 data-reactid="2845">(load-file name)</h2></a><div class="section doc" data-reactid="2846">Sequentially read and evaluate the set of forms contained in the file.</div></div><div class="var-info" data-reactid="2847"><a href="../clj/clojure.core/load-reader.html" data-reactid="2848"><h2 data-reactid="2849">(load-reader rdr)</h2></a><div class="section doc" data-reactid="2850">Sequentially read and evaluate the set of forms contained in the
  stream/file</div><div class="section" data-reactid="2851"><a href="../clj/clojure.core/load-reader.html" data-reactid="2852"><h3 data-reactid="2853">+ Source</h3></a></div></div><div class="var-info" data-reactid="2854"><a href="../clj/clojure.core/load-string.html" data-reactid="2855"><h2 data-reactid="2856">(load-string s)</h2></a><div class="section doc" data-reactid="2857">Sequentially read and evaluate the set of forms contained in the
  string</div><div class="section" data-reactid="2858"><a href="../clj/clojure.core/load-string.html" data-reactid="2859"><h3 data-reactid="2860">+ Source</h3></a></div></div><div class="var-info" data-reactid="2861"><a href="../clj/clojure.core/loaded-libs.html" data-reactid="2862"><h2 data-reactid="2863">(loaded-libs)</h2></a><div class="section doc" data-reactid="2864">Returns a sorted set of symbols naming the currently loaded libs</div><div class="section" data-reactid="2865"><a href="../clj/clojure.core/loaded-libs.html" data-reactid="2866"><h3 data-reactid="2867">+ Source</h3></a></div></div><div class="var-info" data-reactid="2868"><a href="../clj/clojure.core/locking.html" data-reactid="2869"><h2 data-reactid="2870">(locking x &amp; body)</h2></a><div class="section doc" data-reactid="2871">Executes exprs in an implicit do, while holding the monitor of x.
  Will release the monitor of x in all circumstances.</div><div class="section" data-reactid="2872"><a href="../clj/clojure.core/locking.html" data-reactid="2873"><h3 data-reactid="2874">+ Source</h3></a></div></div><div class="var-info" data-reactid="2875"><a href="../clj/clojure.core/long.html" data-reactid="2876"><h2 data-reactid="2877">(long x)</h2></a><div class="section doc" data-reactid="2878">Coerce to long</div><div class="section" data-reactid="2879"><a href="../clj/clojure.core/long.html" data-reactid="2880"><h3 data-reactid="2881">+ Source</h3></a></div></div><div class="var-info" data-reactid="2882"><a href="../clj/clojure.core/long-array.html" data-reactid="2883"><h2 data-reactid="2884">(long-array size-or-seq)</h2><h2 data-reactid="2885">(long-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="2886">Creates an array of longs</div><div class="section" data-reactid="2887"><a href="../clj/clojure.core/long-array.html" data-reactid="2888"><h3 data-reactid="2889">+ Source</h3></a></div></div><div class="var-info" data-reactid="2890"><a href="../clj/clojure.core/longs.html" data-reactid="2891"><h2 data-reactid="2892">(longs xs)</h2></a><div class="section doc" data-reactid="2893">Casts to long[]</div><div class="section" data-reactid="2894"><a href="../clj/clojure.core/longs.html" data-reactid="2895"><h3 data-reactid="2896">+ Source</h3></a></div></div><div class="var-info" data-reactid="2897"><a href="../clj/clojure.core/loop.html" data-reactid="2898"><h2 data-reactid="2899">(loop bindings &amp; body)</h2></a><div class="section doc" data-reactid="2900">Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein. Acts as a recur target.</div><div class="section" data-reactid="2901"><a href="../clj/clojure.core/loop.html" data-reactid="2902"><h3 data-reactid="2903">+ Source</h3></a></div></div><div class="var-info" data-reactid="2904"><a href="../clj/clojure.core/macroexpand.html" data-reactid="2905"><h2 data-reactid="2906">(macroexpand form)</h2></a><div class="section doc" data-reactid="2907">Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms.</div><div class="section" data-reactid="2908"><a href="../clj/clojure.core/macroexpand.html" data-reactid="2909"><h3 data-reactid="2910">+ Source</h3></a></div></div><div class="var-info" data-reactid="2911"><a href="../clj/clojure.core/macroexpand-1.html" data-reactid="2912"><h2 data-reactid="2913">(macroexpand-1 form)</h2></a><div class="section doc" data-reactid="2914">If form represents a macro form, returns its expansion,
  else returns form.</div><div class="section" data-reactid="2915"><a href="../clj/clojure.core/macroexpand-1.html" data-reactid="2916"><h3 data-reactid="2917">+ Source</h3></a></div></div><div class="var-info" data-reactid="2918"><a href="../clj/clojure.core/make-array.html" data-reactid="2919"><h2 data-reactid="2920">(make-array type len)</h2><h2 data-reactid="2921">(make-array type dim &amp; more-dims)</h2></a><div class="section doc" data-reactid="2922">Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE.</div><div class="section" data-reactid="2923"><a href="../clj/clojure.core/make-array.html" data-reactid="2924"><h3 data-reactid="2925">+ Source</h3></a></div></div><div class="var-info" data-reactid="2926"><a href="../clj/clojure.core/make-hierarchy.html" data-reactid="2927"><h2 data-reactid="2928">(make-hierarchy)</h2></a><div class="section doc" data-reactid="2929">Creates a hierarchy object for use with derive, isa? etc.</div><div class="section" data-reactid="2930"><a href="../clj/clojure.core/make-hierarchy.html" data-reactid="2931"><h3 data-reactid="2932">+ Source</h3></a></div></div><div class="var-info" data-reactid="2933"><a href="../clj/clojure.core/map.html" data-reactid="2934"><h2 data-reactid="2935">(map f)</h2><h2 data-reactid="2936">(map f coll)</h2><h2 data-reactid="2937">(map f c1 c2)</h2><h2 data-reactid="2938">(map f c1 c2 c3)</h2><h2 data-reactid="2939">(map f c1 c2 c3 &amp; colls)</h2></a><div class="section doc" data-reactid="2940">Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.</div><div class="section" data-reactid="2941"><a href="../clj/clojure.core/map.html" data-reactid="2942"><h3 data-reactid="2943">+ Source</h3></a></div></div><div class="var-info" data-reactid="2944"><a href="../clj/clojure.core/map-entry&#x27;q&#x27;.html" data-reactid="2945"><h2 data-reactid="2946">(map-entry? x)</h2></a><div class="section doc" data-reactid="2947">Return true if x is a map entry</div><div class="section" data-reactid="2948"><a href="../clj/clojure.core/map-entry&#x27;q&#x27;.html" data-reactid="2949"><h3 data-reactid="2950">+ Source</h3></a></div></div><div class="var-info" data-reactid="2951"><a href="../clj/clojure.core/map-indexed.html" data-reactid="2952"><h2 data-reactid="2953">(map-indexed f)</h2><h2 data-reactid="2954">(map-indexed f coll)</h2></a><div class="section doc" data-reactid="2955">Returns a lazy sequence consisting of the result of applying f to 0
  and the first item of coll, followed by applying f to 1 and the second
  item in coll, etc, until coll is exhausted. Thus function f should
  accept 2 arguments, index and item. Returns a stateful transducer when
  no collection is provided.</div><div class="section" data-reactid="2956"><a href="../clj/clojure.core/map-indexed.html" data-reactid="2957"><h3 data-reactid="2958">+ Source</h3></a></div></div><div class="var-info" data-reactid="2959"><a href="../clj/clojure.core/map&#x27;q&#x27;.html" data-reactid="2960"><h2 data-reactid="2961">(map? x)</h2></a><div class="section doc" data-reactid="2962">Return true if x implements IPersistentMap</div><div class="section" data-reactid="2963"><a href="../clj/clojure.core/map&#x27;q&#x27;.html" data-reactid="2964"><h3 data-reactid="2965">+ Source</h3></a></div></div><div class="var-info" data-reactid="2966"><a href="../clj/clojure.core/mapcat.html" data-reactid="2967"><h2 data-reactid="2968">(mapcat f)</h2><h2 data-reactid="2969">(mapcat f &amp; colls)</h2></a><div class="section doc" data-reactid="2970">Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided</div><div class="section" data-reactid="2971"><a href="../clj/clojure.core/mapcat.html" data-reactid="2972"><h3 data-reactid="2973">+ Source</h3></a></div></div><div class="var-info" data-reactid="2974"><a href="../clj/clojure.core/mapv.html" data-reactid="2975"><h2 data-reactid="2976">(mapv f coll)</h2><h2 data-reactid="2977">(mapv f c1 c2)</h2><h2 data-reactid="2978">(mapv f c1 c2 c3)</h2><h2 data-reactid="2979">(mapv f c1 c2 c3 &amp; colls)</h2></a><div class="section doc" data-reactid="2980">Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.</div><div class="section" data-reactid="2981"><a href="../clj/clojure.core/mapv.html" data-reactid="2982"><h3 data-reactid="2983">+ Source</h3></a></div></div><div class="var-info" data-reactid="2984"><a href="../clj/clojure.core/max.html" data-reactid="2985"><h2 data-reactid="2986">(max x)</h2><h2 data-reactid="2987">(max x y)</h2><h2 data-reactid="2988">(max x y &amp; more)</h2></a><div class="section doc" data-reactid="2989">Returns the greatest of the nums.</div><div class="section" data-reactid="2990"><a href="../clj/clojure.core/max.html" data-reactid="2991"><h3 data-reactid="2992">+ Source</h3></a></div></div><div class="var-info" data-reactid="2993"><a href="../clj/clojure.core/max-key.html" data-reactid="2994"><h2 data-reactid="2995">(max-key k x)</h2><h2 data-reactid="2996">(max-key k x y)</h2><h2 data-reactid="2997">(max-key k x y &amp; more)</h2></a><div class="section doc" data-reactid="2998">Returns the x for which (k x), a number, is greatest.

  If there are multiple such xs, the last one is returned.</div><div class="section" data-reactid="2999"><a href="../clj/clojure.core/max-key.html" data-reactid="3000"><h3 data-reactid="3001">+ Source</h3></a></div></div><div class="var-info" data-reactid="3002"><a href="../clj/clojure.core/memfn.html" data-reactid="3003"><h2 data-reactid="3004">(memfn name &amp; args)</h2></a><div class="section doc" data-reactid="3005">Expands into code that creates a fn that expects to be passed an
  object and any args and calls the named instance method on the
  object passing the args. Use when you want to treat a Java method as
  a first-class fn. name may be type-hinted with the method receiver&#x27;s
  type in order to avoid reflective calls.</div><div class="section" data-reactid="3006"><a href="../clj/clojure.core/memfn.html" data-reactid="3007"><h3 data-reactid="3008">+ Source</h3></a></div></div><div class="var-info" data-reactid="3009"><a href="../clj/clojure.core/memoize.html" data-reactid="3010"><h2 data-reactid="3011">(memoize f)</h2></a><div class="section doc" data-reactid="3012">Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use.</div><div class="section" data-reactid="3013"><a href="../clj/clojure.core/memoize.html" data-reactid="3014"><h3 data-reactid="3015">+ Source</h3></a></div></div><div class="var-info" data-reactid="3016"><a href="../clj/clojure.core/merge.html" data-reactid="3017"><h2 data-reactid="3018">(merge &amp; maps)</h2></a><div class="section doc" data-reactid="3019">Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.</div><div class="section" data-reactid="3020"><a href="../clj/clojure.core/merge.html" data-reactid="3021"><h3 data-reactid="3022">+ Source</h3></a></div></div><div class="var-info" data-reactid="3023"><a href="../clj/clojure.core/merge-with.html" data-reactid="3024"><h2 data-reactid="3025">(merge-with f &amp; maps)</h2></a><div class="section doc" data-reactid="3026">Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (f val-in-result val-in-latter).</div><div class="section" data-reactid="3027"><a href="../clj/clojure.core/merge-with.html" data-reactid="3028"><h3 data-reactid="3029">+ Source</h3></a></div></div><div class="var-info" data-reactid="3030"><a href="../clj/clojure.core/meta.html" data-reactid="3031"><h2 data-reactid="3032">(meta obj)</h2></a><div class="section doc" data-reactid="3033">Returns the metadata of obj, returns nil if there is no metadata.</div><div class="section" data-reactid="3034"><a href="../clj/clojure.core/meta.html" data-reactid="3035"><h3 data-reactid="3036">+ Source</h3></a></div></div><div class="var-info" data-reactid="3037"><a href="../clj/clojure.core/method-sig.html" data-reactid="3038"><h2 data-reactid="3039">(method-sig meth)</h2></a><div class="section" data-reactid="3040"><a href="../clj/clojure.core/method-sig.html" data-reactid="3041"><h3 data-reactid="3042">+ Source</h3></a></div></div><div class="var-info" data-reactid="3043"><a href="../clj/clojure.core/methods.html" data-reactid="3044"><h2 data-reactid="3045">(methods multifn)</h2></a><div class="section doc" data-reactid="3046">Given a multimethod, returns a map of dispatch values -&gt; dispatch fns</div><div class="section" data-reactid="3047"><a href="../clj/clojure.core/methods.html" data-reactid="3048"><h3 data-reactid="3049">+ Source</h3></a></div></div><div class="var-info" data-reactid="3050"><a href="../clj/clojure.core/min.html" data-reactid="3051"><h2 data-reactid="3052">(min x)</h2><h2 data-reactid="3053">(min x y)</h2><h2 data-reactid="3054">(min x y &amp; more)</h2></a><div class="section doc" data-reactid="3055">Returns the least of the nums.</div><div class="section" data-reactid="3056"><a href="../clj/clojure.core/min.html" data-reactid="3057"><h3 data-reactid="3058">+ Source</h3></a></div></div><div class="var-info" data-reactid="3059"><a href="../clj/clojure.core/min-key.html" data-reactid="3060"><h2 data-reactid="3061">(min-key k x)</h2><h2 data-reactid="3062">(min-key k x y)</h2><h2 data-reactid="3063">(min-key k x y &amp; more)</h2></a><div class="section doc" data-reactid="3064">Returns the x for which (k x), a number, is least.

  If there are multiple such xs, the last one is returned.</div><div class="section" data-reactid="3065"><a href="../clj/clojure.core/min-key.html" data-reactid="3066"><h3 data-reactid="3067">+ Source</h3></a></div></div><div class="var-info" data-reactid="3068"><a href="../clj/clojure.core/mix-collection-hash.html" data-reactid="3069"><h2 data-reactid="3070">(mix-collection-hash hash-basis count)</h2></a><div class="section doc" data-reactid="3071">Mix final collection hash for ordered or unordered collections.
   hash-basis is the combined collection hash, count is the number
   of elements included in the basis. Note this is the hash code
   consistent with =, different from .hashCode.
   See http://clojure.org/data_structures#hash for full algorithms.</div><div class="section" data-reactid="3072"><a href="../clj/clojure.core/mix-collection-hash.html" data-reactid="3073"><h3 data-reactid="3074">+ Source</h3></a></div></div><div class="var-info" data-reactid="3075"><a href="../clj/clojure.core/mod.html" data-reactid="3076"><h2 data-reactid="3077">(mod num div)</h2></a><div class="section doc" data-reactid="3078">Modulus of num and div. Truncates toward negative infinity.</div><div class="section" data-reactid="3079"><a href="../clj/clojure.core/mod.html" data-reactid="3080"><h3 data-reactid="3081">+ Source</h3></a></div></div><div class="var-info" data-reactid="3082"><a href="../clj/clojure.core/munge.html" data-reactid="3083"><h2 data-reactid="3084">(munge s)</h2></a><div class="section" data-reactid="3085"><a href="../clj/clojure.core/munge.html" data-reactid="3086"><h3 data-reactid="3087">+ Source</h3></a></div></div><div class="var-info" data-reactid="3088"><a href="../clj/clojure.core/name.html" data-reactid="3089"><h2 data-reactid="3090">(name x)</h2></a><div class="section doc" data-reactid="3091">Returns the name String of a string, symbol or keyword.</div><div class="section" data-reactid="3092"><a href="../clj/clojure.core/name.html" data-reactid="3093"><h3 data-reactid="3094">+ Source</h3></a></div></div><div class="var-info" data-reactid="3095"><a href="../clj/clojure.core/namespace.html" data-reactid="3096"><h2 data-reactid="3097">(namespace x)</h2></a><div class="section doc" data-reactid="3098">Returns the namespace String of a symbol or keyword, or nil if not present.</div><div class="section" data-reactid="3099"><a href="../clj/clojure.core/namespace.html" data-reactid="3100"><h3 data-reactid="3101">+ Source</h3></a></div></div><div class="var-info" data-reactid="3102"><a href="../clj/clojure.core/namespace-munge.html" data-reactid="3103"><h2 data-reactid="3104">(namespace-munge ns)</h2></a><div class="section doc" data-reactid="3105">Convert a Clojure namespace name to a legal Java package name.</div><div class="section" data-reactid="3106"><a href="../clj/clojure.core/namespace-munge.html" data-reactid="3107"><h3 data-reactid="3108">+ Source</h3></a></div></div><div class="var-info" data-reactid="3109"><a href="../clj/clojure.core/nat-int&#x27;q&#x27;.html" data-reactid="3110"><h2 data-reactid="3111">(nat-int? x)</h2></a><div class="section doc" data-reactid="3112">Return true if x is a non-negative fixed precision integer</div><div class="section" data-reactid="3113"><a href="../clj/clojure.core/nat-int&#x27;q&#x27;.html" data-reactid="3114"><h3 data-reactid="3115">+ Source</h3></a></div></div><div class="var-info" data-reactid="3116"><a href="../clj/clojure.core/neg-int&#x27;q&#x27;.html" data-reactid="3117"><h2 data-reactid="3118">(neg-int? x)</h2></a><div class="section doc" data-reactid="3119">Return true if x is a negative fixed precision integer</div><div class="section" data-reactid="3120"><a href="../clj/clojure.core/neg-int&#x27;q&#x27;.html" data-reactid="3121"><h3 data-reactid="3122">+ Source</h3></a></div></div><div class="var-info" data-reactid="3123"><a href="../clj/clojure.core/neg&#x27;q&#x27;.html" data-reactid="3124"><h2 data-reactid="3125">(neg? num)</h2></a><div class="section doc" data-reactid="3126">Returns true if num is less than zero, else false</div><div class="section" data-reactid="3127"><a href="../clj/clojure.core/neg&#x27;q&#x27;.html" data-reactid="3128"><h3 data-reactid="3129">+ Source</h3></a></div></div><div class="var-info" data-reactid="3130"><a href="../clj/clojure.core/newline.html" data-reactid="3131"><h2 data-reactid="3132">(newline)</h2></a><div class="section doc" data-reactid="3133">Writes a platform-specific newline to *out*</div><div class="section" data-reactid="3134"><a href="../clj/clojure.core/newline.html" data-reactid="3135"><h3 data-reactid="3136">+ Source</h3></a></div></div><div class="var-info" data-reactid="3137"><a href="../clj/clojure.core/next.html" data-reactid="3138"><h2 data-reactid="3139">(next coll)</h2></a><div class="section doc" data-reactid="3140">Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.</div><div class="section" data-reactid="3141"><a href="../clj/clojure.core/next.html" data-reactid="3142"><h3 data-reactid="3143">+ Source</h3></a></div></div><div class="var-info" data-reactid="3144"><a href="../clj/clojure.core/nfirst.html" data-reactid="3145"><h2 data-reactid="3146">(nfirst x)</h2></a><div class="section doc" data-reactid="3147">Same as (next (first x))</div><div class="section" data-reactid="3148"><a href="../clj/clojure.core/nfirst.html" data-reactid="3149"><h3 data-reactid="3150">+ Source</h3></a></div></div><div class="var-info" data-reactid="3151"><a href="../clj/clojure.core/nil&#x27;q&#x27;.html" data-reactid="3152"><h2 data-reactid="3153">(nil? x)</h2></a><div class="section doc" data-reactid="3154">Returns true if x is nil, false otherwise.</div><div class="section" data-reactid="3155"><a href="../clj/clojure.core/nil&#x27;q&#x27;.html" data-reactid="3156"><h3 data-reactid="3157">+ Source</h3></a></div></div><div class="var-info" data-reactid="3158"><a href="../clj/clojure.core/nnext.html" data-reactid="3159"><h2 data-reactid="3160">(nnext x)</h2></a><div class="section doc" data-reactid="3161">Same as (next (next x))</div><div class="section" data-reactid="3162"><a href="../clj/clojure.core/nnext.html" data-reactid="3163"><h3 data-reactid="3164">+ Source</h3></a></div></div><div class="var-info" data-reactid="3165"><a href="../clj/clojure.core/not.html" data-reactid="3166"><h2 data-reactid="3167">(not x)</h2></a><div class="section doc" data-reactid="3168">Returns true if x is logical false, false otherwise.</div><div class="section" data-reactid="3169"><a href="../clj/clojure.core/not.html" data-reactid="3170"><h3 data-reactid="3171">+ Source</h3></a></div></div><div class="var-info" data-reactid="3172"><a href="../clj/clojure.core/not-any&#x27;q&#x27;.html" data-reactid="3173"><h2 data-reactid="3174">(not-any? pred coll)</h2></a><div class="section doc" data-reactid="3175">Returns false if (pred x) is logical true for any x in coll,
  else true.</div><div class="section" data-reactid="3176"><a href="../clj/clojure.core/not-any&#x27;q&#x27;.html" data-reactid="3177"><h3 data-reactid="3178">+ Source</h3></a></div></div><div class="var-info" data-reactid="3179"><a href="../clj/clojure.core/not-empty.html" data-reactid="3180"><h2 data-reactid="3181">(not-empty coll)</h2></a><div class="section doc" data-reactid="3182">If coll is empty, returns nil, else coll</div><div class="section" data-reactid="3183"><a href="../clj/clojure.core/not-empty.html" data-reactid="3184"><h3 data-reactid="3185">+ Source</h3></a></div></div><div class="var-info" data-reactid="3186"><a href="../clj/clojure.core/not-every&#x27;q&#x27;.html" data-reactid="3187"><h2 data-reactid="3188">(not-every? pred coll)</h2></a><div class="section doc" data-reactid="3189">Returns false if (pred x) is logical true for every x in
  coll, else true.</div><div class="section" data-reactid="3190"><a href="../clj/clojure.core/not-every&#x27;q&#x27;.html" data-reactid="3191"><h3 data-reactid="3192">+ Source</h3></a></div></div><div class="var-info" data-reactid="3193"><a href="../clj/clojure.core/not=.html" data-reactid="3194"><h2 data-reactid="3195">(not= x)</h2><h2 data-reactid="3196">(not= x y)</h2><h2 data-reactid="3197">(not= x y &amp; more)</h2></a><div class="section doc" data-reactid="3198">Same as (not (= obj1 obj2))</div><div class="section" data-reactid="3199"><a href="../clj/clojure.core/not=.html" data-reactid="3200"><h3 data-reactid="3201">+ Source</h3></a></div></div><div class="var-info" data-reactid="3202"><a href="../clj/clojure.core/ns.html" data-reactid="3203"><h2 data-reactid="3204">(ns name docstring? attr-map? references*)</h2></a><div class="section doc" data-reactid="3205">Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &#x27;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))</div><div class="section" data-reactid="3206"><a href="../clj/clojure.core/ns.html" data-reactid="3207"><h3 data-reactid="3208">+ Spec</h3></a></div><div class="section" data-reactid="3209"><a href="../clj/clojure.core/ns.html" data-reactid="3210"><h3 data-reactid="3211">+ Source</h3></a></div></div><div class="var-info" data-reactid="3212"><a href="../clj/clojure.core/ns-aliases.html" data-reactid="3213"><h2 data-reactid="3214">(ns-aliases ns)</h2></a><div class="section doc" data-reactid="3215">Returns a map of the aliases for the namespace.</div><div class="section" data-reactid="3216"><a href="../clj/clojure.core/ns-aliases.html" data-reactid="3217"><h3 data-reactid="3218">+ Source</h3></a></div></div><div class="var-info" data-reactid="3219"><a href="../clj/clojure.core/ns-imports.html" data-reactid="3220"><h2 data-reactid="3221">(ns-imports ns)</h2></a><div class="section doc" data-reactid="3222">Returns a map of the import mappings for the namespace.</div><div class="section" data-reactid="3223"><a href="../clj/clojure.core/ns-imports.html" data-reactid="3224"><h3 data-reactid="3225">+ Source</h3></a></div></div><div class="var-info" data-reactid="3226"><a href="../clj/clojure.core/ns-interns.html" data-reactid="3227"><h2 data-reactid="3228">(ns-interns ns)</h2></a><div class="section doc" data-reactid="3229">Returns a map of the intern mappings for the namespace.</div><div class="section" data-reactid="3230"><a href="../clj/clojure.core/ns-interns.html" data-reactid="3231"><h3 data-reactid="3232">+ Source</h3></a></div></div><div class="var-info" data-reactid="3233"><a href="../clj/clojure.core/ns-map.html" data-reactid="3234"><h2 data-reactid="3235">(ns-map ns)</h2></a><div class="section doc" data-reactid="3236">Returns a map of all the mappings for the namespace.</div><div class="section" data-reactid="3237"><a href="../clj/clojure.core/ns-map.html" data-reactid="3238"><h3 data-reactid="3239">+ Source</h3></a></div></div><div class="var-info" data-reactid="3240"><a href="../clj/clojure.core/ns-name.html" data-reactid="3241"><h2 data-reactid="3242">(ns-name ns)</h2></a><div class="section doc" data-reactid="3243">Returns the name of the namespace, a symbol.</div><div class="section" data-reactid="3244"><a href="../clj/clojure.core/ns-name.html" data-reactid="3245"><h3 data-reactid="3246">+ Source</h3></a></div></div><div class="var-info" data-reactid="3247"><a href="../clj/clojure.core/ns-publics.html" data-reactid="3248"><h2 data-reactid="3249">(ns-publics ns)</h2></a><div class="section doc" data-reactid="3250">Returns a map of the public intern mappings for the namespace.</div><div class="section" data-reactid="3251"><a href="../clj/clojure.core/ns-publics.html" data-reactid="3252"><h3 data-reactid="3253">+ Source</h3></a></div></div><div class="var-info" data-reactid="3254"><a href="../clj/clojure.core/ns-refers.html" data-reactid="3255"><h2 data-reactid="3256">(ns-refers ns)</h2></a><div class="section doc" data-reactid="3257">Returns a map of the refer mappings for the namespace.</div><div class="section" data-reactid="3258"><a href="../clj/clojure.core/ns-refers.html" data-reactid="3259"><h3 data-reactid="3260">+ Source</h3></a></div></div><div class="var-info" data-reactid="3261"><a href="../clj/clojure.core/ns-resolve.html" data-reactid="3262"><h2 data-reactid="3263">(ns-resolve ns sym)</h2><h2 data-reactid="3264">(ns-resolve ns env sym)</h2></a><div class="section doc" data-reactid="3265">Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.</div><div class="section" data-reactid="3266"><a href="../clj/clojure.core/ns-resolve.html" data-reactid="3267"><h3 data-reactid="3268">+ Source</h3></a></div></div><div class="var-info" data-reactid="3269"><a href="../clj/clojure.core/ns-unalias.html" data-reactid="3270"><h2 data-reactid="3271">(ns-unalias ns sym)</h2></a><div class="section doc" data-reactid="3272">Removes the alias for the symbol from the namespace.</div><div class="section" data-reactid="3273"><a href="../clj/clojure.core/ns-unalias.html" data-reactid="3274"><h3 data-reactid="3275">+ Source</h3></a></div></div><div class="var-info" data-reactid="3276"><a href="../clj/clojure.core/ns-unmap.html" data-reactid="3277"><h2 data-reactid="3278">(ns-unmap ns sym)</h2></a><div class="section doc" data-reactid="3279">Removes the mappings for the symbol from the namespace.</div><div class="section" data-reactid="3280"><a href="../clj/clojure.core/ns-unmap.html" data-reactid="3281"><h3 data-reactid="3282">+ Source</h3></a></div></div><div class="var-info" data-reactid="3283"><a href="../clj/clojure.core/nth.html" data-reactid="3284"><h2 data-reactid="3285">(nth coll index)</h2><h2 data-reactid="3286">(nth coll index not-found)</h2></a><div class="section doc" data-reactid="3287">Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.</div><div class="section" data-reactid="3288"><a href="../clj/clojure.core/nth.html" data-reactid="3289"><h3 data-reactid="3290">+ Source</h3></a></div></div><div class="var-info" data-reactid="3291"><a href="../clj/clojure.core/nthnext.html" data-reactid="3292"><h2 data-reactid="3293">(nthnext coll n)</h2></a><div class="section doc" data-reactid="3294">Returns the nth next of coll, (seq coll) when n is 0.</div><div class="section" data-reactid="3295"><a href="../clj/clojure.core/nthnext.html" data-reactid="3296"><h3 data-reactid="3297">+ Source</h3></a></div></div><div class="var-info" data-reactid="3298"><a href="../clj/clojure.core/nthrest.html" data-reactid="3299"><h2 data-reactid="3300">(nthrest coll n)</h2></a><div class="section doc" data-reactid="3301">Returns the nth rest of coll, coll when n is 0.</div><div class="section" data-reactid="3302"><a href="../clj/clojure.core/nthrest.html" data-reactid="3303"><h3 data-reactid="3304">+ Source</h3></a></div></div><div class="var-info" data-reactid="3305"><a href="../clj/clojure.core/num.html" data-reactid="3306"><h2 data-reactid="3307">(num x)</h2></a><div class="section doc" data-reactid="3308">Coerce to Number</div><div class="section" data-reactid="3309"><a href="../clj/clojure.core/num.html" data-reactid="3310"><h3 data-reactid="3311">+ Source</h3></a></div></div><div class="var-info" data-reactid="3312"><a href="../clj/clojure.core/number&#x27;q&#x27;.html" data-reactid="3313"><h2 data-reactid="3314">(number? x)</h2></a><div class="section doc" data-reactid="3315">Returns true if x is a Number</div><div class="section" data-reactid="3316"><a href="../clj/clojure.core/number&#x27;q&#x27;.html" data-reactid="3317"><h3 data-reactid="3318">+ Source</h3></a></div></div><div class="var-info" data-reactid="3319"><a href="../clj/clojure.core/numerator.html" data-reactid="3320"><h2 data-reactid="3321">(numerator r)</h2></a><div class="section doc" data-reactid="3322">Returns the numerator part of a Ratio.</div><div class="section" data-reactid="3323"><a href="../clj/clojure.core/numerator.html" data-reactid="3324"><h3 data-reactid="3325">+ Source</h3></a></div></div><div class="var-info" data-reactid="3326"><a href="../clj/clojure.core/object-array.html" data-reactid="3327"><h2 data-reactid="3328">(object-array size-or-seq)</h2></a><div class="section doc" data-reactid="3329">Creates an array of objects</div><div class="section" data-reactid="3330"><a href="../clj/clojure.core/object-array.html" data-reactid="3331"><h3 data-reactid="3332">+ Source</h3></a></div></div><div class="var-info" data-reactid="3333"><a href="../clj/clojure.core/odd&#x27;q&#x27;.html" data-reactid="3334"><h2 data-reactid="3335">(odd? n)</h2></a><div class="section doc" data-reactid="3336">Returns true if n is odd, throws an exception if n is not an integer</div><div class="section" data-reactid="3337"><a href="../clj/clojure.core/odd&#x27;q&#x27;.html" data-reactid="3338"><h3 data-reactid="3339">+ Source</h3></a></div></div><div class="var-info" data-reactid="3340"><a href="../clj/clojure.core/or.html" data-reactid="3341"><h2 data-reactid="3342">(or)</h2><h2 data-reactid="3343">(or x)</h2><h2 data-reactid="3344">(or x &amp; next)</h2></a><div class="section doc" data-reactid="3345">Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&#x27;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.</div><div class="section" data-reactid="3346"><a href="../clj/clojure.core/or.html" data-reactid="3347"><h3 data-reactid="3348">+ Source</h3></a></div></div><div class="var-info" data-reactid="3349"><a href="../clj/clojure.core/parents.html" data-reactid="3350"><h2 data-reactid="3351">(parents tag)</h2><h2 data-reactid="3352">(parents h tag)</h2></a><div class="section doc" data-reactid="3353">Returns the immediate parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy</div><div class="section" data-reactid="3354"><a href="../clj/clojure.core/parents.html" data-reactid="3355"><h3 data-reactid="3356">+ Source</h3></a></div></div><div class="var-info" data-reactid="3357"><a href="../clj/clojure.core/partial.html" data-reactid="3358"><h2 data-reactid="3359">(partial f)</h2><h2 data-reactid="3360">(partial f arg1)</h2><h2 data-reactid="3361">(partial f arg1 arg2)</h2><h2 data-reactid="3362">(partial f arg1 arg2 arg3)</h2><h2 data-reactid="3363">(partial f arg1 arg2 arg3 &amp; more)</h2></a><div class="section doc" data-reactid="3364">Takes a function f and fewer than the normal arguments to f, and
  returns a fn that takes a variable number of additional args. When
  called, the returned function calls f with args + additional args.</div><div class="section" data-reactid="3365"><a href="../clj/clojure.core/partial.html" data-reactid="3366"><h3 data-reactid="3367">+ Source</h3></a></div></div><div class="var-info" data-reactid="3368"><a href="../clj/clojure.core/partition.html" data-reactid="3369"><h2 data-reactid="3370">(partition n coll)</h2><h2 data-reactid="3371">(partition n step coll)</h2><h2 data-reactid="3372">(partition n step pad coll)</h2></a><div class="section doc" data-reactid="3373">Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.</div><div class="section" data-reactid="3374"><a href="../clj/clojure.core/partition.html" data-reactid="3375"><h3 data-reactid="3376">+ Source</h3></a></div></div><div class="var-info" data-reactid="3377"><a href="../clj/clojure.core/partition-all.html" data-reactid="3378"><h2 data-reactid="3379">(partition-all n)</h2><h2 data-reactid="3380">(partition-all n coll)</h2><h2 data-reactid="3381">(partition-all n step coll)</h2></a><div class="section doc" data-reactid="3382">Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.  Returns a stateful
  transducer when no collection is provided.</div><div class="section" data-reactid="3383"><a href="../clj/clojure.core/partition-all.html" data-reactid="3384"><h3 data-reactid="3385">+ Source</h3></a></div></div><div class="var-info" data-reactid="3386"><a href="../clj/clojure.core/partition-by.html" data-reactid="3387"><h2 data-reactid="3388">(partition-by f)</h2><h2 data-reactid="3389">(partition-by f coll)</h2></a><div class="section doc" data-reactid="3390">Applies f to each value in coll, splitting it each time f returns a
   new value.  Returns a lazy seq of partitions.  Returns a stateful
   transducer when no collection is provided.</div><div class="section" data-reactid="3391"><a href="../clj/clojure.core/partition-by.html" data-reactid="3392"><h3 data-reactid="3393">+ Source</h3></a></div></div><div class="var-info" data-reactid="3394"><a href="../clj/clojure.core/pcalls.html" data-reactid="3395"><h2 data-reactid="3396">(pcalls &amp; fns)</h2></a><div class="section doc" data-reactid="3397">Executes the no-arg fns in parallel, returning a lazy sequence of
  their values</div><div class="section" data-reactid="3398"><a href="../clj/clojure.core/pcalls.html" data-reactid="3399"><h3 data-reactid="3400">+ Source</h3></a></div></div><div class="var-info" data-reactid="3401"><a href="../clj/clojure.core/peek.html" data-reactid="3402"><h2 data-reactid="3403">(peek coll)</h2></a><div class="section doc" data-reactid="3404">For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.</div><div class="section" data-reactid="3405"><a href="../clj/clojure.core/peek.html" data-reactid="3406"><h3 data-reactid="3407">+ Source</h3></a></div></div><div class="var-info" data-reactid="3408"><a href="../clj/clojure.core/persistent&#x27;e&#x27;.html" data-reactid="3409"><h2 data-reactid="3410">(persistent! coll)</h2></a><div class="section doc" data-reactid="3411">Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.</div><div class="section" data-reactid="3412"><a href="../clj/clojure.core/persistent&#x27;e&#x27;.html" data-reactid="3413"><h3 data-reactid="3414">+ Source</h3></a></div></div><div class="var-info" data-reactid="3415"><a href="../clj/clojure.core/pmap.html" data-reactid="3416"><h2 data-reactid="3417">(pmap f coll)</h2><h2 data-reactid="3418">(pmap f coll &amp; colls)</h2></a><div class="section doc" data-reactid="3419">Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&#x27;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.</div><div class="section" data-reactid="3420"><a href="../clj/clojure.core/pmap.html" data-reactid="3421"><h3 data-reactid="3422">+ Source</h3></a></div></div><div class="var-info" data-reactid="3423"><a href="../clj/clojure.core/pop.html" data-reactid="3424"><h2 data-reactid="3425">(pop coll)</h2></a><div class="section doc" data-reactid="3426">For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.</div><div class="section" data-reactid="3427"><a href="../clj/clojure.core/pop.html" data-reactid="3428"><h3 data-reactid="3429">+ Source</h3></a></div></div><div class="var-info" data-reactid="3430"><a href="../clj/clojure.core/pop&#x27;e&#x27;.html" data-reactid="3431"><h2 data-reactid="3432">(pop! coll)</h2></a><div class="section doc" data-reactid="3433">Removes the last item from a transient vector. If
  the collection is empty, throws an exception. Returns coll</div><div class="section" data-reactid="3434"><a href="../clj/clojure.core/pop&#x27;e&#x27;.html" data-reactid="3435"><h3 data-reactid="3436">+ Source</h3></a></div></div><div class="var-info" data-reactid="3437"><a href="../clj/clojure.core/pop-thread-bindings.html" data-reactid="3438"><h2 data-reactid="3439">(pop-thread-bindings)</h2></a><div class="section doc" data-reactid="3440">Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before.</div><div class="section" data-reactid="3441"><a href="../clj/clojure.core/pop-thread-bindings.html" data-reactid="3442"><h3 data-reactid="3443">+ Source</h3></a></div></div><div class="var-info" data-reactid="3444"><a href="../clj/clojure.core/pos-int&#x27;q&#x27;.html" data-reactid="3445"><h2 data-reactid="3446">(pos-int? x)</h2></a><div class="section doc" data-reactid="3447">Return true if x is a positive fixed precision integer</div><div class="section" data-reactid="3448"><a href="../clj/clojure.core/pos-int&#x27;q&#x27;.html" data-reactid="3449"><h3 data-reactid="3450">+ Source</h3></a></div></div><div class="var-info" data-reactid="3451"><a href="../clj/clojure.core/pos&#x27;q&#x27;.html" data-reactid="3452"><h2 data-reactid="3453">(pos? num)</h2></a><div class="section doc" data-reactid="3454">Returns true if num is greater than zero, else false</div><div class="section" data-reactid="3455"><a href="../clj/clojure.core/pos&#x27;q&#x27;.html" data-reactid="3456"><h3 data-reactid="3457">+ Source</h3></a></div></div><div class="var-info" data-reactid="3458"><a href="../clj/clojure.core/pr.html" data-reactid="3459"><h2 data-reactid="3460">(pr)</h2><h2 data-reactid="3461">(pr x)</h2><h2 data-reactid="3462">(pr x &amp; more)</h2></a><div class="section doc" data-reactid="3463">Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader</div><div class="section" data-reactid="3464"><a href="../clj/clojure.core/pr.html" data-reactid="3465"><h3 data-reactid="3466">+ Source</h3></a></div></div><div class="var-info" data-reactid="3467"><a href="../clj/clojure.core/pr-str.html" data-reactid="3468"><h2 data-reactid="3469">(pr-str &amp; xs)</h2></a><div class="section doc" data-reactid="3470">pr to a string, returning it</div><div class="section" data-reactid="3471"><a href="../clj/clojure.core/pr-str.html" data-reactid="3472"><h3 data-reactid="3473">+ Source</h3></a></div></div><div class="var-info" data-reactid="3474"><a href="../clj/clojure.core/prefer-method.html" data-reactid="3475"><h2 data-reactid="3476">(prefer-method multifn dispatch-val-x dispatch-val-y)</h2></a><div class="section doc" data-reactid="3477">Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y 
   when there is a conflict</div><div class="section" data-reactid="3478"><a href="../clj/clojure.core/prefer-method.html" data-reactid="3479"><h3 data-reactid="3480">+ Source</h3></a></div></div><div class="var-info" data-reactid="3481"><a href="../clj/clojure.core/prefers.html" data-reactid="3482"><h2 data-reactid="3483">(prefers multifn)</h2></a><div class="section doc" data-reactid="3484">Given a multimethod, returns a map of preferred value -&gt; set of other values</div><div class="section" data-reactid="3485"><a href="../clj/clojure.core/prefers.html" data-reactid="3486"><h3 data-reactid="3487">+ Source</h3></a></div></div><div class="var-info" data-reactid="3488"><a href="../clj/clojure.core/primitives-classnames.html" data-reactid="3489"><h2 data-reactid="3490">primitives-classnames</h2></a><div class="section" data-reactid="3491"><a href="../clj/clojure.core/primitives-classnames.html" data-reactid="3492"><h3 data-reactid="3493">+ Source</h3></a></div></div><div class="var-info" data-reactid="3494"><a href="../clj/clojure.core/print.html" data-reactid="3495"><h2 data-reactid="3496">(print &amp; more)</h2></a><div class="section doc" data-reactid="3497">Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption.</div><div class="section" data-reactid="3498"><a href="../clj/clojure.core/print.html" data-reactid="3499"><h3 data-reactid="3500">+ Source</h3></a></div></div><div class="var-info" data-reactid="3501"><a href="../clj/clojure.core/print-ctor.html" data-reactid="3502"><h2 data-reactid="3503">(print-ctor o print-args w)</h2></a><div class="section" data-reactid="3504"><a href="../clj/clojure.core/print-ctor.html" data-reactid="3505"><h3 data-reactid="3506">+ Source</h3></a></div></div><div class="var-info" data-reactid="3507"><a href="../clj/clojure.core/print-dup.html" data-reactid="3508"><h2 data-reactid="3509">print-dup</h2></a><div class="section" data-reactid="3510"><a href="../clj/clojure.core/print-dup.html" data-reactid="3511"><h3 data-reactid="3512">+ Source</h3></a></div></div><div class="var-info" data-reactid="3513"><a href="../clj/clojure.core/print-method.html" data-reactid="3514"><h2 data-reactid="3515">print-method</h2></a><div class="section" data-reactid="3516"><a href="../clj/clojure.core/print-method.html" data-reactid="3517"><h3 data-reactid="3518">+ Source</h3></a></div></div><div class="var-info" data-reactid="3519"><a href="../clj/clojure.core/print-simple.html" data-reactid="3520"><h2 data-reactid="3521">(print-simple o w)</h2></a><div class="section" data-reactid="3522"><a href="../clj/clojure.core/print-simple.html" data-reactid="3523"><h3 data-reactid="3524">+ Source</h3></a></div></div><div class="var-info" data-reactid="3525"><a href="../clj/clojure.core/print-str.html" data-reactid="3526"><h2 data-reactid="3527">(print-str &amp; xs)</h2></a><div class="section doc" data-reactid="3528">print to a string, returning it</div><div class="section" data-reactid="3529"><a href="../clj/clojure.core/print-str.html" data-reactid="3530"><h3 data-reactid="3531">+ Source</h3></a></div></div><div class="var-info" data-reactid="3532"><a href="../clj/clojure.core/printf.html" data-reactid="3533"><h2 data-reactid="3534">(printf fmt &amp; args)</h2></a><div class="section doc" data-reactid="3535">Prints formatted output, as per format</div><div class="section" data-reactid="3536"><a href="../clj/clojure.core/printf.html" data-reactid="3537"><h3 data-reactid="3538">+ Source</h3></a></div></div><div class="var-info" data-reactid="3539"><a href="../clj/clojure.core/println.html" data-reactid="3540"><h2 data-reactid="3541">(println &amp; more)</h2></a><div class="section doc" data-reactid="3542">Same as print followed by (newline)</div><div class="section" data-reactid="3543"><a href="../clj/clojure.core/println.html" data-reactid="3544"><h3 data-reactid="3545">+ Source</h3></a></div></div><div class="var-info" data-reactid="3546"><a href="../clj/clojure.core/println-str.html" data-reactid="3547"><h2 data-reactid="3548">(println-str &amp; xs)</h2></a><div class="section doc" data-reactid="3549">println to a string, returning it</div><div class="section" data-reactid="3550"><a href="../clj/clojure.core/println-str.html" data-reactid="3551"><h3 data-reactid="3552">+ Source</h3></a></div></div><div class="var-info" data-reactid="3553"><a href="../clj/clojure.core/prn.html" data-reactid="3554"><h2 data-reactid="3555">(prn &amp; more)</h2></a><div class="section doc" data-reactid="3556">Same as pr followed by (newline). Observes *flush-on-newline*</div><div class="section" data-reactid="3557"><a href="../clj/clojure.core/prn.html" data-reactid="3558"><h3 data-reactid="3559">+ Source</h3></a></div></div><div class="var-info" data-reactid="3560"><a href="../clj/clojure.core/prn-str.html" data-reactid="3561"><h2 data-reactid="3562">(prn-str &amp; xs)</h2></a><div class="section doc" data-reactid="3563">prn to a string, returning it</div><div class="section" data-reactid="3564"><a href="../clj/clojure.core/prn-str.html" data-reactid="3565"><h3 data-reactid="3566">+ Source</h3></a></div></div><div class="var-info" data-reactid="3567"><a href="../clj/clojure.core/promise.html" data-reactid="3568"><h2 data-reactid="3569">(promise)</h2></a><div class="section doc" data-reactid="3570">Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?.</div><div class="section" data-reactid="3571"><a href="../clj/clojure.core/promise.html" data-reactid="3572"><h3 data-reactid="3573">+ Source</h3></a></div></div><div class="var-info" data-reactid="3574"><a href="../clj/clojure.core/proxy.html" data-reactid="3575"><h2 data-reactid="3576">(proxy class-and-interfaces args &amp; fs)</h2></a><div class="section doc" data-reactid="3577">class-and-interfaces - a vector of class names

  args - a (possibly empty) vector of arguments to the superclass
  constructor.

  f =&gt; (name [params*] body) or
  (name ([params*] body) ([params+] body) ...)

  Expands to code which creates a instance of a proxy class that
  implements the named class/interface(s) by calling the supplied
  fns. A single class, if provided, must be first. If not provided it
  defaults to Object.

  The interfaces names must be valid interface types. If a method fn
  is not provided for a class method, the superclass methd will be
  called. If a method fn is not provided for an interface method, an
  UnsupportedOperationException will be thrown should it be
  called. Method fns are closures and can capture the environment in
  which proxy is called. Each method fn takes an additional implicit
  first arg, which is bound to &#x27;this. Note that while method fns can
  be provided to override protected methods, they have no other access
  to protected members, nor to super, as these capabilities cannot be
  proxied.</div><div class="section" data-reactid="3578"><a href="../clj/clojure.core/proxy.html" data-reactid="3579"><h3 data-reactid="3580">+ Source</h3></a></div></div><div class="var-info" data-reactid="3581"><a href="../clj/clojure.core/proxy-call-with-super.html" data-reactid="3582"><h2 data-reactid="3583">(proxy-call-with-super call this meth)</h2></a><div class="section" data-reactid="3584"><a href="../clj/clojure.core/proxy-call-with-super.html" data-reactid="3585"><h3 data-reactid="3586">+ Source</h3></a></div></div><div class="var-info" data-reactid="3587"><a href="../clj/clojure.core/proxy-mappings.html" data-reactid="3588"><h2 data-reactid="3589">(proxy-mappings proxy)</h2></a><div class="section doc" data-reactid="3590">Takes a proxy instance and returns the proxy&#x27;s fn map.</div><div class="section" data-reactid="3591"><a href="../clj/clojure.core/proxy-mappings.html" data-reactid="3592"><h3 data-reactid="3593">+ Source</h3></a></div></div><div class="var-info" data-reactid="3594"><a href="../clj/clojure.core/proxy-name.html" data-reactid="3595"><h2 data-reactid="3596">(proxy-name super interfaces)</h2></a><div class="section" data-reactid="3597"><a href="../clj/clojure.core/proxy-name.html" data-reactid="3598"><h3 data-reactid="3599">+ Source</h3></a></div></div><div class="var-info" data-reactid="3600"><a href="../clj/clojure.core/proxy-super.html" data-reactid="3601"><h2 data-reactid="3602">(proxy-super meth &amp; args)</h2></a><div class="section doc" data-reactid="3603">Use to call a superclass method in the body of a proxy method. 
  Note, expansion captures &#x27;this</div><div class="section" data-reactid="3604"><a href="../clj/clojure.core/proxy-super.html" data-reactid="3605"><h3 data-reactid="3606">+ Source</h3></a></div></div><div class="var-info" data-reactid="3607"><a href="../clj/clojure.core/push-thread-bindings.html" data-reactid="3608"><h2 data-reactid="3609">(push-thread-bindings bindings)</h2></a><div class="section doc" data-reactid="3610">WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))</div><div class="section" data-reactid="3611"><a href="../clj/clojure.core/push-thread-bindings.html" data-reactid="3612"><h3 data-reactid="3613">+ Source</h3></a></div></div><div class="var-info" data-reactid="3614"><a href="../clj/clojure.core/pvalues.html" data-reactid="3615"><h2 data-reactid="3616">(pvalues &amp; exprs)</h2></a><div class="section doc" data-reactid="3617">Returns a lazy sequence of the values of the exprs, which are
  evaluated in parallel</div><div class="section" data-reactid="3618"><a href="../clj/clojure.core/pvalues.html" data-reactid="3619"><h3 data-reactid="3620">+ Source</h3></a></div></div><div class="var-info" data-reactid="3621"><a href="../clj/clojure.core/qualified-ident&#x27;q&#x27;.html" data-reactid="3622"><h2 data-reactid="3623">(qualified-ident? x)</h2></a><div class="section doc" data-reactid="3624">Return true if x is a symbol or keyword with a namespace</div><div class="section" data-reactid="3625"><a href="../clj/clojure.core/qualified-ident&#x27;q&#x27;.html" data-reactid="3626"><h3 data-reactid="3627">+ Source</h3></a></div></div><div class="var-info" data-reactid="3628"><a href="../clj/clojure.core/qualified-keyword&#x27;q&#x27;.html" data-reactid="3629"><h2 data-reactid="3630">(qualified-keyword? x)</h2></a><div class="section doc" data-reactid="3631">Return true if x is a keyword with a namespace</div><div class="section" data-reactid="3632"><a href="../clj/clojure.core/qualified-keyword&#x27;q&#x27;.html" data-reactid="3633"><h3 data-reactid="3634">+ Source</h3></a></div></div><div class="var-info" data-reactid="3635"><a href="../clj/clojure.core/qualified-symbol&#x27;q&#x27;.html" data-reactid="3636"><h2 data-reactid="3637">(qualified-symbol? x)</h2></a><div class="section doc" data-reactid="3638">Return true if x is a symbol with a namespace</div><div class="section" data-reactid="3639"><a href="../clj/clojure.core/qualified-symbol&#x27;q&#x27;.html" data-reactid="3640"><h3 data-reactid="3641">+ Source</h3></a></div></div><div class="var-info" data-reactid="3642"><a href="../clj/clojure.core/quot.html" data-reactid="3643"><h2 data-reactid="3644">(quot num div)</h2></a><div class="section doc" data-reactid="3645">quot[ient] of dividing numerator by denominator.</div><div class="section" data-reactid="3646"><a href="../clj/clojure.core/quot.html" data-reactid="3647"><h3 data-reactid="3648">+ Source</h3></a></div></div><div class="var-info" data-reactid="3649"><a href="../clj/clojure.core/rand.html" data-reactid="3650"><h2 data-reactid="3651">(rand)</h2><h2 data-reactid="3652">(rand n)</h2></a><div class="section doc" data-reactid="3653">Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).</div><div class="section" data-reactid="3654"><a href="../clj/clojure.core/rand.html" data-reactid="3655"><h3 data-reactid="3656">+ Source</h3></a></div></div><div class="var-info" data-reactid="3657"><a href="../clj/clojure.core/rand-int.html" data-reactid="3658"><h2 data-reactid="3659">(rand-int n)</h2></a><div class="section doc" data-reactid="3660">Returns a random integer between 0 (inclusive) and n (exclusive).</div><div class="section" data-reactid="3661"><a href="../clj/clojure.core/rand-int.html" data-reactid="3662"><h3 data-reactid="3663">+ Source</h3></a></div></div><div class="var-info" data-reactid="3664"><a href="../clj/clojure.core/rand-nth.html" data-reactid="3665"><h2 data-reactid="3666">(rand-nth coll)</h2></a><div class="section doc" data-reactid="3667">Return a random element of the (sequential) collection. Will have
  the same performance characteristics as nth for the given
  collection.</div><div class="section" data-reactid="3668"><a href="../clj/clojure.core/rand-nth.html" data-reactid="3669"><h3 data-reactid="3670">+ Source</h3></a></div></div><div class="var-info" data-reactid="3671"><a href="../clj/clojure.core/random-sample.html" data-reactid="3672"><h2 data-reactid="3673">(random-sample prob)</h2><h2 data-reactid="3674">(random-sample prob coll)</h2></a><div class="section doc" data-reactid="3675">Returns items from coll with random probability of prob (0.0 -
  1.0).  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="3676"><a href="../clj/clojure.core/random-sample.html" data-reactid="3677"><h3 data-reactid="3678">+ Source</h3></a></div></div><div class="var-info" data-reactid="3679"><a href="../clj/clojure.core/range.html" data-reactid="3680"><h2 data-reactid="3681">(range)</h2><h2 data-reactid="3682">(range end)</h2><h2 data-reactid="3683">(range start end)</h2><h2 data-reactid="3684">(range start end step)</h2></a><div class="section doc" data-reactid="3685">Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.</div><div class="section" data-reactid="3686"><a href="../clj/clojure.core/range.html" data-reactid="3687"><h3 data-reactid="3688">+ Source</h3></a></div></div><div class="var-info" data-reactid="3689"><a href="../clj/clojure.core/ratio&#x27;q&#x27;.html" data-reactid="3690"><h2 data-reactid="3691">(ratio? n)</h2></a><div class="section doc" data-reactid="3692">Returns true if n is a Ratio</div><div class="section" data-reactid="3693"><a href="../clj/clojure.core/ratio&#x27;q&#x27;.html" data-reactid="3694"><h3 data-reactid="3695">+ Source</h3></a></div></div><div class="var-info" data-reactid="3696"><a href="../clj/clojure.core/rational&#x27;q&#x27;.html" data-reactid="3697"><h2 data-reactid="3698">(rational? n)</h2></a><div class="section doc" data-reactid="3699">Returns true if n is a rational number</div><div class="section" data-reactid="3700"><a href="../clj/clojure.core/rational&#x27;q&#x27;.html" data-reactid="3701"><h3 data-reactid="3702">+ Source</h3></a></div></div><div class="var-info" data-reactid="3703"><a href="../clj/clojure.core/rationalize.html" data-reactid="3704"><h2 data-reactid="3705">(rationalize num)</h2></a><div class="section doc" data-reactid="3706">returns the rational value of num</div><div class="section" data-reactid="3707"><a href="../clj/clojure.core/rationalize.html" data-reactid="3708"><h3 data-reactid="3709">+ Source</h3></a></div></div><div class="var-info" data-reactid="3710"><a href="../clj/clojure.core/re-find.html" data-reactid="3711"><h2 data-reactid="3712">(re-find m)</h2><h2 data-reactid="3713">(re-find re s)</h2></a><div class="section doc" data-reactid="3714">Returns the next regex match, if any, of string to pattern, using
  java.util.regex.Matcher.find().  Uses re-groups to return the
  groups.</div><div class="section" data-reactid="3715"><a href="../clj/clojure.core/re-find.html" data-reactid="3716"><h3 data-reactid="3717">+ Source</h3></a></div></div><div class="var-info" data-reactid="3718"><a href="../clj/clojure.core/re-groups.html" data-reactid="3719"><h2 data-reactid="3720">(re-groups m)</h2></a><div class="section doc" data-reactid="3721">Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.</div><div class="section" data-reactid="3722"><a href="../clj/clojure.core/re-groups.html" data-reactid="3723"><h3 data-reactid="3724">+ Source</h3></a></div></div><div class="var-info" data-reactid="3725"><a href="../clj/clojure.core/re-matcher.html" data-reactid="3726"><h2 data-reactid="3727">(re-matcher re s)</h2></a><div class="section doc" data-reactid="3728">Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.</div><div class="section" data-reactid="3729"><a href="../clj/clojure.core/re-matcher.html" data-reactid="3730"><h3 data-reactid="3731">+ Source</h3></a></div></div><div class="var-info" data-reactid="3732"><a href="../clj/clojure.core/re-matches.html" data-reactid="3733"><h2 data-reactid="3734">(re-matches re s)</h2></a><div class="section doc" data-reactid="3735">Returns the match, if any, of string to pattern, using
  java.util.regex.Matcher.matches().  Uses re-groups to return the
  groups.</div><div class="section" data-reactid="3736"><a href="../clj/clojure.core/re-matches.html" data-reactid="3737"><h3 data-reactid="3738">+ Source</h3></a></div></div><div class="var-info" data-reactid="3739"><a href="../clj/clojure.core/re-pattern.html" data-reactid="3740"><h2 data-reactid="3741">(re-pattern s)</h2></a><div class="section doc" data-reactid="3742">Returns an instance of java.util.regex.Pattern, for use, e.g. in
  re-matcher.</div><div class="section" data-reactid="3743"><a href="../clj/clojure.core/re-pattern.html" data-reactid="3744"><h3 data-reactid="3745">+ Source</h3></a></div></div><div class="var-info" data-reactid="3746"><a href="../clj/clojure.core/re-seq.html" data-reactid="3747"><h2 data-reactid="3748">(re-seq re s)</h2></a><div class="section doc" data-reactid="3749">Returns a lazy sequence of successive matches of pattern in string,
  using java.util.regex.Matcher.find(), each such match processed with
  re-groups.</div><div class="section" data-reactid="3750"><a href="../clj/clojure.core/re-seq.html" data-reactid="3751"><h3 data-reactid="3752">+ Source</h3></a></div></div><div class="var-info" data-reactid="3753"><a href="../clj/clojure.core/read.html" data-reactid="3754"><h2 data-reactid="3755">(read)</h2><h2 data-reactid="3756">(read stream)</h2><h2 data-reactid="3757">(read stream eof-error? eof-value)</h2><h2 data-reactid="3758">(read stream eof-error? eof-value recursive?)</h2><h2 data-reactid="3759">(read opts stream)</h2></a><div class="section doc" data-reactid="3760">Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read</div><div class="section" data-reactid="3761"><a href="../clj/clojure.core/read.html" data-reactid="3762"><h3 data-reactid="3763">+ Source</h3></a></div></div><div class="var-info" data-reactid="3764"><a href="../clj/clojure.core/read-line.html" data-reactid="3765"><h2 data-reactid="3766">(read-line)</h2></a><div class="section doc" data-reactid="3767">Reads the next line from stream that is the current value of *in* .</div><div class="section" data-reactid="3768"><a href="../clj/clojure.core/read-line.html" data-reactid="3769"><h3 data-reactid="3770">+ Source</h3></a></div></div><div class="var-info" data-reactid="3771"><a href="../clj/clojure.core/read-string.html" data-reactid="3772"><h2 data-reactid="3773">(read-string s)</h2><h2 data-reactid="3774">(read-string opts s)</h2></a><div class="section doc" data-reactid="3775">Reads one object from the string s. Optionally include reader
  options, as specified in read.

  Note that read-string can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read-string</div><div class="section" data-reactid="3776"><a href="../clj/clojure.core/read-string.html" data-reactid="3777"><h3 data-reactid="3778">+ Source</h3></a></div></div><div class="var-info" data-reactid="3779"><a href="../clj/clojure.core/reader-conditional.html" data-reactid="3780"><h2 data-reactid="3781">(reader-conditional form splicing?)</h2></a><div class="section doc" data-reactid="3782">Construct a data representation of a reader conditional.
  If true, splicing? indicates read-cond-splicing.</div><div class="section" data-reactid="3783"><a href="../clj/clojure.core/reader-conditional.html" data-reactid="3784"><h3 data-reactid="3785">+ Source</h3></a></div></div><div class="var-info" data-reactid="3786"><a href="../clj/clojure.core/reader-conditional&#x27;q&#x27;.html" data-reactid="3787"><h2 data-reactid="3788">(reader-conditional? value)</h2></a><div class="section doc" data-reactid="3789">Return true if the value is the data representation of a reader conditional</div><div class="section" data-reactid="3790"><a href="../clj/clojure.core/reader-conditional&#x27;q&#x27;.html" data-reactid="3791"><h3 data-reactid="3792">+ Source</h3></a></div></div><div class="var-info" data-reactid="3793"><a href="../clj/clojure.core/realized&#x27;q&#x27;.html" data-reactid="3794"><h2 data-reactid="3795">(realized? x)</h2></a><div class="section doc" data-reactid="3796">Returns true if a value has been produced for a promise, delay, future or lazy sequence.</div><div class="section" data-reactid="3797"><a href="../clj/clojure.core/realized&#x27;q&#x27;.html" data-reactid="3798"><h3 data-reactid="3799">+ Source</h3></a></div></div><div class="var-info" data-reactid="3800"><a href="../clj/clojure.core/record&#x27;q&#x27;.html" data-reactid="3801"><h2 data-reactid="3802">(record? x)</h2></a><div class="section doc" data-reactid="3803">Returns true if x is a record</div><div class="section" data-reactid="3804"><a href="../clj/clojure.core/record&#x27;q&#x27;.html" data-reactid="3805"><h3 data-reactid="3806">+ Source</h3></a></div></div><div class="var-info" data-reactid="3807"><a href="../clj/clojure.core/reduce.html" data-reactid="3808"><h2 data-reactid="3809">(reduce f coll)</h2><h2 data-reactid="3810">(reduce f val coll)</h2></a><div class="section doc" data-reactid="3811">f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.</div><div class="section" data-reactid="3812"><a href="../clj/clojure.core/reduce.html" data-reactid="3813"><h3 data-reactid="3814">+ Source</h3></a></div></div><div class="var-info" data-reactid="3815"><a href="../clj/clojure.core/reduce-kv.html" data-reactid="3816"><h2 data-reactid="3817">(reduce-kv f init coll)</h2></a><div class="section doc" data-reactid="3818">Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals.</div><div class="section" data-reactid="3819"><a href="../clj/clojure.core/reduce-kv.html" data-reactid="3820"><h3 data-reactid="3821">+ Source</h3></a></div></div><div class="var-info" data-reactid="3822"><a href="../clj/clojure.core/reduced.html" data-reactid="3823"><h2 data-reactid="3824">(reduced x)</h2></a><div class="section doc" data-reactid="3825">Wraps x in a way such that a reduce will terminate with the value x</div><div class="section" data-reactid="3826"><a href="../clj/clojure.core/reduced.html" data-reactid="3827"><h3 data-reactid="3828">+ Source</h3></a></div></div><div class="var-info" data-reactid="3829"><a href="../clj/clojure.core/reduced&#x27;q&#x27;.html" data-reactid="3830"><h2 data-reactid="3831">(reduced? x)</h2></a><div class="section doc" data-reactid="3832">Returns true if x is the result of a call to reduced</div><div class="section" data-reactid="3833"><a href="../clj/clojure.core/reduced&#x27;q&#x27;.html" data-reactid="3834"><h3 data-reactid="3835">+ Source</h3></a></div></div><div class="var-info" data-reactid="3836"><a href="../clj/clojure.core/reductions.html" data-reactid="3837"><h2 data-reactid="3838">(reductions f coll)</h2><h2 data-reactid="3839">(reductions f init coll)</h2></a><div class="section doc" data-reactid="3840">Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.</div><div class="section" data-reactid="3841"><a href="../clj/clojure.core/reductions.html" data-reactid="3842"><h3 data-reactid="3843">+ Source</h3></a></div></div><div class="var-info" data-reactid="3844"><a href="../clj/clojure.core/ref.html" data-reactid="3845"><h2 data-reactid="3846">(ref x)</h2><h2 data-reactid="3847">(ref x &amp; options)</h2></a><div class="section doc" data-reactid="3848">Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.</div><div class="section" data-reactid="3849"><a href="../clj/clojure.core/ref.html" data-reactid="3850"><h3 data-reactid="3851">+ Source</h3></a></div></div><div class="var-info" data-reactid="3852"><a href="../clj/clojure.core/ref-history-count.html" data-reactid="3853"><h2 data-reactid="3854">(ref-history-count ref)</h2></a><div class="section doc" data-reactid="3855">Returns the history count of a ref</div><div class="section" data-reactid="3856"><a href="../clj/clojure.core/ref-history-count.html" data-reactid="3857"><h3 data-reactid="3858">+ Source</h3></a></div></div><div class="var-info" data-reactid="3859"><a href="../clj/clojure.core/ref-max-history.html" data-reactid="3860"><h2 data-reactid="3861">(ref-max-history ref)</h2><h2 data-reactid="3862">(ref-max-history ref n)</h2></a><div class="section doc" data-reactid="3863">Gets the max-history of a ref, or sets it and returns the ref</div><div class="section" data-reactid="3864"><a href="../clj/clojure.core/ref-max-history.html" data-reactid="3865"><h3 data-reactid="3866">+ Source</h3></a></div></div><div class="var-info" data-reactid="3867"><a href="../clj/clojure.core/ref-min-history.html" data-reactid="3868"><h2 data-reactid="3869">(ref-min-history ref)</h2><h2 data-reactid="3870">(ref-min-history ref n)</h2></a><div class="section doc" data-reactid="3871">Gets the min-history of a ref, or sets it and returns the ref</div><div class="section" data-reactid="3872"><a href="../clj/clojure.core/ref-min-history.html" data-reactid="3873"><h3 data-reactid="3874">+ Source</h3></a></div></div><div class="var-info" data-reactid="3875"><a href="../clj/clojure.core/ref-set.html" data-reactid="3876"><h2 data-reactid="3877">(ref-set ref val)</h2></a><div class="section doc" data-reactid="3878">Must be called in a transaction. Sets the value of ref.
  Returns val.</div><div class="section" data-reactid="3879"><a href="../clj/clojure.core/ref-set.html" data-reactid="3880"><h3 data-reactid="3881">+ Source</h3></a></div></div><div class="var-info" data-reactid="3882"><a href="../clj/clojure.core/refer.html" data-reactid="3883"><h2 data-reactid="3884">(refer ns-sym &amp; filters)</h2></a><div class="section doc" data-reactid="3885">refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&#x27;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.</div><div class="section" data-reactid="3886"><a href="../clj/clojure.core/refer.html" data-reactid="3887"><h3 data-reactid="3888">+ Source</h3></a></div></div><div class="var-info" data-reactid="3889"><a href="../clj/clojure.core/refer-clojure.html" data-reactid="3890"><h2 data-reactid="3891">(refer-clojure &amp; filters)</h2></a><div class="section doc" data-reactid="3892">Same as (refer &#x27;clojure.core &lt;filters&gt;)</div><div class="section" data-reactid="3893"><a href="../clj/clojure.core/refer-clojure.html" data-reactid="3894"><h3 data-reactid="3895">+ Spec</h3></a></div><div class="section" data-reactid="3896"><a href="../clj/clojure.core/refer-clojure.html" data-reactid="3897"><h3 data-reactid="3898">+ Source</h3></a></div></div><div class="var-info" data-reactid="3899"><a href="../clj/clojure.core/reify.html" data-reactid="3900"><h2 data-reactid="3901">(reify &amp; opts+specs)</h2></a><div class="section doc" data-reactid="3902">reify is a macro with the following structure:

 (reify options* specs*)
  
  Currently there are no options.

  Each spec consists of the protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args+] body)*

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that the first parameter must be supplied to
  correspond to the target object (&#x27;this&#x27; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations.  Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  The return type can be indicated by a type hint on the method name,
  and arg types can be indicated by a type hint on arg names. If you
  leave out all hints, reify will try to match on same name/arity
  method in the protocol(s)/interface(s) - this is preferred. If you
  supply any hints at all, no inference is done, so all hints (or
  default of Object) must be correct, for both arguments and return
  type. If a method is overloaded in a protocol/interface, multiple
  independent method definitions must be supplied.  If overloaded with
  same arity in an interface you must specify complete hints to
  disambiguate - a missing hint implies Object.

  recur works to method heads The method bodies of reify are lexical
  closures, and can refer to the surrounding local scope:
  
  (str (let [f &quot;foo&quot;] 
       (reify Object 
         (toString [this] f))))
  == &quot;foo&quot;

  (seq (let [f &quot;foo&quot;] 
       (reify clojure.lang.Seqable 
         (seq [this] (seq f)))))
  == (\f \o \o))
  
  reify always implements clojure.lang.IObj and transfers meta
  data of the form to the created object.
  
  (meta ^{:k :v} (reify Object (toString [this] &quot;foo&quot;)))
  == {:k :v}</div><div class="section" data-reactid="3903"><a href="../clj/clojure.core/reify.html" data-reactid="3904"><h3 data-reactid="3905">+ Source</h3></a></div></div><div class="var-info" data-reactid="3906"><a href="../clj/clojure.core/release-pending-sends.html" data-reactid="3907"><h2 data-reactid="3908">(release-pending-sends)</h2></a><div class="section doc" data-reactid="3909">Normally, actions sent directly or indirectly during another action
  are held until the action completes (changes the agent&#x27;s
  state). This function can be used to dispatch any pending sent
  actions immediately. This has no impact on actions sent during a
  transaction, which are still held until commit. If no action is
  occurring, does nothing. Returns the number of actions dispatched.</div><div class="section" data-reactid="3910"><a href="../clj/clojure.core/release-pending-sends.html" data-reactid="3911"><h3 data-reactid="3912">+ Source</h3></a></div></div><div class="var-info" data-reactid="3913"><a href="../clj/clojure.core/rem.html" data-reactid="3914"><h2 data-reactid="3915">(rem num div)</h2></a><div class="section doc" data-reactid="3916">remainder of dividing numerator by denominator.</div><div class="section" data-reactid="3917"><a href="../clj/clojure.core/rem.html" data-reactid="3918"><h3 data-reactid="3919">+ Source</h3></a></div></div><div class="var-info" data-reactid="3920"><a href="../clj/clojure.core/remove.html" data-reactid="3921"><h2 data-reactid="3922">(remove pred)</h2><h2 data-reactid="3923">(remove pred coll)</h2></a><div class="section doc" data-reactid="3924">Returns a lazy sequence of the items in coll for which
  (pred item) returns logical false. pred must be free of side-effects.
  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="3925"><a href="../clj/clojure.core/remove.html" data-reactid="3926"><h3 data-reactid="3927">+ Source</h3></a></div></div><div class="var-info" data-reactid="3928"><a href="../clj/clojure.core/remove-all-methods.html" data-reactid="3929"><h2 data-reactid="3930">(remove-all-methods multifn)</h2></a><div class="section doc" data-reactid="3931">Removes all of the methods of multimethod.</div><div class="section" data-reactid="3932"><a href="../clj/clojure.core/remove-all-methods.html" data-reactid="3933"><h3 data-reactid="3934">+ Source</h3></a></div></div><div class="var-info" data-reactid="3935"><a href="../clj/clojure.core/remove-method.html" data-reactid="3936"><h2 data-reactid="3937">(remove-method multifn dispatch-val)</h2></a><div class="section doc" data-reactid="3938">Removes the method of multimethod associated with dispatch-value.</div><div class="section" data-reactid="3939"><a href="../clj/clojure.core/remove-method.html" data-reactid="3940"><h3 data-reactid="3941">+ Source</h3></a></div></div><div class="var-info" data-reactid="3942"><a href="../clj/clojure.core/remove-ns.html" data-reactid="3943"><h2 data-reactid="3944">(remove-ns sym)</h2></a><div class="section doc" data-reactid="3945">Removes the namespace named by the symbol. Use with caution.
  Cannot be used to remove the clojure namespace.</div><div class="section" data-reactid="3946"><a href="../clj/clojure.core/remove-ns.html" data-reactid="3947"><h3 data-reactid="3948">+ Source</h3></a></div></div><div class="var-info" data-reactid="3949"><a href="../clj/clojure.core/remove-watch.html" data-reactid="3950"><h2 data-reactid="3951">(remove-watch reference key)</h2></a><div class="section doc" data-reactid="3952">Removes a watch (set by add-watch) from a reference</div><div class="section" data-reactid="3953"><a href="../clj/clojure.core/remove-watch.html" data-reactid="3954"><h3 data-reactid="3955">+ Source</h3></a></div></div><div class="var-info" data-reactid="3956"><a href="../clj/clojure.core/repeat.html" data-reactid="3957"><h2 data-reactid="3958">(repeat x)</h2><h2 data-reactid="3959">(repeat n x)</h2></a><div class="section doc" data-reactid="3960">Returns a lazy (infinite!, or length n if supplied) sequence of xs.</div><div class="section" data-reactid="3961"><a href="../clj/clojure.core/repeat.html" data-reactid="3962"><h3 data-reactid="3963">+ Source</h3></a></div></div><div class="var-info" data-reactid="3964"><a href="../clj/clojure.core/repeatedly.html" data-reactid="3965"><h2 data-reactid="3966">(repeatedly f)</h2><h2 data-reactid="3967">(repeatedly n f)</h2></a><div class="section doc" data-reactid="3968">Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it</div><div class="section" data-reactid="3969"><a href="../clj/clojure.core/repeatedly.html" data-reactid="3970"><h3 data-reactid="3971">+ Source</h3></a></div></div><div class="var-info" data-reactid="3972"><a href="../clj/clojure.core/replace.html" data-reactid="3973"><h2 data-reactid="3974">(replace smap)</h2><h2 data-reactid="3975">(replace smap coll)</h2></a><div class="section doc" data-reactid="3976">Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided.</div><div class="section" data-reactid="3977"><a href="../clj/clojure.core/replace.html" data-reactid="3978"><h3 data-reactid="3979">+ Source</h3></a></div></div><div class="var-info" data-reactid="3980"><a href="../clj/clojure.core/replicate.html" data-reactid="3981"><h2 data-reactid="3982">(replicate n x)</h2></a><div class="section doc" data-reactid="3983">DEPRECATED: Use &#x27;repeat&#x27; instead.
   Returns a lazy seq of n xs.</div><div class="section" data-reactid="3984"><a href="../clj/clojure.core/replicate.html" data-reactid="3985"><h3 data-reactid="3986">+ Source</h3></a></div></div><div class="var-info" data-reactid="3987"><a href="../clj/clojure.core/require.html" data-reactid="3988"><h2 data-reactid="3989">(require &amp; args)</h2></a><div class="section doc" data-reactid="3990">Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &#x27;lib&#x27; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&#x27;s
  name also locates its root directory within classpath using Java&#x27;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &#x27;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &#x27;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj, or
  &lt;classpath&gt;/x/y/z.cljc if &lt;classpath&gt;/x/y/z.clj does not exist. The
  root resource should contain code to create the lib&#x27;s
  namespace (usually by using the ns macro) and load any additional
  lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&#x27;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&#x27;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &#x27;s&#x27;.

  (require &#x27;(clojure zip [set :as s]))</div><div class="section" data-reactid="3991"><a href="../clj/clojure.core/require.html" data-reactid="3992"><h3 data-reactid="3993">+ Source</h3></a></div></div><div class="var-info" data-reactid="3994"><a href="../clj/clojure.core/reset&#x27;e&#x27;.html" data-reactid="3995"><h2 data-reactid="3996">(reset! atom newval)</h2></a><div class="section doc" data-reactid="3997">Sets the value of atom to newval without regard for the
  current value. Returns newval.</div><div class="section" data-reactid="3998"><a href="../clj/clojure.core/reset&#x27;e&#x27;.html" data-reactid="3999"><h3 data-reactid="4000">+ Source</h3></a></div></div><div class="var-info" data-reactid="4001"><a href="../clj/clojure.core/reset-meta&#x27;e&#x27;.html" data-reactid="4002"><h2 data-reactid="4003">(reset-meta! iref metadata-map)</h2></a><div class="section doc" data-reactid="4004">Atomically resets the metadata for a namespace/var/ref/agent/atom</div><div class="section" data-reactid="4005"><a href="../clj/clojure.core/reset-meta&#x27;e&#x27;.html" data-reactid="4006"><h3 data-reactid="4007">+ Source</h3></a></div></div><div class="var-info" data-reactid="4008"><a href="../clj/clojure.core/reset-vals&#x27;e&#x27;.html" data-reactid="4009"><h2 data-reactid="4010">(reset-vals! atom newval)</h2></a><div class="section doc" data-reactid="4011">Sets the value of atom to newval. Returns [old new], the value of the
   atom before and after the reset.</div><div class="section" data-reactid="4012"><a href="../clj/clojure.core/reset-vals&#x27;e&#x27;.html" data-reactid="4013"><h3 data-reactid="4014">+ Source</h3></a></div></div><div class="var-info" data-reactid="4015"><a href="../clj/clojure.core/resolve.html" data-reactid="4016"><h2 data-reactid="4017">(resolve sym)</h2><h2 data-reactid="4018">(resolve env sym)</h2></a><div class="section doc" data-reactid="4019">same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)</div><div class="section" data-reactid="4020"><a href="../clj/clojure.core/resolve.html" data-reactid="4021"><h3 data-reactid="4022">+ Source</h3></a></div></div><div class="var-info" data-reactid="4023"><a href="../clj/clojure.core/rest.html" data-reactid="4024"><h2 data-reactid="4025">(rest coll)</h2></a><div class="section doc" data-reactid="4026">Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.</div><div class="section" data-reactid="4027"><a href="../clj/clojure.core/rest.html" data-reactid="4028"><h3 data-reactid="4029">+ Source</h3></a></div></div><div class="var-info" data-reactid="4030"><a href="../clj/clojure.core/restart-agent.html" data-reactid="4031"><h2 data-reactid="4032">(restart-agent a new-state &amp; options)</h2></a><div class="section doc" data-reactid="4033">When an agent is failed, changes the agent state to new-state and
  then un-fails the agent so that sends are allowed again.  If
  a :clear-actions true option is given, any actions queued on the
  agent that were being held while it was failed will be discarded,
  otherwise those held actions will proceed.  The new-state must pass
  the validator if any, or restart will throw an exception and the
  agent will remain failed with its old state and error.  Watchers, if
  any, will NOT be notified of the new state.  Throws an exception if
  the agent is not failed.</div><div class="section" data-reactid="4034"><a href="../clj/clojure.core/restart-agent.html" data-reactid="4035"><h3 data-reactid="4036">+ Source</h3></a></div></div><div class="var-info" data-reactid="4037"><a href="../clj/clojure.core/resultset-seq.html" data-reactid="4038"><h2 data-reactid="4039">(resultset-seq rs)</h2></a><div class="section doc" data-reactid="4040">Creates and returns a lazy sequence of structmaps corresponding to
  the rows in the java.sql.ResultSet rs</div><div class="section" data-reactid="4041"><a href="../clj/clojure.core/resultset-seq.html" data-reactid="4042"><h3 data-reactid="4043">+ Source</h3></a></div></div><div class="var-info" data-reactid="4044"><a href="../clj/clojure.core/reverse.html" data-reactid="4045"><h2 data-reactid="4046">(reverse coll)</h2></a><div class="section doc" data-reactid="4047">Returns a seq of the items in coll in reverse order. Not lazy.</div><div class="section" data-reactid="4048"><a href="../clj/clojure.core/reverse.html" data-reactid="4049"><h3 data-reactid="4050">+ Source</h3></a></div></div><div class="var-info" data-reactid="4051"><a href="../clj/clojure.core/reversible&#x27;q&#x27;.html" data-reactid="4052"><h2 data-reactid="4053">(reversible? coll)</h2></a><div class="section doc" data-reactid="4054">Returns true if coll implements Reversible</div><div class="section" data-reactid="4055"><a href="../clj/clojure.core/reversible&#x27;q&#x27;.html" data-reactid="4056"><h3 data-reactid="4057">+ Source</h3></a></div></div><div class="var-info" data-reactid="4058"><a href="../clj/clojure.core/rseq.html" data-reactid="4059"><h2 data-reactid="4060">(rseq rev)</h2></a><div class="section doc" data-reactid="4061">Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil</div><div class="section" data-reactid="4062"><a href="../clj/clojure.core/rseq.html" data-reactid="4063"><h3 data-reactid="4064">+ Source</h3></a></div></div><div class="var-info" data-reactid="4065"><a href="../clj/clojure.core/rsubseq.html" data-reactid="4066"><h2 data-reactid="4067">(rsubseq sc test key)</h2><h2 data-reactid="4068">(rsubseq sc start-test start-key end-test end-key)</h2></a><div class="section doc" data-reactid="4069">sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or
  &gt;=. Returns a reverse seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true</div><div class="section" data-reactid="4070"><a href="../clj/clojure.core/rsubseq.html" data-reactid="4071"><h3 data-reactid="4072">+ Source</h3></a></div></div><div class="var-info" data-reactid="4073"><a href="../clj/clojure.core/run&#x27;e&#x27;.html" data-reactid="4074"><h2 data-reactid="4075">(run! proc coll)</h2></a><div class="section doc" data-reactid="4076">Runs the supplied procedure (via reduce), for purposes of side
  effects, on successive items in the collection. Returns nil</div><div class="section" data-reactid="4077"><a href="../clj/clojure.core/run&#x27;e&#x27;.html" data-reactid="4078"><h3 data-reactid="4079">+ Source</h3></a></div></div><div class="var-info" data-reactid="4080"><a href="../clj/clojure.core/satisfies&#x27;q&#x27;.html" data-reactid="4081"><h2 data-reactid="4082">(satisfies? protocol x)</h2></a><div class="section doc" data-reactid="4083">Returns true if x satisfies the protocol</div><div class="section" data-reactid="4084"><a href="../clj/clojure.core/satisfies&#x27;q&#x27;.html" data-reactid="4085"><h3 data-reactid="4086">+ Source</h3></a></div></div><div class="var-info" data-reactid="4087"><a href="../clj/clojure.core/second.html" data-reactid="4088"><h2 data-reactid="4089">(second x)</h2></a><div class="section doc" data-reactid="4090">Same as (first (next x))</div><div class="section" data-reactid="4091"><a href="../clj/clojure.core/second.html" data-reactid="4092"><h3 data-reactid="4093">+ Source</h3></a></div></div><div class="var-info" data-reactid="4094"><a href="../clj/clojure.core/select-keys.html" data-reactid="4095"><h2 data-reactid="4096">(select-keys map keyseq)</h2></a><div class="section doc" data-reactid="4097">Returns a map containing only those entries in map whose key is in keys</div><div class="section" data-reactid="4098"><a href="../clj/clojure.core/select-keys.html" data-reactid="4099"><h3 data-reactid="4100">+ Source</h3></a></div></div><div class="var-info" data-reactid="4101"><a href="../clj/clojure.core/send.html" data-reactid="4102"><h2 data-reactid="4103">(send a f &amp; args)</h2></a><div class="section doc" data-reactid="4104">Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)</div><div class="section" data-reactid="4105"><a href="../clj/clojure.core/send.html" data-reactid="4106"><h3 data-reactid="4107">+ Source</h3></a></div></div><div class="var-info" data-reactid="4108"><a href="../clj/clojure.core/send-off.html" data-reactid="4109"><h2 data-reactid="4110">(send-off a f &amp; args)</h2></a><div class="section doc" data-reactid="4111">Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:

  (apply action-fn state-of-agent args)</div><div class="section" data-reactid="4112"><a href="../clj/clojure.core/send-off.html" data-reactid="4113"><h3 data-reactid="4114">+ Source</h3></a></div></div><div class="var-info" data-reactid="4115"><a href="../clj/clojure.core/send-via.html" data-reactid="4116"><h2 data-reactid="4117">(send-via executor a f &amp; args)</h2></a><div class="section doc" data-reactid="4118">Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread supplied by executor, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)</div><div class="section" data-reactid="4119"><a href="../clj/clojure.core/send-via.html" data-reactid="4120"><h3 data-reactid="4121">+ Source</h3></a></div></div><div class="var-info" data-reactid="4122"><a href="../clj/clojure.core/seq.html" data-reactid="4123"><h2 data-reactid="4124">(seq coll)</h2></a><div class="section doc" data-reactid="4125">Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.</div><div class="section" data-reactid="4126"><a href="../clj/clojure.core/seq.html" data-reactid="4127"><h3 data-reactid="4128">+ Source</h3></a></div></div><div class="var-info" data-reactid="4129"><a href="../clj/clojure.core/seq&#x27;q&#x27;.html" data-reactid="4130"><h2 data-reactid="4131">(seq? x)</h2></a><div class="section doc" data-reactid="4132">Return true if x implements ISeq</div><div class="section" data-reactid="4133"><a href="../clj/clojure.core/seq&#x27;q&#x27;.html" data-reactid="4134"><h3 data-reactid="4135">+ Source</h3></a></div></div><div class="var-info" data-reactid="4136"><a href="../clj/clojure.core/seqable&#x27;q&#x27;.html" data-reactid="4137"><h2 data-reactid="4138">(seqable? x)</h2></a><div class="section doc" data-reactid="4139">Return true if the seq function is supported for x</div><div class="section" data-reactid="4140"><a href="../clj/clojure.core/seqable&#x27;q&#x27;.html" data-reactid="4141"><h3 data-reactid="4142">+ Source</h3></a></div></div><div class="var-info" data-reactid="4143"><a href="../clj/clojure.core/seque.html" data-reactid="4144"><h2 data-reactid="4145">(seque s)</h2><h2 data-reactid="4146">(seque n-or-q s)</h2></a><div class="section doc" data-reactid="4147">Creates a queued seq on another (presumably lazy) seq s. The queued
  seq will produce a concrete seq in the background, and can get up to
  n items ahead of the consumer. n-or-q can be an integer n buffer
  size, or an instance of java.util.concurrent BlockingQueue. Note
  that reading from a seque can block if the reader gets ahead of the
  producer.</div><div class="section" data-reactid="4148"><a href="../clj/clojure.core/seque.html" data-reactid="4149"><h3 data-reactid="4150">+ Source</h3></a></div></div><div class="var-info" data-reactid="4151"><a href="../clj/clojure.core/sequence.html" data-reactid="4152"><h2 data-reactid="4153">(sequence coll)</h2><h2 data-reactid="4154">(sequence xform coll)</h2><h2 data-reactid="4155">(sequence xform coll &amp; colls)</h2></a><div class="section doc" data-reactid="4156">Coerces coll to a (possibly empty) sequence, if it is not already
  one. Will not force a lazy seq. (sequence nil) yields (), When a
  transducer is supplied, returns a lazy sequence of applications of
  the transform to the items in coll(s), i.e. to the set of first
  items of each coll, followed by the set of second
  items in each coll, until any one of the colls is exhausted.  Any
  remaining items in other colls are ignored. The transform should accept
  number-of-colls arguments</div><div class="section" data-reactid="4157"><a href="../clj/clojure.core/sequence.html" data-reactid="4158"><h3 data-reactid="4159">+ Source</h3></a></div></div><div class="var-info" data-reactid="4160"><a href="../clj/clojure.core/sequential&#x27;q&#x27;.html" data-reactid="4161"><h2 data-reactid="4162">(sequential? coll)</h2></a><div class="section doc" data-reactid="4163">Returns true if coll implements Sequential</div><div class="section" data-reactid="4164"><a href="../clj/clojure.core/sequential&#x27;q&#x27;.html" data-reactid="4165"><h3 data-reactid="4166">+ Source</h3></a></div></div><div class="var-info" data-reactid="4167"><a href="../clj/clojure.core/set.html" data-reactid="4168"><h2 data-reactid="4169">(set coll)</h2></a><div class="section doc" data-reactid="4170">Returns a set of the distinct elements of coll.</div><div class="section" data-reactid="4171"><a href="../clj/clojure.core/set.html" data-reactid="4172"><h3 data-reactid="4173">+ Source</h3></a></div></div><div class="var-info" data-reactid="4174"><a href="../clj/clojure.core/set-agent-send-executor&#x27;e&#x27;.html" data-reactid="4175"><h2 data-reactid="4176">(set-agent-send-executor! executor)</h2></a><div class="section doc" data-reactid="4177">Sets the ExecutorService to be used by send</div><div class="section" data-reactid="4178"><a href="../clj/clojure.core/set-agent-send-executor&#x27;e&#x27;.html" data-reactid="4179"><h3 data-reactid="4180">+ Source</h3></a></div></div><div class="var-info" data-reactid="4181"><a href="../clj/clojure.core/set-agent-send-off-executor&#x27;e&#x27;.html" data-reactid="4182"><h2 data-reactid="4183">(set-agent-send-off-executor! executor)</h2></a><div class="section doc" data-reactid="4184">Sets the ExecutorService to be used by send-off</div><div class="section" data-reactid="4185"><a href="../clj/clojure.core/set-agent-send-off-executor&#x27;e&#x27;.html" data-reactid="4186"><h3 data-reactid="4187">+ Source</h3></a></div></div><div class="var-info" data-reactid="4188"><a href="../clj/clojure.core/set-error-handler&#x27;e&#x27;.html" data-reactid="4189"><h2 data-reactid="4190">(set-error-handler! a handler-fn)</h2></a><div class="section doc" data-reactid="4191">Sets the error-handler of agent a to handler-fn.  If an action
  being run by the agent throws an exception or doesn&#x27;t pass the
  validator fn, handler-fn will be called with two arguments: the
  agent and the exception.</div><div class="section" data-reactid="4192"><a href="../clj/clojure.core/set-error-handler&#x27;e&#x27;.html" data-reactid="4193"><h3 data-reactid="4194">+ Source</h3></a></div></div><div class="var-info" data-reactid="4195"><a href="../clj/clojure.core/set-error-mode&#x27;e&#x27;.html" data-reactid="4196"><h2 data-reactid="4197">(set-error-mode! a mode-keyword)</h2></a><div class="section doc" data-reactid="4198">Sets the error-mode of agent a to mode-keyword, which must be
  either :fail or :continue.  If an action being run by the agent
  throws an exception or doesn&#x27;t pass the validator fn, an
  error-handler may be called (see set-error-handler!), after which,
  if the mode is :continue, the agent will continue as if neither the
  action that caused the error nor the error itself ever happened.
  
  If the mode is :fail, the agent will become failed and will stop
  accepting new &#x27;send&#x27; and &#x27;send-off&#x27; actions, and any previously
  queued actions will be held until a &#x27;restart-agent&#x27;.  Deref will
  still work, returning the state of the agent before the error.</div><div class="section" data-reactid="4199"><a href="../clj/clojure.core/set-error-mode&#x27;e&#x27;.html" data-reactid="4200"><h3 data-reactid="4201">+ Source</h3></a></div></div><div class="var-info" data-reactid="4202"><a href="../clj/clojure.core/set-validator&#x27;e&#x27;.html" data-reactid="4203"><h2 data-reactid="4204">(set-validator! iref validator-fn)</h2></a><div class="section doc" data-reactid="4205">Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a
  side-effect-free fn of one argument, which will be passed the intended
  new state on any state change. If the new state is unacceptable, the
  validator-fn should return false or throw an exception. If the current state (root
  value if var) is not acceptable to the new validator, an exception
  will be thrown and the validator will not be changed.</div><div class="section" data-reactid="4206"><a href="../clj/clojure.core/set-validator&#x27;e&#x27;.html" data-reactid="4207"><h3 data-reactid="4208">+ Source</h3></a></div></div><div class="var-info" data-reactid="4209"><a href="../clj/clojure.core/set&#x27;q&#x27;.html" data-reactid="4210"><h2 data-reactid="4211">(set? x)</h2></a><div class="section doc" data-reactid="4212">Returns true if x implements IPersistentSet</div><div class="section" data-reactid="4213"><a href="../clj/clojure.core/set&#x27;q&#x27;.html" data-reactid="4214"><h3 data-reactid="4215">+ Source</h3></a></div></div><div class="var-info" data-reactid="4216"><a href="../clj/clojure.core/short.html" data-reactid="4217"><h2 data-reactid="4218">(short x)</h2></a><div class="section doc" data-reactid="4219">Coerce to short</div><div class="section" data-reactid="4220"><a href="../clj/clojure.core/short.html" data-reactid="4221"><h3 data-reactid="4222">+ Source</h3></a></div></div><div class="var-info" data-reactid="4223"><a href="../clj/clojure.core/short-array.html" data-reactid="4224"><h2 data-reactid="4225">(short-array size-or-seq)</h2><h2 data-reactid="4226">(short-array size init-val-or-seq)</h2></a><div class="section doc" data-reactid="4227">Creates an array of shorts</div><div class="section" data-reactid="4228"><a href="../clj/clojure.core/short-array.html" data-reactid="4229"><h3 data-reactid="4230">+ Source</h3></a></div></div><div class="var-info" data-reactid="4231"><a href="../clj/clojure.core/shorts.html" data-reactid="4232"><h2 data-reactid="4233">(shorts xs)</h2></a><div class="section doc" data-reactid="4234">Casts to shorts[]</div><div class="section" data-reactid="4235"><a href="../clj/clojure.core/shorts.html" data-reactid="4236"><h3 data-reactid="4237">+ Source</h3></a></div></div><div class="var-info" data-reactid="4238"><a href="../clj/clojure.core/shuffle.html" data-reactid="4239"><h2 data-reactid="4240">(shuffle coll)</h2></a><div class="section doc" data-reactid="4241">Return a random permutation of coll</div><div class="section" data-reactid="4242"><a href="../clj/clojure.core/shuffle.html" data-reactid="4243"><h3 data-reactid="4244">+ Source</h3></a></div></div><div class="var-info" data-reactid="4245"><a href="../clj/clojure.core/shutdown-agents.html" data-reactid="4246"><h2 data-reactid="4247">(shutdown-agents)</h2></a><div class="section doc" data-reactid="4248">Initiates a shutdown of the thread pools that back the agent
  system. Running actions will complete, but no new actions will be
  accepted</div><div class="section" data-reactid="4249"><a href="../clj/clojure.core/shutdown-agents.html" data-reactid="4250"><h3 data-reactid="4251">+ Source</h3></a></div></div><div class="var-info" data-reactid="4252"><a href="../clj/clojure.core/simple-ident&#x27;q&#x27;.html" data-reactid="4253"><h2 data-reactid="4254">(simple-ident? x)</h2></a><div class="section doc" data-reactid="4255">Return true if x is a symbol or keyword without a namespace</div><div class="section" data-reactid="4256"><a href="../clj/clojure.core/simple-ident&#x27;q&#x27;.html" data-reactid="4257"><h3 data-reactid="4258">+ Source</h3></a></div></div><div class="var-info" data-reactid="4259"><a href="../clj/clojure.core/simple-keyword&#x27;q&#x27;.html" data-reactid="4260"><h2 data-reactid="4261">(simple-keyword? x)</h2></a><div class="section doc" data-reactid="4262">Return true if x is a keyword without a namespace</div><div class="section" data-reactid="4263"><a href="../clj/clojure.core/simple-keyword&#x27;q&#x27;.html" data-reactid="4264"><h3 data-reactid="4265">+ Source</h3></a></div></div><div class="var-info" data-reactid="4266"><a href="../clj/clojure.core/simple-symbol&#x27;q&#x27;.html" data-reactid="4267"><h2 data-reactid="4268">(simple-symbol? x)</h2></a><div class="section doc" data-reactid="4269">Return true if x is a symbol without a namespace</div><div class="section" data-reactid="4270"><a href="../clj/clojure.core/simple-symbol&#x27;q&#x27;.html" data-reactid="4271"><h3 data-reactid="4272">+ Source</h3></a></div></div><div class="var-info" data-reactid="4273"><a href="../clj/clojure.core/slurp.html" data-reactid="4274"><h2 data-reactid="4275">(slurp f &amp; opts)</h2></a><div class="section doc" data-reactid="4276">Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.</div><div class="section" data-reactid="4277"><a href="../clj/clojure.core/slurp.html" data-reactid="4278"><h3 data-reactid="4279">+ Source</h3></a></div></div><div class="var-info" data-reactid="4280"><a href="../clj/clojure.core/some.html" data-reactid="4281"><h2 data-reactid="4282">(some pred coll)</h2></a><div class="section doc" data-reactid="4283">Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)</div><div class="section" data-reactid="4284"><a href="../clj/clojure.core/some.html" data-reactid="4285"><h3 data-reactid="4286">+ Source</h3></a></div></div><div class="var-info" data-reactid="4287"><a href="../clj/clojure.core/some-&#x27;g&#x27;.html" data-reactid="4288"><h2 data-reactid="4289">(some-&gt; expr &amp; forms)</h2></a><div class="section doc" data-reactid="4290">When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc</div><div class="section" data-reactid="4291"><a href="../clj/clojure.core/some-&#x27;g&#x27;.html" data-reactid="4292"><h3 data-reactid="4293">+ Source</h3></a></div></div><div class="var-info" data-reactid="4294"><a href="../clj/clojure.core/some-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="4295"><h2 data-reactid="4296">(some-&gt;&gt; expr &amp; forms)</h2></a><div class="section doc" data-reactid="4297">When expr is not nil, threads it into the first form (via -&gt;&gt;),
  and when that result is not nil, through the next etc</div><div class="section" data-reactid="4298"><a href="../clj/clojure.core/some-&#x27;g&#x27;&#x27;g&#x27;.html" data-reactid="4299"><h3 data-reactid="4300">+ Source</h3></a></div></div><div class="var-info" data-reactid="4301"><a href="../clj/clojure.core/some-fn.html" data-reactid="4302"><h2 data-reactid="4303">(some-fn p)</h2><h2 data-reactid="4304">(some-fn p1 p2)</h2><h2 data-reactid="4305">(some-fn p1 p2 p3)</h2><h2 data-reactid="4306">(some-fn p1 p2 p3 &amp; ps)</h2></a><div class="section doc" data-reactid="4307">Takes a set of predicates and returns a function f that returns the first logical true value
  returned by one of its composing predicates against any of its arguments, else it returns
  logical false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical true result against the original predicates.</div><div class="section" data-reactid="4308"><a href="../clj/clojure.core/some-fn.html" data-reactid="4309"><h3 data-reactid="4310">+ Source</h3></a></div></div><div class="var-info" data-reactid="4311"><a href="../clj/clojure.core/some&#x27;q&#x27;.html" data-reactid="4312"><h2 data-reactid="4313">(some? x)</h2></a><div class="section doc" data-reactid="4314">Returns true if x is not nil, false otherwise.</div><div class="section" data-reactid="4315"><a href="../clj/clojure.core/some&#x27;q&#x27;.html" data-reactid="4316"><h3 data-reactid="4317">+ Source</h3></a></div></div><div class="var-info" data-reactid="4318"><a href="../clj/clojure.core/sort.html" data-reactid="4319"><h2 data-reactid="4320">(sort coll)</h2><h2 data-reactid="4321">(sort comp coll)</h2></a><div class="section doc" data-reactid="4322">Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.</div><div class="section" data-reactid="4323"><a href="../clj/clojure.core/sort.html" data-reactid="4324"><h3 data-reactid="4325">+ Source</h3></a></div></div><div class="var-info" data-reactid="4326"><a href="../clj/clojure.core/sort-by.html" data-reactid="4327"><h2 data-reactid="4328">(sort-by keyfn coll)</h2><h2 data-reactid="4329">(sort-by keyfn comp coll)</h2></a><div class="section doc" data-reactid="4330">Returns a sorted sequence of the items in coll, where the sort
  order is determined by comparing (keyfn item).  If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.</div><div class="section" data-reactid="4331"><a href="../clj/clojure.core/sort-by.html" data-reactid="4332"><h3 data-reactid="4333">+ Source</h3></a></div></div><div class="var-info" data-reactid="4334"><a href="../clj/clojure.core/sorted-map.html" data-reactid="4335"><h2 data-reactid="4336">(sorted-map &amp; keyvals)</h2></a><div class="section doc" data-reactid="4337">keyval =&gt; key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.</div><div class="section" data-reactid="4338"><a href="../clj/clojure.core/sorted-map.html" data-reactid="4339"><h3 data-reactid="4340">+ Source</h3></a></div></div><div class="var-info" data-reactid="4341"><a href="../clj/clojure.core/sorted-map-by.html" data-reactid="4342"><h2 data-reactid="4343">(sorted-map-by comparator &amp; keyvals)</h2></a><div class="section doc" data-reactid="4344">keyval =&gt; key val
  Returns a new sorted map with supplied mappings, using the supplied
  comparator.  If any keys are equal, they are handled as if by
  repeated uses of assoc.</div><div class="section" data-reactid="4345"><a href="../clj/clojure.core/sorted-map-by.html" data-reactid="4346"><h3 data-reactid="4347">+ Source</h3></a></div></div><div class="var-info" data-reactid="4348"><a href="../clj/clojure.core/sorted-set.html" data-reactid="4349"><h2 data-reactid="4350">(sorted-set &amp; keys)</h2></a><div class="section doc" data-reactid="4351">Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.</div><div class="section" data-reactid="4352"><a href="../clj/clojure.core/sorted-set.html" data-reactid="4353"><h3 data-reactid="4354">+ Source</h3></a></div></div><div class="var-info" data-reactid="4355"><a href="../clj/clojure.core/sorted-set-by.html" data-reactid="4356"><h2 data-reactid="4357">(sorted-set-by comparator &amp; keys)</h2></a><div class="section doc" data-reactid="4358">Returns a new sorted set with supplied keys, using the supplied
  comparator.  Any equal keys are handled as if by repeated uses of
  conj.</div><div class="section" data-reactid="4359"><a href="../clj/clojure.core/sorted-set-by.html" data-reactid="4360"><h3 data-reactid="4361">+ Source</h3></a></div></div><div class="var-info" data-reactid="4362"><a href="../clj/clojure.core/sorted&#x27;q&#x27;.html" data-reactid="4363"><h2 data-reactid="4364">(sorted? coll)</h2></a><div class="section doc" data-reactid="4365">Returns true if coll implements Sorted</div><div class="section" data-reactid="4366"><a href="../clj/clojure.core/sorted&#x27;q&#x27;.html" data-reactid="4367"><h3 data-reactid="4368">+ Source</h3></a></div></div><div class="var-info" data-reactid="4369"><a href="../clj/clojure.core/special-symbol&#x27;q&#x27;.html" data-reactid="4370"><h2 data-reactid="4371">(special-symbol? s)</h2></a><div class="section doc" data-reactid="4372">Returns true if s names a special form</div><div class="section" data-reactid="4373"><a href="../clj/clojure.core/special-symbol&#x27;q&#x27;.html" data-reactid="4374"><h3 data-reactid="4375">+ Source</h3></a></div></div><div class="var-info" data-reactid="4376"><a href="../clj/clojure.core/spit.html" data-reactid="4377"><h2 data-reactid="4378">(spit f content &amp; options)</h2></a><div class="section doc" data-reactid="4379">Opposite of slurp.  Opens f with writer, writes content, then
  closes f. Options passed to clojure.java.io/writer.</div><div class="section" data-reactid="4380"><a href="../clj/clojure.core/spit.html" data-reactid="4381"><h3 data-reactid="4382">+ Source</h3></a></div></div><div class="var-info" data-reactid="4383"><a href="../clj/clojure.core/split-at.html" data-reactid="4384"><h2 data-reactid="4385">(split-at n coll)</h2></a><div class="section doc" data-reactid="4386">Returns a vector of [(take n coll) (drop n coll)]</div><div class="section" data-reactid="4387"><a href="../clj/clojure.core/split-at.html" data-reactid="4388"><h3 data-reactid="4389">+ Source</h3></a></div></div><div class="var-info" data-reactid="4390"><a href="../clj/clojure.core/split-with.html" data-reactid="4391"><h2 data-reactid="4392">(split-with pred coll)</h2></a><div class="section doc" data-reactid="4393">Returns a vector of [(take-while pred coll) (drop-while pred coll)]</div><div class="section" data-reactid="4394"><a href="../clj/clojure.core/split-with.html" data-reactid="4395"><h3 data-reactid="4396">+ Source</h3></a></div></div><div class="var-info" data-reactid="4397"><a href="../clj/clojure.core/str.html" data-reactid="4398"><h2 data-reactid="4399">(str)</h2><h2 data-reactid="4400">(str x)</h2><h2 data-reactid="4401">(str x &amp; ys)</h2></a><div class="section doc" data-reactid="4402">With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.</div><div class="section" data-reactid="4403"><a href="../clj/clojure.core/str.html" data-reactid="4404"><h3 data-reactid="4405">+ Source</h3></a></div></div><div class="var-info" data-reactid="4406"><a href="../clj/clojure.core/string&#x27;q&#x27;.html" data-reactid="4407"><h2 data-reactid="4408">(string? x)</h2></a><div class="section doc" data-reactid="4409">Return true if x is a String</div><div class="section" data-reactid="4410"><a href="../clj/clojure.core/string&#x27;q&#x27;.html" data-reactid="4411"><h3 data-reactid="4412">+ Source</h3></a></div></div><div class="var-info" data-reactid="4413"><a href="../clj/clojure.core/struct.html" data-reactid="4414"><h2 data-reactid="4415">(struct s &amp; vals)</h2></a><div class="section doc" data-reactid="4416">Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil.</div><div class="section" data-reactid="4417"><a href="../clj/clojure.core/struct.html" data-reactid="4418"><h3 data-reactid="4419">+ Source</h3></a></div></div><div class="var-info" data-reactid="4420"><a href="../clj/clojure.core/struct-map.html" data-reactid="4421"><h2 data-reactid="4422">(struct-map s &amp; inits)</h2></a><div class="section doc" data-reactid="4423">Returns a new structmap instance with the keys of the
  structure-basis. keyvals may contain all, some or none of the basis
  keys - where values are not supplied they will default to nil.
  keyvals can also contain keys not in the basis.</div><div class="section" data-reactid="4424"><a href="../clj/clojure.core/struct-map.html" data-reactid="4425"><h3 data-reactid="4426">+ Source</h3></a></div></div><div class="var-info" data-reactid="4427"><a href="../clj/clojure.core/subs.html" data-reactid="4428"><h2 data-reactid="4429">(subs s start)</h2><h2 data-reactid="4430">(subs s start end)</h2></a><div class="section doc" data-reactid="4431">Returns the substring of s beginning at start inclusive, and ending
  at end (defaults to length of string), exclusive.</div><div class="section" data-reactid="4432"><a href="../clj/clojure.core/subs.html" data-reactid="4433"><h3 data-reactid="4434">+ Source</h3></a></div></div><div class="var-info" data-reactid="4435"><a href="../clj/clojure.core/subseq.html" data-reactid="4436"><h2 data-reactid="4437">(subseq sc test key)</h2><h2 data-reactid="4438">(subseq sc start-test start-key end-test end-key)</h2></a><div class="section doc" data-reactid="4439">sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or
  &gt;=. Returns a seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true</div><div class="section" data-reactid="4440"><a href="../clj/clojure.core/subseq.html" data-reactid="4441"><h3 data-reactid="4442">+ Source</h3></a></div></div><div class="var-info" data-reactid="4443"><a href="../clj/clojure.core/subvec.html" data-reactid="4444"><h2 data-reactid="4445">(subvec v start)</h2><h2 data-reactid="4446">(subvec v start end)</h2></a><div class="section doc" data-reactid="4447">Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.</div><div class="section" data-reactid="4448"><a href="../clj/clojure.core/subvec.html" data-reactid="4449"><h3 data-reactid="4450">+ Source</h3></a></div></div><div class="var-info" data-reactid="4451"><a href="../clj/clojure.core/supers.html" data-reactid="4452"><h2 data-reactid="4453">(supers class)</h2></a><div class="section doc" data-reactid="4454">Returns the immediate and indirect superclasses and interfaces of c, if any</div><div class="section" data-reactid="4455"><a href="../clj/clojure.core/supers.html" data-reactid="4456"><h3 data-reactid="4457">+ Source</h3></a></div></div><div class="var-info" data-reactid="4458"><a href="../clj/clojure.core/swap&#x27;e&#x27;.html" data-reactid="4459"><h2 data-reactid="4460">(swap! atom f)</h2><h2 data-reactid="4461">(swap! atom f x)</h2><h2 data-reactid="4462">(swap! atom f x y)</h2><h2 data-reactid="4463">(swap! atom f x y &amp; args)</h2></a><div class="section doc" data-reactid="4464">Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.  Returns
  the value that was swapped in.</div><div class="section" data-reactid="4465"><a href="../clj/clojure.core/swap&#x27;e&#x27;.html" data-reactid="4466"><h3 data-reactid="4467">+ Source</h3></a></div></div><div class="var-info" data-reactid="4468"><a href="../clj/clojure.core/swap-vals&#x27;e&#x27;.html" data-reactid="4469"><h2 data-reactid="4470">(swap-vals! atom f)</h2><h2 data-reactid="4471">(swap-vals! atom f x)</h2><h2 data-reactid="4472">(swap-vals! atom f x y)</h2><h2 data-reactid="4473">(swap-vals! atom f x y &amp; args)</h2></a><div class="section doc" data-reactid="4474">Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.
  Returns [old new], the value of the atom before and after the swap.</div><div class="section" data-reactid="4475"><a href="../clj/clojure.core/swap-vals&#x27;e&#x27;.html" data-reactid="4476"><h3 data-reactid="4477">+ Source</h3></a></div></div><div class="var-info" data-reactid="4478"><a href="../clj/clojure.core/symbol.html" data-reactid="4479"><h2 data-reactid="4480">(symbol name)</h2><h2 data-reactid="4481">(symbol ns name)</h2></a><div class="section doc" data-reactid="4482">Returns a Symbol with the given namespace and name.</div><div class="section" data-reactid="4483"><a href="../clj/clojure.core/symbol.html" data-reactid="4484"><h3 data-reactid="4485">+ Source</h3></a></div></div><div class="var-info" data-reactid="4486"><a href="../clj/clojure.core/symbol&#x27;q&#x27;.html" data-reactid="4487"><h2 data-reactid="4488">(symbol? x)</h2></a><div class="section doc" data-reactid="4489">Return true if x is a Symbol</div><div class="section" data-reactid="4490"><a href="../clj/clojure.core/symbol&#x27;q&#x27;.html" data-reactid="4491"><h3 data-reactid="4492">+ Source</h3></a></div></div><div class="var-info" data-reactid="4493"><a href="../clj/clojure.core/sync.html" data-reactid="4494"><h2 data-reactid="4495">(sync flags-ignored-for-now &amp; body)</h2></a><div class="section doc" data-reactid="4496">transaction-flags =&gt; TBD, pass nil for now

  Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of sync. The exprs may be run more than
  once, but any effects on Refs will be atomic.</div><div class="section" data-reactid="4497"><a href="../clj/clojure.core/sync.html" data-reactid="4498"><h3 data-reactid="4499">+ Source</h3></a></div></div><div class="var-info" data-reactid="4500"><a href="../clj/clojure.core/tagged-literal.html" data-reactid="4501"><h2 data-reactid="4502">(tagged-literal tag form)</h2></a><div class="section doc" data-reactid="4503">Construct a data representation of a tagged literal from a
  tag symbol and a form.</div><div class="section" data-reactid="4504"><a href="../clj/clojure.core/tagged-literal.html" data-reactid="4505"><h3 data-reactid="4506">+ Source</h3></a></div></div><div class="var-info" data-reactid="4507"><a href="../clj/clojure.core/tagged-literal&#x27;q&#x27;.html" data-reactid="4508"><h2 data-reactid="4509">(tagged-literal? value)</h2></a><div class="section doc" data-reactid="4510">Return true if the value is the data representation of a tagged literal</div><div class="section" data-reactid="4511"><a href="../clj/clojure.core/tagged-literal&#x27;q&#x27;.html" data-reactid="4512"><h3 data-reactid="4513">+ Source</h3></a></div></div><div class="var-info" data-reactid="4514"><a href="../clj/clojure.core/take.html" data-reactid="4515"><h2 data-reactid="4516">(take n)</h2><h2 data-reactid="4517">(take n coll)</h2></a><div class="section doc" data-reactid="4518">Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.</div><div class="section" data-reactid="4519"><a href="../clj/clojure.core/take.html" data-reactid="4520"><h3 data-reactid="4521">+ Source</h3></a></div></div><div class="var-info" data-reactid="4522"><a href="../clj/clojure.core/take-last.html" data-reactid="4523"><h2 data-reactid="4524">(take-last n coll)</h2></a><div class="section doc" data-reactid="4525">Returns a seq of the last n items in coll.  Depending on the type
  of coll may be no better than linear time.  For vectors, see also subvec.</div><div class="section" data-reactid="4526"><a href="../clj/clojure.core/take-last.html" data-reactid="4527"><h3 data-reactid="4528">+ Source</h3></a></div></div><div class="var-info" data-reactid="4529"><a href="../clj/clojure.core/take-nth.html" data-reactid="4530"><h2 data-reactid="4531">(take-nth n)</h2><h2 data-reactid="4532">(take-nth n coll)</h2></a><div class="section doc" data-reactid="4533">Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.</div><div class="section" data-reactid="4534"><a href="../clj/clojure.core/take-nth.html" data-reactid="4535"><h3 data-reactid="4536">+ Source</h3></a></div></div><div class="var-info" data-reactid="4537"><a href="../clj/clojure.core/take-while.html" data-reactid="4538"><h2 data-reactid="4539">(take-while pred)</h2><h2 data-reactid="4540">(take-while pred coll)</h2></a><div class="section doc" data-reactid="4541">Returns a lazy sequence of successive items from coll while
  (pred item) returns logical true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.</div><div class="section" data-reactid="4542"><a href="../clj/clojure.core/take-while.html" data-reactid="4543"><h3 data-reactid="4544">+ Source</h3></a></div></div><div class="var-info" data-reactid="4545"><a href="../clj/clojure.core/test.html" data-reactid="4546"><h2 data-reactid="4547">(test v)</h2></a><div class="section doc" data-reactid="4548">test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception</div><div class="section" data-reactid="4549"><a href="../clj/clojure.core/test.html" data-reactid="4550"><h3 data-reactid="4551">+ Source</h3></a></div></div><div class="var-info" data-reactid="4552"><a href="../clj/clojure.core/the-ns.html" data-reactid="4553"><h2 data-reactid="4554">(the-ns x)</h2></a><div class="section doc" data-reactid="4555">If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.</div><div class="section" data-reactid="4556"><a href="../clj/clojure.core/the-ns.html" data-reactid="4557"><h3 data-reactid="4558">+ Source</h3></a></div></div><div class="var-info" data-reactid="4559"><a href="../clj/clojure.core/thread-bound&#x27;q&#x27;.html" data-reactid="4560"><h2 data-reactid="4561">(thread-bound? &amp; vars)</h2></a><div class="section doc" data-reactid="4562">Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!&#x27;ing the provided vars will succeed.  Returns true if no vars are provided.</div><div class="section" data-reactid="4563"><a href="../clj/clojure.core/thread-bound&#x27;q&#x27;.html" data-reactid="4564"><h3 data-reactid="4565">+ Source</h3></a></div></div><div class="var-info" data-reactid="4566"><a href="../clj/clojure.core/time.html" data-reactid="4567"><h2 data-reactid="4568">(time expr)</h2></a><div class="section doc" data-reactid="4569">Evaluates expr and prints the time it took.  Returns the value of
 expr.</div><div class="section" data-reactid="4570"><a href="../clj/clojure.core/time.html" data-reactid="4571"><h3 data-reactid="4572">+ Source</h3></a></div></div><div class="var-info" data-reactid="4573"><a href="../clj/clojure.core/to-array.html" data-reactid="4574"><h2 data-reactid="4575">(to-array coll)</h2></a><div class="section doc" data-reactid="4576">Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().</div><div class="section" data-reactid="4577"><a href="../clj/clojure.core/to-array.html" data-reactid="4578"><h3 data-reactid="4579">+ Source</h3></a></div></div><div class="var-info" data-reactid="4580"><a href="../clj/clojure.core/to-array-2d.html" data-reactid="4581"><h2 data-reactid="4582">(to-array-2d coll)</h2></a><div class="section doc" data-reactid="4583">Returns a (potentially-ragged) 2-dimensional array of Objects
  containing the contents of coll, which can be any Collection of any
  Collection.</div><div class="section" data-reactid="4584"><a href="../clj/clojure.core/to-array-2d.html" data-reactid="4585"><h3 data-reactid="4586">+ Source</h3></a></div></div><div class="var-info" data-reactid="4587"><a href="../clj/clojure.core/trampoline.html" data-reactid="4588"><h2 data-reactid="4589">(trampoline f)</h2><h2 data-reactid="4590">(trampoline f &amp; args)</h2></a><div class="section doc" data-reactid="4591">trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns.</div><div class="section" data-reactid="4592"><a href="../clj/clojure.core/trampoline.html" data-reactid="4593"><h3 data-reactid="4594">+ Source</h3></a></div></div><div class="var-info" data-reactid="4595"><a href="../clj/clojure.core/transduce.html" data-reactid="4596"><h2 data-reactid="4597">(transduce xform f coll)</h2><h2 data-reactid="4598">(transduce xform f init coll)</h2></a><div class="section doc" data-reactid="4599">reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &#x27;completing&#x27;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.</div><div class="section" data-reactid="4600"><a href="../clj/clojure.core/transduce.html" data-reactid="4601"><h3 data-reactid="4602">+ Source</h3></a></div></div><div class="var-info" data-reactid="4603"><a href="../clj/clojure.core/transient.html" data-reactid="4604"><h2 data-reactid="4605">(transient coll)</h2></a><div class="section doc" data-reactid="4606">Returns a new, transient version of the collection, in constant time.</div><div class="section" data-reactid="4607"><a href="../clj/clojure.core/transient.html" data-reactid="4608"><h3 data-reactid="4609">+ Source</h3></a></div></div><div class="var-info" data-reactid="4610"><a href="../clj/clojure.core/tree-seq.html" data-reactid="4611"><h2 data-reactid="4612">(tree-seq branch? children root)</h2></a><div class="section doc" data-reactid="4613">Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.</div><div class="section" data-reactid="4614"><a href="../clj/clojure.core/tree-seq.html" data-reactid="4615"><h3 data-reactid="4616">+ Source</h3></a></div></div><div class="var-info" data-reactid="4617"><a href="../clj/clojure.core/true&#x27;q&#x27;.html" data-reactid="4618"><h2 data-reactid="4619">(true? x)</h2></a><div class="section doc" data-reactid="4620">Returns true if x is the value true, false otherwise.</div><div class="section" data-reactid="4621"><a href="../clj/clojure.core/true&#x27;q&#x27;.html" data-reactid="4622"><h3 data-reactid="4623">+ Source</h3></a></div></div><div class="var-info" data-reactid="4624"><a href="../clj/clojure.core/type.html" data-reactid="4625"><h2 data-reactid="4626">(type x)</h2></a><div class="section doc" data-reactid="4627">Returns the :type metadata of x, or its Class if none</div><div class="section" data-reactid="4628"><a href="../clj/clojure.core/type.html" data-reactid="4629"><h3 data-reactid="4630">+ Source</h3></a></div></div><div class="var-info" data-reactid="4631"><a href="../clj/clojure.core/unchecked-add.html" data-reactid="4632"><h2 data-reactid="4633">(unchecked-add x y)</h2></a><div class="section doc" data-reactid="4634">Returns the sum of x and y, both long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4635"><a href="../clj/clojure.core/unchecked-add.html" data-reactid="4636"><h3 data-reactid="4637">+ Source</h3></a></div></div><div class="var-info" data-reactid="4638"><a href="../clj/clojure.core/unchecked-add-int.html" data-reactid="4639"><h2 data-reactid="4640">(unchecked-add-int x y)</h2></a><div class="section doc" data-reactid="4641">Returns the sum of x and y, both int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4642"><a href="../clj/clojure.core/unchecked-add-int.html" data-reactid="4643"><h3 data-reactid="4644">+ Source</h3></a></div></div><div class="var-info" data-reactid="4645"><a href="../clj/clojure.core/unchecked-byte.html" data-reactid="4646"><h2 data-reactid="4647">(unchecked-byte x)</h2></a><div class="section doc" data-reactid="4648">Coerce to byte. Subject to rounding or truncation.</div><div class="section" data-reactid="4649"><a href="../clj/clojure.core/unchecked-byte.html" data-reactid="4650"><h3 data-reactid="4651">+ Source</h3></a></div></div><div class="var-info" data-reactid="4652"><a href="../clj/clojure.core/unchecked-char.html" data-reactid="4653"><h2 data-reactid="4654">(unchecked-char x)</h2></a><div class="section doc" data-reactid="4655">Coerce to char. Subject to rounding or truncation.</div><div class="section" data-reactid="4656"><a href="../clj/clojure.core/unchecked-char.html" data-reactid="4657"><h3 data-reactid="4658">+ Source</h3></a></div></div><div class="var-info" data-reactid="4659"><a href="../clj/clojure.core/unchecked-dec.html" data-reactid="4660"><h2 data-reactid="4661">(unchecked-dec x)</h2></a><div class="section doc" data-reactid="4662">Returns a number one less than x, a long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4663"><a href="../clj/clojure.core/unchecked-dec.html" data-reactid="4664"><h3 data-reactid="4665">+ Source</h3></a></div></div><div class="var-info" data-reactid="4666"><a href="../clj/clojure.core/unchecked-dec-int.html" data-reactid="4667"><h2 data-reactid="4668">(unchecked-dec-int x)</h2></a><div class="section doc" data-reactid="4669">Returns a number one less than x, an int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4670"><a href="../clj/clojure.core/unchecked-dec-int.html" data-reactid="4671"><h3 data-reactid="4672">+ Source</h3></a></div></div><div class="var-info" data-reactid="4673"><a href="../clj/clojure.core/unchecked-divide-int.html" data-reactid="4674"><h2 data-reactid="4675">(unchecked-divide-int x y)</h2></a><div class="section doc" data-reactid="4676">Returns the division of x by y, both int.
  Note - uses a primitive operator subject to truncation.</div><div class="section" data-reactid="4677"><a href="../clj/clojure.core/unchecked-divide-int.html" data-reactid="4678"><h3 data-reactid="4679">+ Source</h3></a></div></div><div class="var-info" data-reactid="4680"><a href="../clj/clojure.core/unchecked-double.html" data-reactid="4681"><h2 data-reactid="4682">(unchecked-double x)</h2></a><div class="section doc" data-reactid="4683">Coerce to double. Subject to rounding.</div><div class="section" data-reactid="4684"><a href="../clj/clojure.core/unchecked-double.html" data-reactid="4685"><h3 data-reactid="4686">+ Source</h3></a></div></div><div class="var-info" data-reactid="4687"><a href="../clj/clojure.core/unchecked-float.html" data-reactid="4688"><h2 data-reactid="4689">(unchecked-float x)</h2></a><div class="section doc" data-reactid="4690">Coerce to float. Subject to rounding.</div><div class="section" data-reactid="4691"><a href="../clj/clojure.core/unchecked-float.html" data-reactid="4692"><h3 data-reactid="4693">+ Source</h3></a></div></div><div class="var-info" data-reactid="4694"><a href="../clj/clojure.core/unchecked-inc.html" data-reactid="4695"><h2 data-reactid="4696">(unchecked-inc x)</h2></a><div class="section doc" data-reactid="4697">Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4698"><a href="../clj/clojure.core/unchecked-inc.html" data-reactid="4699"><h3 data-reactid="4700">+ Source</h3></a></div></div><div class="var-info" data-reactid="4701"><a href="../clj/clojure.core/unchecked-inc-int.html" data-reactid="4702"><h2 data-reactid="4703">(unchecked-inc-int x)</h2></a><div class="section doc" data-reactid="4704">Returns a number one greater than x, an int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4705"><a href="../clj/clojure.core/unchecked-inc-int.html" data-reactid="4706"><h3 data-reactid="4707">+ Source</h3></a></div></div><div class="var-info" data-reactid="4708"><a href="../clj/clojure.core/unchecked-int.html" data-reactid="4709"><h2 data-reactid="4710">(unchecked-int x)</h2></a><div class="section doc" data-reactid="4711">Coerce to int. Subject to rounding or truncation.</div><div class="section" data-reactid="4712"><a href="../clj/clojure.core/unchecked-int.html" data-reactid="4713"><h3 data-reactid="4714">+ Source</h3></a></div></div><div class="var-info" data-reactid="4715"><a href="../clj/clojure.core/unchecked-long.html" data-reactid="4716"><h2 data-reactid="4717">(unchecked-long x)</h2></a><div class="section doc" data-reactid="4718">Coerce to long. Subject to rounding or truncation.</div><div class="section" data-reactid="4719"><a href="../clj/clojure.core/unchecked-long.html" data-reactid="4720"><h3 data-reactid="4721">+ Source</h3></a></div></div><div class="var-info" data-reactid="4722"><a href="../clj/clojure.core/unchecked-multiply.html" data-reactid="4723"><h2 data-reactid="4724">(unchecked-multiply x y)</h2></a><div class="section doc" data-reactid="4725">Returns the product of x and y, both long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4726"><a href="../clj/clojure.core/unchecked-multiply.html" data-reactid="4727"><h3 data-reactid="4728">+ Source</h3></a></div></div><div class="var-info" data-reactid="4729"><a href="../clj/clojure.core/unchecked-multiply-int.html" data-reactid="4730"><h2 data-reactid="4731">(unchecked-multiply-int x y)</h2></a><div class="section doc" data-reactid="4732">Returns the product of x and y, both int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4733"><a href="../clj/clojure.core/unchecked-multiply-int.html" data-reactid="4734"><h3 data-reactid="4735">+ Source</h3></a></div></div><div class="var-info" data-reactid="4736"><a href="../clj/clojure.core/unchecked-negate.html" data-reactid="4737"><h2 data-reactid="4738">(unchecked-negate x)</h2></a><div class="section doc" data-reactid="4739">Returns the negation of x, a long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4740"><a href="../clj/clojure.core/unchecked-negate.html" data-reactid="4741"><h3 data-reactid="4742">+ Source</h3></a></div></div><div class="var-info" data-reactid="4743"><a href="../clj/clojure.core/unchecked-negate-int.html" data-reactid="4744"><h2 data-reactid="4745">(unchecked-negate-int x)</h2></a><div class="section doc" data-reactid="4746">Returns the negation of x, an int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4747"><a href="../clj/clojure.core/unchecked-negate-int.html" data-reactid="4748"><h3 data-reactid="4749">+ Source</h3></a></div></div><div class="var-info" data-reactid="4750"><a href="../clj/clojure.core/unchecked-remainder-int.html" data-reactid="4751"><h2 data-reactid="4752">(unchecked-remainder-int x y)</h2></a><div class="section doc" data-reactid="4753">Returns the remainder of division of x by y, both int.
  Note - uses a primitive operator subject to truncation.</div><div class="section" data-reactid="4754"><a href="../clj/clojure.core/unchecked-remainder-int.html" data-reactid="4755"><h3 data-reactid="4756">+ Source</h3></a></div></div><div class="var-info" data-reactid="4757"><a href="../clj/clojure.core/unchecked-short.html" data-reactid="4758"><h2 data-reactid="4759">(unchecked-short x)</h2></a><div class="section doc" data-reactid="4760">Coerce to short. Subject to rounding or truncation.</div><div class="section" data-reactid="4761"><a href="../clj/clojure.core/unchecked-short.html" data-reactid="4762"><h3 data-reactid="4763">+ Source</h3></a></div></div><div class="var-info" data-reactid="4764"><a href="../clj/clojure.core/unchecked-subtract.html" data-reactid="4765"><h2 data-reactid="4766">(unchecked-subtract x y)</h2></a><div class="section doc" data-reactid="4767">Returns the difference of x and y, both long.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4768"><a href="../clj/clojure.core/unchecked-subtract.html" data-reactid="4769"><h3 data-reactid="4770">+ Source</h3></a></div></div><div class="var-info" data-reactid="4771"><a href="../clj/clojure.core/unchecked-subtract-int.html" data-reactid="4772"><h2 data-reactid="4773">(unchecked-subtract-int x y)</h2></a><div class="section doc" data-reactid="4774">Returns the difference of x and y, both int.
  Note - uses a primitive operator subject to overflow.</div><div class="section" data-reactid="4775"><a href="../clj/clojure.core/unchecked-subtract-int.html" data-reactid="4776"><h3 data-reactid="4777">+ Source</h3></a></div></div><div class="var-info" data-reactid="4778"><a href="../clj/clojure.core/underive.html" data-reactid="4779"><h2 data-reactid="4780">(underive tag parent)</h2><h2 data-reactid="4781">(underive h tag parent)</h2></a><div class="section doc" data-reactid="4782">Removes a parent/child relationship between parent and
  tag. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.</div><div class="section" data-reactid="4783"><a href="../clj/clojure.core/underive.html" data-reactid="4784"><h3 data-reactid="4785">+ Source</h3></a></div></div><div class="var-info" data-reactid="4786"><a href="../clj/clojure.core/unquote.html" data-reactid="4787"><h2 data-reactid="4788">unquote</h2></a><div class="section" data-reactid="4789"><a href="../clj/clojure.core/unquote.html" data-reactid="4790"><h3 data-reactid="4791">+ Source</h3></a></div></div><div class="var-info" data-reactid="4792"><a href="../clj/clojure.core/unquote-splicing.html" data-reactid="4793"><h2 data-reactid="4794">unquote-splicing</h2></a><div class="section" data-reactid="4795"><a href="../clj/clojure.core/unquote-splicing.html" data-reactid="4796"><h3 data-reactid="4797">+ Source</h3></a></div></div><div class="var-info" data-reactid="4798"><a href="../clj/clojure.core/unreduced.html" data-reactid="4799"><h2 data-reactid="4800">(unreduced x)</h2></a><div class="section doc" data-reactid="4801">If x is reduced?, returns (deref x), else returns x</div><div class="section" data-reactid="4802"><a href="../clj/clojure.core/unreduced.html" data-reactid="4803"><h3 data-reactid="4804">+ Source</h3></a></div></div><div class="var-info" data-reactid="4805"><a href="../clj/clojure.core/unsigned-bit-shift-right.html" data-reactid="4806"><h2 data-reactid="4807">(unsigned-bit-shift-right x n)</h2></a><div class="section doc" data-reactid="4808">Bitwise shift right, without sign-extension.</div><div class="section" data-reactid="4809"><a href="../clj/clojure.core/unsigned-bit-shift-right.html" data-reactid="4810"><h3 data-reactid="4811">+ Source</h3></a></div></div><div class="var-info" data-reactid="4812"><a href="../clj/clojure.core/update.html" data-reactid="4813"><h2 data-reactid="4814">(update m k f)</h2><h2 data-reactid="4815">(update m k f x)</h2><h2 data-reactid="4816">(update m k f x y)</h2><h2 data-reactid="4817">(update m k f x y z)</h2><h2 data-reactid="4818">(update m k f x y z &amp; more)</h2></a><div class="section doc" data-reactid="4819">&#x27;Updates&#x27; a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value.</div><div class="section" data-reactid="4820"><a href="../clj/clojure.core/update.html" data-reactid="4821"><h3 data-reactid="4822">+ Source</h3></a></div></div><div class="var-info" data-reactid="4823"><a href="../clj/clojure.core/update-in.html" data-reactid="4824"><h2 data-reactid="4825">(update-in m ks f &amp; args)</h2></a><div class="section doc" data-reactid="4826">&#x27;Updates&#x27; a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.</div><div class="section" data-reactid="4827"><a href="../clj/clojure.core/update-in.html" data-reactid="4828"><h3 data-reactid="4829">+ Source</h3></a></div></div><div class="var-info" data-reactid="4830"><a href="../clj/clojure.core/update-proxy.html" data-reactid="4831"><h2 data-reactid="4832">(update-proxy proxy mappings)</h2></a><div class="section doc" data-reactid="4833">Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  updates (via assoc) the proxy&#x27;s fn map. nil can be passed instead of
  a fn, in which case the corresponding method will revert to the
  default behavior. Note that this function can be used to update the
  behavior of an existing instance without changing its identity.
  Returns the proxy.</div><div class="section" data-reactid="4834"><a href="../clj/clojure.core/update-proxy.html" data-reactid="4835"><h3 data-reactid="4836">+ Source</h3></a></div></div><div class="var-info" data-reactid="4837"><a href="../clj/clojure.core/uri&#x27;q&#x27;.html" data-reactid="4838"><h2 data-reactid="4839">(uri? x)</h2></a><div class="section doc" data-reactid="4840">Return true if x is a java.net.URI</div><div class="section" data-reactid="4841"><a href="../clj/clojure.core/uri&#x27;q&#x27;.html" data-reactid="4842"><h3 data-reactid="4843">+ Source</h3></a></div></div><div class="var-info" data-reactid="4844"><a href="../clj/clojure.core/use.html" data-reactid="4845"><h2 data-reactid="4846">(use &amp; args)</h2></a><div class="section doc" data-reactid="4847">Like &#x27;require, but also refers to each lib&#x27;s namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  &#x27;use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.</div><div class="section" data-reactid="4848"><a href="../clj/clojure.core/use.html" data-reactid="4849"><h3 data-reactid="4850">+ Source</h3></a></div></div><div class="var-info" data-reactid="4851"><a href="../clj/clojure.core/uuid&#x27;q&#x27;.html" data-reactid="4852"><h2 data-reactid="4853">(uuid? x)</h2></a><div class="section doc" data-reactid="4854">Return true if x is a java.util.UUID</div><div class="section" data-reactid="4855"><a href="../clj/clojure.core/uuid&#x27;q&#x27;.html" data-reactid="4856"><h3 data-reactid="4857">+ Source</h3></a></div></div><div class="var-info" data-reactid="4858"><a href="../clj/clojure.core/val.html" data-reactid="4859"><h2 data-reactid="4860">(val e)</h2></a><div class="section doc" data-reactid="4861">Returns the value in the map entry.</div><div class="section" data-reactid="4862"><a href="../clj/clojure.core/val.html" data-reactid="4863"><h3 data-reactid="4864">+ Source</h3></a></div></div><div class="var-info" data-reactid="4865"><a href="../clj/clojure.core/vals.html" data-reactid="4866"><h2 data-reactid="4867">(vals map)</h2></a><div class="section doc" data-reactid="4868">Returns a sequence of the map&#x27;s values, in the same order as (seq map).</div><div class="section" data-reactid="4869"><a href="../clj/clojure.core/vals.html" data-reactid="4870"><h3 data-reactid="4871">+ Source</h3></a></div></div><div class="var-info" data-reactid="4872"><a href="../clj/clojure.core/var-get.html" data-reactid="4873"><h2 data-reactid="4874">(var-get x)</h2></a><div class="section doc" data-reactid="4875">Gets the value in the var object</div><div class="section" data-reactid="4876"><a href="../clj/clojure.core/var-get.html" data-reactid="4877"><h3 data-reactid="4878">+ Source</h3></a></div></div><div class="var-info" data-reactid="4879"><a href="../clj/clojure.core/var-set.html" data-reactid="4880"><h2 data-reactid="4881">(var-set x val)</h2></a><div class="section doc" data-reactid="4882">Sets the value in the var object to val. The var must be
 thread-locally bound.</div><div class="section" data-reactid="4883"><a href="../clj/clojure.core/var-set.html" data-reactid="4884"><h3 data-reactid="4885">+ Source</h3></a></div></div><div class="var-info" data-reactid="4886"><a href="../clj/clojure.core/var&#x27;q&#x27;.html" data-reactid="4887"><h2 data-reactid="4888">(var? v)</h2></a><div class="section doc" data-reactid="4889">Returns true if v is of type clojure.lang.Var</div><div class="section" data-reactid="4890"><a href="../clj/clojure.core/var&#x27;q&#x27;.html" data-reactid="4891"><h3 data-reactid="4892">+ Source</h3></a></div></div><div class="var-info" data-reactid="4893"><a href="../clj/clojure.core/vary-meta.html" data-reactid="4894"><h2 data-reactid="4895">(vary-meta obj f &amp; args)</h2></a><div class="section doc" data-reactid="4896">Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.</div><div class="section" data-reactid="4897"><a href="../clj/clojure.core/vary-meta.html" data-reactid="4898"><h3 data-reactid="4899">+ Source</h3></a></div></div><div class="var-info" data-reactid="4900"><a href="../clj/clojure.core/vec.html" data-reactid="4901"><h2 data-reactid="4902">(vec coll)</h2></a><div class="section doc" data-reactid="4903">Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.</div><div class="section" data-reactid="4904"><a href="../clj/clojure.core/vec.html" data-reactid="4905"><h3 data-reactid="4906">+ Source</h3></a></div></div><div class="var-info" data-reactid="4907"><a href="../clj/clojure.core/vector.html" data-reactid="4908"><h2 data-reactid="4909">(vector)</h2><h2 data-reactid="4910">(vector a)</h2><h2 data-reactid="4911">(vector a b)</h2><h2 data-reactid="4912">(vector a b c)</h2><h2 data-reactid="4913">(vector a b c d)</h2><h2 data-reactid="4914">(vector a b c d e)</h2><h2 data-reactid="4915">(vector a b c d e f)</h2><h2 data-reactid="4916">(vector a b c d e f &amp; args)</h2></a><div class="section doc" data-reactid="4917">Creates a new vector containing the args.</div><div class="section" data-reactid="4918"><a href="../clj/clojure.core/vector.html" data-reactid="4919"><h3 data-reactid="4920">+ Source</h3></a></div></div><div class="var-info" data-reactid="4921"><a href="../clj/clojure.core/vector-of.html" data-reactid="4922"><h2 data-reactid="4923">(vector-of t)</h2><h2 data-reactid="4924">(vector-of t &amp; elements)</h2></a><div class="section doc" data-reactid="4925">Creates a new vector of a single primitive type t, where t is one
  of :int :long :float :double :byte :short :char or :boolean. The
  resulting vector complies with the interface of vectors in general,
  but stores the values unboxed internally.

  Optionally takes one or more elements to populate the vector.</div><div class="section" data-reactid="4926"><a href="../clj/clojure.core/vector-of.html" data-reactid="4927"><h3 data-reactid="4928">+ Source</h3></a></div></div><div class="var-info" data-reactid="4929"><a href="../clj/clojure.core/vector&#x27;q&#x27;.html" data-reactid="4930"><h2 data-reactid="4931">(vector? x)</h2></a><div class="section doc" data-reactid="4932">Return true if x implements IPersistentVector</div><div class="section" data-reactid="4933"><a href="../clj/clojure.core/vector&#x27;q&#x27;.html" data-reactid="4934"><h3 data-reactid="4935">+ Source</h3></a></div></div><div class="var-info" data-reactid="4936"><a href="../clj/clojure.core/volatile&#x27;e&#x27;.html" data-reactid="4937"><h2 data-reactid="4938">(volatile! val)</h2></a><div class="section doc" data-reactid="4939">Creates and returns a Volatile with an initial value of val.</div><div class="section" data-reactid="4940"><a href="../clj/clojure.core/volatile&#x27;e&#x27;.html" data-reactid="4941"><h3 data-reactid="4942">+ Source</h3></a></div></div><div class="var-info" data-reactid="4943"><a href="../clj/clojure.core/volatile&#x27;q&#x27;.html" data-reactid="4944"><h2 data-reactid="4945">(volatile? x)</h2></a><div class="section doc" data-reactid="4946">Returns true if x is a volatile.</div><div class="section" data-reactid="4947"><a href="../clj/clojure.core/volatile&#x27;q&#x27;.html" data-reactid="4948"><h3 data-reactid="4949">+ Source</h3></a></div></div><div class="var-info" data-reactid="4950"><a href="../clj/clojure.core/vreset&#x27;e&#x27;.html" data-reactid="4951"><h2 data-reactid="4952">(vreset! vol newval)</h2></a><div class="section doc" data-reactid="4953">Sets the value of volatile to newval without regard for the
   current value. Returns newval.</div><div class="section" data-reactid="4954"><a href="../clj/clojure.core/vreset&#x27;e&#x27;.html" data-reactid="4955"><h3 data-reactid="4956">+ Source</h3></a></div></div><div class="var-info" data-reactid="4957"><a href="../clj/clojure.core/vswap&#x27;e&#x27;.html" data-reactid="4958"><h2 data-reactid="4959">(vswap! vol f &amp; args)</h2></a><div class="section doc" data-reactid="4960">Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.</div><div class="section" data-reactid="4961"><a href="../clj/clojure.core/vswap&#x27;e&#x27;.html" data-reactid="4962"><h3 data-reactid="4963">+ Source</h3></a></div></div><div class="var-info" data-reactid="4964"><a href="../clj/clojure.core/when.html" data-reactid="4965"><h2 data-reactid="4966">(when test &amp; body)</h2></a><div class="section doc" data-reactid="4967">Evaluates test. If logical true, evaluates body in an implicit do.</div><div class="section" data-reactid="4968"><a href="../clj/clojure.core/when.html" data-reactid="4969"><h3 data-reactid="4970">+ Source</h3></a></div></div><div class="var-info" data-reactid="4971"><a href="../clj/clojure.core/when-first.html" data-reactid="4972"><h2 data-reactid="4973">(when-first bindings &amp; body)</h2></a><div class="section doc" data-reactid="4974">bindings =&gt; x xs

  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once</div><div class="section" data-reactid="4975"><a href="../clj/clojure.core/when-first.html" data-reactid="4976"><h3 data-reactid="4977">+ Source</h3></a></div></div><div class="var-info" data-reactid="4978"><a href="../clj/clojure.core/when-let.html" data-reactid="4979"><h2 data-reactid="4980">(when-let bindings &amp; body)</h2></a><div class="section doc" data-reactid="4981">bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test</div><div class="section" data-reactid="4982"><a href="../clj/clojure.core/when-let.html" data-reactid="4983"><h3 data-reactid="4984">+ Spec</h3></a></div><div class="section" data-reactid="4985"><a href="../clj/clojure.core/when-let.html" data-reactid="4986"><h3 data-reactid="4987">+ Source</h3></a></div></div><div class="var-info" data-reactid="4988"><a href="../clj/clojure.core/when-not.html" data-reactid="4989"><h2 data-reactid="4990">(when-not test &amp; body)</h2></a><div class="section doc" data-reactid="4991">Evaluates test. If logical false, evaluates body in an implicit do.</div><div class="section" data-reactid="4992"><a href="../clj/clojure.core/when-not.html" data-reactid="4993"><h3 data-reactid="4994">+ Source</h3></a></div></div><div class="var-info" data-reactid="4995"><a href="../clj/clojure.core/when-some.html" data-reactid="4996"><h2 data-reactid="4997">(when-some bindings &amp; body)</h2></a><div class="section doc" data-reactid="4998">bindings =&gt; binding-form test

   When test is not nil, evaluates body with binding-form bound to the
   value of test</div><div class="section" data-reactid="4999"><a href="../clj/clojure.core/when-some.html" data-reactid="5000"><h3 data-reactid="5001">+ Source</h3></a></div></div><div class="var-info" data-reactid="5002"><a href="../clj/clojure.core/while.html" data-reactid="5003"><h2 data-reactid="5004">(while test &amp; body)</h2></a><div class="section doc" data-reactid="5005">Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil</div><div class="section" data-reactid="5006"><a href="../clj/clojure.core/while.html" data-reactid="5007"><h3 data-reactid="5008">+ Source</h3></a></div></div><div class="var-info" data-reactid="5009"><a href="../clj/clojure.core/with-bindings.html" data-reactid="5010"><h2 data-reactid="5011">(with-bindings binding-map &amp; body)</h2></a><div class="section doc" data-reactid="5012">Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then executes body. Pops the installed
  bindings after body was evaluated. Returns the value of body.</div><div class="section" data-reactid="5013"><a href="../clj/clojure.core/with-bindings.html" data-reactid="5014"><h3 data-reactid="5015">+ Source</h3></a></div></div><div class="var-info" data-reactid="5016"><a href="../clj/clojure.core/with-bindings&#x27;a&#x27;.html" data-reactid="5017"><h2 data-reactid="5018">(with-bindings* binding-map f &amp; args)</h2></a><div class="section doc" data-reactid="5019">Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.</div><div class="section" data-reactid="5020"><a href="../clj/clojure.core/with-bindings&#x27;a&#x27;.html" data-reactid="5021"><h3 data-reactid="5022">+ Source</h3></a></div></div><div class="var-info" data-reactid="5023"><a href="../clj/clojure.core/with-in-str.html" data-reactid="5024"><h2 data-reactid="5025">(with-in-str s &amp; body)</h2></a><div class="section doc" data-reactid="5026">Evaluates body in a context in which *in* is bound to a fresh
  StringReader initialized with the string s.</div><div class="section" data-reactid="5027"><a href="../clj/clojure.core/with-in-str.html" data-reactid="5028"><h3 data-reactid="5029">+ Source</h3></a></div></div><div class="var-info" data-reactid="5030"><a href="../clj/clojure.core/with-loading-context.html" data-reactid="5031"><h2 data-reactid="5032">(with-loading-context &amp; body)</h2></a><div class="section" data-reactid="5033"><a href="../clj/clojure.core/with-loading-context.html" data-reactid="5034"><h3 data-reactid="5035">+ Source</h3></a></div></div><div class="var-info" data-reactid="5036"><a href="../clj/clojure.core/with-local-vars.html" data-reactid="5037"><h2 data-reactid="5038">(with-local-vars name-vals-vec &amp; body)</h2></a><div class="section doc" data-reactid="5039">varbinding=&gt; symbol init-expr

  Executes the exprs in a context in which the symbols are bound to
  vars with per-thread bindings to the init-exprs.  The symbols refer
  to the var objects themselves, and must be accessed with var-get and
  var-set</div><div class="section" data-reactid="5040"><a href="../clj/clojure.core/with-local-vars.html" data-reactid="5041"><h3 data-reactid="5042">+ Source</h3></a></div></div><div class="var-info" data-reactid="5043"><a href="../clj/clojure.core/with-meta.html" data-reactid="5044"><h2 data-reactid="5045">(with-meta obj m)</h2></a><div class="section doc" data-reactid="5046">Returns an object of the same type and value as obj, with
    map m as its metadata.</div><div class="section" data-reactid="5047"><a href="../clj/clojure.core/with-meta.html" data-reactid="5048"><h3 data-reactid="5049">+ Source</h3></a></div></div><div class="var-info" data-reactid="5050"><a href="../clj/clojure.core/with-open.html" data-reactid="5051"><h2 data-reactid="5052">(with-open bindings &amp; body)</h2></a><div class="section doc" data-reactid="5053">bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.</div><div class="section" data-reactid="5054"><a href="../clj/clojure.core/with-open.html" data-reactid="5055"><h3 data-reactid="5056">+ Source</h3></a></div></div><div class="var-info" data-reactid="5057"><a href="../clj/clojure.core/with-out-str.html" data-reactid="5058"><h2 data-reactid="5059">(with-out-str &amp; body)</h2></a><div class="section doc" data-reactid="5060">Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.</div><div class="section" data-reactid="5061"><a href="../clj/clojure.core/with-out-str.html" data-reactid="5062"><h3 data-reactid="5063">+ Source</h3></a></div></div><div class="var-info" data-reactid="5064"><a href="../clj/clojure.core/with-precision.html" data-reactid="5065"><h2 data-reactid="5066">(with-precision precision &amp; exprs)</h2></a><div class="section doc" data-reactid="5067">Sets the precision and rounding mode to be used for BigDecimal operations.

  Usage: (with-precision 10 (/ 1M 3))
  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))

  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,
  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.</div><div class="section" data-reactid="5068"><a href="../clj/clojure.core/with-precision.html" data-reactid="5069"><h3 data-reactid="5070">+ Source</h3></a></div></div><div class="var-info" data-reactid="5071"><a href="../clj/clojure.core/with-redefs.html" data-reactid="5072"><h2 data-reactid="5073">(with-redefs bindings &amp; body)</h2></a><div class="section doc" data-reactid="5074">binding =&gt; var-symbol temp-value-expr

  Temporarily redefines Vars while executing the body.  The
  temp-value-exprs will be evaluated and each resulting value will
  replace in parallel the root value of its Var.  After the body is
  executed, the root values of all the Vars will be set back to their
  old values.  These temporary changes will be visible in all threads.
  Useful for mocking out functions during testing.</div><div class="section" data-reactid="5075"><a href="../clj/clojure.core/with-redefs.html" data-reactid="5076"><h3 data-reactid="5077">+ Source</h3></a></div></div><div class="var-info" data-reactid="5078"><a href="../clj/clojure.core/with-redefs-fn.html" data-reactid="5079"><h2 data-reactid="5080">(with-redefs-fn binding-map func)</h2></a><div class="section doc" data-reactid="5081">Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing.</div><div class="section" data-reactid="5082"><a href="../clj/clojure.core/with-redefs-fn.html" data-reactid="5083"><h3 data-reactid="5084">+ Source</h3></a></div></div><div class="var-info" data-reactid="5085"><a href="../clj/clojure.core/xml-seq.html" data-reactid="5086"><h2 data-reactid="5087">(xml-seq root)</h2></a><div class="section doc" data-reactid="5088">A tree seq on the xml elements as per xml/parse</div><div class="section" data-reactid="5089"><a href="../clj/clojure.core/xml-seq.html" data-reactid="5090"><h3 data-reactid="5091">+ Source</h3></a></div></div><div class="var-info" data-reactid="5092"><a href="../clj/clojure.core/zero&#x27;q&#x27;.html" data-reactid="5093"><h2 data-reactid="5094">(zero? num)</h2></a><div class="section doc" data-reactid="5095">Returns true if num is zero, else false</div><div class="section" data-reactid="5096"><a href="../clj/clojure.core/zero&#x27;q&#x27;.html" data-reactid="5097"><h3 data-reactid="5098">+ Source</h3></a></div></div><div class="var-info" data-reactid="5099"><a href="../clj/clojure.core/zipmap.html" data-reactid="5100"><h2 data-reactid="5101">(zipmap keys vals)</h2></a><div class="section doc" data-reactid="5102">Returns a map with the keys mapped to the corresponding vals.</div><div class="section" data-reactid="5103"><a href="../clj/clojure.core/zipmap.html" data-reactid="5104"><h3 data-reactid="5105">+ Source</h3></a></div></div><div class="footer" data-reactid="5106"><!-- react-text: 5107 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="5108">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:type :clj, :ns-sym clojure.core, :static? true, :cljs-nses-and-vars {eval-soup.core ({:sym chan?, :meta {}, :source "(def\n chan?\n (partial instance? cljs.core.async.impl.channels.ManyToManyChannel))\n"} {:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n"}), reagent.impl.util ({:sym merge-props, :meta {:doc nil, :arglists ([p1 p2])}, :source "(defn\n merge-props\n [p1 p2]\n (if\n  (nil? p1)\n  p2\n  (do\n   (assert (map? p1) (str \"Property must be a map, not \" (pr-str p1)))\n   (merge-style p1 (merge-class p1 (merge p1 p2))))))\n"} {:sym capitalize, :meta {:doc nil, :arglists ([s])}, :source "(defn\n capitalize\n [s]\n (if\n  (< (count s) 2)\n  (string/upper-case s)\n  (str (string/upper-case (subs s 0 1)) (subs s 1))))\n"} {:sym dash-to-camel, :meta {:doc nil, :arglists ([dashed])}, :source "(defn\n dash-to-camel\n [dashed]\n (if\n  (string? dashed)\n  dashed\n  (let\n   [name-str\n    (name dashed)\n    [start & parts]\n    (string/split name-str #\"-\")]\n   (if\n    (dont-camel-case start)\n    name-str\n    (apply str start (map capitalize parts))))))\n"} {:sym dont-camel-case, :meta {}, :source "(def dont-camel-case #{\"aria\" \"data\"})\n"} {:sym memoize-1, :meta {:doc nil, :arglists ([f])}, :source "(defn\n memoize-1\n [f]\n (let\n  [mem (atom {})]\n  (fn\n   [arg]\n   (let\n    [v (get @mem arg)]\n    (if-not\n     (nil? v)\n     v\n     (let [ret (f arg)] (swap! mem assoc arg ret) ret))))))\n"} {:sym make-partial-fn, :meta {:doc nil, :arglists ([f args])}, :source "(defn\n make-partial-fn\n [f args]\n (->PartialFn (apply partial f args) f args))\n"} {:sym *non-reactive*, :meta {}, :source "(def *non-reactive* false)\n"} {:sym fun-name, :meta {:doc nil, :arglists ([f])}, :source "(defn\n fun-name\n [f]\n (let\n  [n\n   (or\n    (and (fn? f) (or ($ f :displayName) ($ f :name)))\n    (and (implements? INamed f) (name f))\n    (let [m (meta f)] (if (map? m) (:name m))))]\n  (-> n str (clojure.string/replace \"$\" \".\"))))\n"} {:sym is-client, :meta {}, :source "(def\n is-client\n (and (exists? js/window) (-> js/window ($ :document) nil? not)))\n"} {:sym force-update, :meta {:doc nil, :arglists ([comp deep])}, :source "(defn\n force-update\n [comp deep]\n (if\n  deep\n  (binding [*always-update* true] ($ comp forceUpdate))\n  ($ comp forceUpdate)))\n"} {:sym *always-update*, :meta {}, :source "(def *always-update* false)\n"}), cljs.source-map.base64 ({:sym chars64, :meta {}, :source "(def\n chars64\n \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n"} {:sym char->int, :meta {}, :source "(def char->int (zipmap chars64 (range 0 64)))\n"} {:sym int->char, :meta {}, :source "(def int->char (zipmap (range 0 64) chars64))\n"} {:sym encode, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode\n [n]\n (let\n  [e (find int->char n)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Must be between 0 and 63: \" n))))))\n"} {:sym decode, :meta {:doc nil, :arglists ([c])}, :source "(defn\n decode\n [c]\n (let\n  [e (find char->int c)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Not a valid base 64 digit: \" c))))))\n"}), oakcljs.tools.reader.impl.utils ({:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :source "(defn\n reader-conditional\n \"Construct a data representation of a reader conditional.\\n  If true, splicing? indicates read-cond-splicing.\"\n [form splicing?]\n (ReaderConditional. splicing? form))\n"} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :source "(defn\n whitespace?\n \"Checks whether a given character is whitespace\"\n [ch]\n (when-not (nil? ch) (if (identical? ch \\,) true (.test ws-rx ch))))\n"} {:sym last-id, :meta {}, :source "(def last-id (atom 0))\n"} {:sym char, :meta {:doc nil, :arglists ([x])}, :source "(defn char [x] (when-not (nil? x) (cljs.core/char x)))\n"} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :source "(defn\n numeric?\n \"Checks whether a given character is numeric\"\n [ch]\n (when-not (nil? ch) (gstring/isNumeric ch)))\n"} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :source "(defn second' [[a b]] (when-not a b))\n"} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :source "(defn\n desugar-meta\n \"Resolves syntactical sugar in metadata\"\n [f]\n (cond\n  (keyword? f)\n  {f true}\n  (symbol? f)\n  {:tag f}\n  (string? f)\n  {:tag f}\n  :else\n  f))\n"} {:sym next-id, :meta {:doc nil, :arglists ([])}, :source "(defn next-id [] (swap! last-id inc))\n"} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :source "(defn ex-info? [ex] (instance? cljs.core.ExceptionInfo ex))\n"} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :source "(defn\n reader-conditional?\n \"Return true if the value is the data representation of a reader conditional\"\n [value]\n (instance? ReaderConditional value))\n"} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :source "(defn\n newline?\n \"Checks whether the character is a newline\"\n [c]\n (or (identical? \\newline c) (identical? \"\\n\" c) (nil? c)))\n"} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :source "(defn\n namespace-keys\n [ns keys]\n (for\n  [key keys]\n  (if\n   (or (symbol? key) (keyword? key))\n   (let\n    [[key-ns key-name]\n     ((juxt namespace name) key)\n     ->key\n     (if (symbol? key) symbol keyword)]\n    (cond\n     (nil? key-ns)\n     (->key ns key-name)\n     (= \"_\" key-ns)\n     (->key key-name)\n     :else\n     key))\n   key)))\n"} {:sym ws-rx, :meta {}, :source "(def ws-rx #\"[\\s]\")\n"}), cljs.core.async.impl.channels ({:sym box, :meta {:doc nil, :arglists ([val])}, :source "(defn box [val] (reify cljs.core/IDeref (-deref [_] val)))\n"} {:sym put-active?, :meta {:doc nil, :arglists ([box])}, :source "(defn put-active? [box] (impl/active? (.-handler box)))\n"} {:sym MAX_DIRTY, :meta {}, :source "(def MAX_DIRTY 64)\n"} {:sym abort, :meta {:doc nil, :arglists ([this])}, :protocol MMC} {:sym MMC, :meta {:doc nil}, :methods (abort)} {:sym chan, :meta {:doc nil, :arglists [[buf] [buf xform] [buf xform exh]]}, :source "(defn\n chan\n ([buf] (chan buf nil))\n ([buf xform] (chan buf xform nil))\n ([buf xform exh]\n  (ManyToManyChannel.\n   (buffers/ring-buffer 32)\n   0\n   (buffers/ring-buffer 32)\n   0\n   buf\n   false\n   (let\n    [add! (if xform (xform impl/add!) impl/add!)]\n    (fn\n     ([buf] (try (add! buf) (catch :default t (handle buf exh t))))\n     ([buf val]\n      (try (add! buf val) (catch :default t (handle buf exh t)))))))))\n"}), cljs.core.async.impl.dispatch ({:sym tasks, :meta {}, :source "(def tasks (buffers/ring-buffer 32))\n"} {:sym running?, :meta {}, :source "(def running? false)\n"} {:sym queued?, :meta {}, :source "(def queued? false)\n"} {:sym TASK_BATCH_SIZE, :meta {}, :source "(def TASK_BATCH_SIZE 1024)\n"} {:sym process-messages, :meta {:doc nil, :arglists ([])}, :source "(defn\n process-messages\n []\n (set! running? true)\n (set! queued? false)\n (loop\n  [count 0]\n  (let\n   [m (.pop tasks)]\n   (when-not\n    (nil? m)\n    (m)\n    (when (< count TASK_BATCH_SIZE) (recur (inc count))))))\n (set! running? false)\n (when (> (.-length tasks) 0) (queue-dispatcher)))\n"} {:sym queue-dispatcher, :meta {:doc nil, :arglists ([])}, :source "(defn\n queue-dispatcher\n []\n (when-not\n  (and queued? running?)\n  (set! queued? true)\n  (goog.async.nextTick process-messages)))\n"} {:sym run, :meta {:doc nil, :arglists ([f])}, :source "(defn run [f] (.unbounded-unshift tasks f) (queue-dispatcher))\n"} {:sym queue-delay, :meta {:doc nil, :arglists ([f delay])}, :source "(defn queue-delay [f delay] (js/setTimeout f delay))\n"}), paren-soup.core ({:sym can-undo, :meta {:doc nil, :arglists ([editor])}, :source "(defn can-undo [editor] (can-undo? editor))\n"} {:sym show-error-message!, :meta {:doc "Shows a popup with an error message.", :arglists ([parent-elem event])}, :source "(defn\n show-error-message!\n \"Shows a popup with an error message.\"\n [parent-elem event]\n (let\n  [elem\n   (.-target event)\n   x\n   (.-clientX event)\n   y\n   (.-clientY event)\n   popup\n   (.createElement js/document \"div\")]\n  (set! (.-textContent popup) (-> elem .-dataset .-message))\n  (set! (.-top (.-style popup)) (str y \"px\"))\n  (set! (.-left (.-style popup)) (str x \"px\"))\n  (set! (.-className popup) \"error-text\")\n  (.appendChild parent-elem popup)))\n"} {:sym focused-text, :meta {:doc nil, :arglists ([])}, :source "(defn focused-text [] (some-> (dom/get-focused-form) .-textContent))\n"} {:sym selected-text, :meta {:doc nil, :arglists ([])}, :source "(defn\n selected-text\n []\n (let\n  [s (-> js/window .getSelection .toString)]\n  (when-not (empty? s) s)))\n"} {:sym can-redo?, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym can-redo, :meta {:doc nil, :arglists ([editor])}, :source "(defn can-redo [editor] (can-redo? editor))\n"} {:sym rainbow-delimiters, :meta {:doc "Returns a map of elements and class names.", :arglists [[parent level] [parent level m]]}, :source "(defn\n rainbow-delimiters\n \"Returns a map of elements and class names.\"\n ([parent level]\n  (persistent! (rainbow-delimiters parent level (transient {}))))\n ([parent level m]\n  (reduce\n   (fn\n    [m elem]\n    (let\n     [classes (.-classList elem)]\n     (cond\n      (.contains classes \"delimiter\")\n      (assoc! m elem (str \"rainbow-\" (mod level rainbow-count)))\n      (.contains classes \"collection\")\n      (rainbow-delimiters elem (inc level) m)\n      :else\n      m)))\n   m\n   (-> parent .-children array-seq))))\n"} {:sym up!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh!, :meta {:doc nil, :arglists ([this state])}, :protocol Editor} {:sym undo!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym key-name?, :meta {:doc "Returns true if the supplied key event involves the key(s) described by key-name.", :arglists ([event key-name])}, :source "(defn\n key-name?\n \"Returns true if the supplied key event involves the key(s) described by key-name.\"\n [event key-name]\n (let\n  [code (key-code event)]\n  (case\n   key-name\n   :undo-or-redo\n   (and (or (.-metaKey event) (.-ctrlKey event)) (= code 90))\n   :tab\n   (= code 9)\n   :enter\n   (= code 13)\n   :arrows\n   (contains? #{39 40 38 37} code)\n   :up-arrow\n   (= code 38)\n   :down-arrow\n   (= code 40)\n   :general\n   (not\n    (or\n     (contains? #{0 91 93 17 16 18} code)\n     (.-ctrlKey event)\n     (.-metaKey event)))\n   false)))\n"} {:sym eval, :meta {:doc nil, :arglists ([editor form callback])}, :source "(defn eval [editor form callback] (eval! editor form callback))\n"} {:sym channel?, :meta {}, :source "(def channel? any?)\n"} {:sym create-editor, :meta {:doc nil, :arglists ([paren-soup content events-chan {:keys [history-limit append-limit compiler-fn console-callback disable-clj? edit-history], :or {history-limit 100, append-limit 5000}}])}, :source "(defn\n create-editor\n [paren-soup\n  content\n  events-chan\n  {:keys\n   [history-limit\n    append-limit\n    compiler-fn\n    console-callback\n    disable-clj?\n    edit-history],\n   :or {history-limit 100, append-limit 5000}}]\n (let\n  [clj?\n   (not disable-clj?)\n   editor?\n   (not console-callback)\n   compiler-fn\n   (or compiler-fn (ir/create-compiler-fn))\n   edit-history\n   (doto\n    (or edit-history (mwm/create-edit-history))\n    (swap! assoc :limit history-limit))\n   refresh-instarepl-with-delay!\n   (debounce refresh-instarepl! 300)\n   console-history\n   (console/create-console-history)\n   last-highlight-elem\n   (atom nil)\n   allow-tab?\n   (atom false)]\n  (when-not\n   editor?\n   (set-validator!\n    edit-history\n    (fn\n     [{:keys [current-state states]}]\n     (if-let\n      [state (get states current-state)]\n      (->\n       state\n       :cursor-position\n       first\n       (>= (console/get-console-start console-history)))\n      true))))\n  (reify\n   Editor\n   (undo! [this] (some->> edit-history mwm/undo! (refresh! this)))\n   (redo! [this] (some->> edit-history mwm/redo! (refresh! this)))\n   (can-undo? [this] (mwm/can-undo? edit-history))\n   (can-redo? [this] (mwm/can-redo? edit-history))\n   (update-cursor-position!\n    [this position]\n    (try\n     (mwm/update-cursor-position! edit-history position)\n     (catch\n      js/Error\n      _\n      (when\n       (apply = position)\n       (let\n        [start (console/get-console-start console-history)]\n        (dom/set-cursor-position! content [start start])\n        (mwm/update-cursor-position! edit-history [start start])))))\n    (update-highlight! content last-highlight-elem))\n   (reset-edit-history!\n    [this start]\n    (console/update-console-start! console-history start)\n    (dom/set-cursor-position! content [start start])\n    (let\n     [new-edit-history\n      (mwm/create-edit-history)\n      state\n      {:cursor-position [start start], :text (.-textContent content)}]\n     (update-edit-history! new-edit-history state)\n     (reset! edit-history @new-edit-history)))\n   (append-text!\n    [this text]\n    (let\n     [node\n      (.createTextNode js/document text)\n      _\n      (.appendChild content node)\n      all-text\n      (.-textContent content)\n      char-count\n      (max 0 (- (count all-text) append-limit))\n      new-all-text\n      (subs all-text char-count)\n      char-count\n      (if\n       (.endsWith new-all-text \"\\n\")\n       (dec (count new-all-text))\n       (count new-all-text))]\n     (when\n      (not= all-text new-all-text)\n      (set! (.-textContent content) new-all-text))\n     (reset-edit-history! this char-count)))\n   (enter!\n    [this]\n    (if\n     editor?\n     (.execCommand js/document \"insertHTML\" false \"\\n\")\n     (let\n      [text\n       (trimr (.-textContent content))\n       post-text\n       (subs text (console/get-console-start console-history))]\n      (reset-edit-history! this (count text))\n      (console/update-console-history! console-history post-text)\n      (console-callback post-text))))\n   (up!\n    [this]\n    (when-not\n     editor?\n     (let\n      [text\n       (.-textContent content)\n       pre-text\n       (subs text 0 (console/get-console-start console-history))\n       line\n       (or (console/up! console-history) \"\")\n       state\n       {:cursor-position (dom/get-cursor-position content false),\n        :text (str pre-text line \\newline)}]\n      (->>\n       state\n       (update-edit-history! edit-history)\n       (refresh! this)))))\n   (down!\n    [this]\n    (when-not\n     editor?\n     (let\n      [text\n       (.-textContent content)\n       pre-text\n       (subs text 0 (console/get-console-start console-history))\n       line\n       (or (console/down! console-history) \"\")\n       state\n       {:cursor-position (dom/get-cursor-position content false),\n        :text (str pre-text line \\newline)}]\n      (->>\n       state\n       (update-edit-history! edit-history)\n       (refresh! this)))))\n   (tab! [this] (when editor? (reset! allow-tab? true)))\n   (refresh!\n    [this state]\n    (post-refresh-content!\n     content\n     events-chan\n     (if\n      editor?\n      (refresh-content! content state)\n      (refresh-console-content!\n       content\n       state\n       (console/get-console-start console-history)\n       clj?)))\n    (when\n     editor?\n     (some->\n      (.querySelector paren-soup \".numbers\")\n      (refresh-numbers! (count (re-seq #\"\\n\" (:text state)))))\n     (when\n      clj?\n      (when-let\n       [elem (.querySelector paren-soup \".instarepl\")]\n       (when-not\n        (-> elem .-style .-display (= \"none\"))\n        (refresh-instarepl-with-delay! elem content compiler-fn)))))\n    (update-highlight! content last-highlight-elem))\n   (edit-and-refresh!\n    [this state]\n    (->>\n     state\n     (add-newline)\n     (add-parinfer clj? (console/get-console-start console-history))\n     (update-edit-history! edit-history)\n     (refresh! this)))\n   (initialize!\n    [this]\n    (when\n     editor?\n     (->> (init-state content false false) (edit-and-refresh! this))))\n   (refresh-after-key-event!\n    [this event]\n    (let\n     [tab?\n      (key-name? event :tab)\n      state\n      (init-state content editor? tab?)]\n     (when-not\n      (and tab? (not @allow-tab?))\n      (edit-and-refresh!\n       this\n       (case\n        (key-code event)\n        13\n        (assoc state :indent-type :return)\n        9\n        (assoc\n         state\n         :indent-type\n         (if (.-shiftKey event) :back :forward))\n        (assoc state :indent-type :normal))))\n     (when tab? (reset! allow-tab? false))))\n   (refresh-after-cut-paste!\n    [this]\n    (let\n     [html\n      (.-innerHTML content)\n      insert-newlines?\n      (-> html (.indexOf \"</tr>\") (> 0))\n      crop?\n      (and editor? (not insert-newlines?))]\n     (when\n      insert-newlines?\n      (set! (.-innerHTML content) (replace html \"</tr>\" \\newline)))\n     (edit-and-refresh!\n      this\n      (assoc (init-state content crop? false) :indent-type :normal))))\n   (eval!\n    [this form callback]\n    (compiler-fn\n     [form]\n     (fn* [p1__17514#] (callback (first p1__17514#))))))))\n"} {:sym key-code, :meta {:doc nil, :arglists ([event])}, :source "(defn\n key-code\n [event]\n (let [code (.-keyCode event)] (if (pos? code) code (.-which event))))\n"} {:sym redo!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym post-refresh-content!, :meta {:doc "Does additional work on the content after it is rendered.", :arglists ([content events-chan state])}, :source "(defn\n post-refresh-content!\n \"Does additional work on the content after it is rendered.\"\n [content events-chan state]\n (if-let\n  [crop (:cropped-state state)]\n  (some->\n   (:element crop)\n   (dom/set-cursor-position! (:cursor-position crop)))\n  (dom/set-cursor-position! content (:cursor-position state)))\n (hide-error-messages! (.-parentElement content))\n (doseq\n  [elem (-> content (.querySelectorAll \".error\") array-seq)]\n  (let\n   [show-error-icon!\n    (fn [elem] (set! (.-display (.-style elem)) \"inline-block\"))\n    show-error-icon!\n    (debounce show-error-icon! 1000)]\n   (show-error-icon! elem))\n  (events/listen\n   elem\n   \"mouseenter\"\n   (fn* [p1__17510#] (put! events-chan p1__17510#)))\n  (events/listen\n   elem\n   \"mouseleave\"\n   (fn* [p1__17511#] (put! events-chan p1__17511#))))\n (doseq\n  [[elem class-name] (rainbow-delimiters content -1)]\n  (.add (.-classList elem) class-name)))\n"} {:sym tab!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym transient-map?, :meta {}, :source "(def\n transient-map?\n (fn*\n  [p1__17506#]\n  (or\n   (instance? cljs.core/TransientArrayMap p1__17506#)\n   (instance? cljs.core/TransientHashMap p1__17506#))))\n"} {:sym refresh-content-element!, :meta {:doc "Replaces a single node in the content, and siblings if necessary.", :arglists ([cropped-state])}, :source "(defn\n refresh-content-element!\n \"Replaces a single node in the content, and siblings if necessary.\"\n [cropped-state]\n (let\n  [{:keys [element text]}\n   cropped-state\n   parent\n   (.-parentElement element)\n   last-elem\n   (.-lastChild parent)\n   last-error\n   (loop\n    [current-elem last-elem]\n    (cond\n     (dom/error-node? current-elem)\n     current-elem\n     (or (nil? current-elem) (= element current-elem))\n     nil\n     :else\n     (recur (.-previousSibling current-elem))))\n   last-elem-to-refresh\n   (when\n    last-error\n    (loop\n     [current-elem last-error]\n     (if-let\n      [sibling (.-nextSibling current-elem)]\n      (if (dom/coll-node? sibling) current-elem (recur sibling))\n      current-elem)))\n   old-elems\n   (loop\n    [elems [element] current-elem element]\n    (cond\n     (= last-elem-to-refresh current-elem)\n     elems\n     (or (some? last-elem-to-refresh) (dom/text-node? current-elem))\n     (if-let\n      [sibling (.-nextSibling current-elem)]\n      (recur (conj elems sibling) sibling)\n      elems)\n     :else\n     elems))\n   _\n   (set! (.-textContent element) text)\n   text\n   (join (map (fn* [p1__17512#] (.-textContent p1__17512#)) old-elems))\n   temp-elem\n   (.createElement js/document \"span\")\n   _\n   (set! (.-innerHTML temp-elem) (hs/code->html text))\n   new-elems\n   (doall\n    (for\n     [i (range (-> temp-elem .-childNodes .-length))]\n     (-> temp-elem .-childNodes (.item i))))]\n  (doseq [new-elem new-elems] (.insertBefore parent new-elem element))\n  (doseq [old-elem old-elems] (.removeChild parent old-elem))\n  (assoc cropped-state :element (first new-elems))))\n"} {:sym elem?, :meta {}, :source "(def elem? (fn* [p1__17507#] (instance? js/Element p1__17507#)))\n"} {:sym enter!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym append-text!, :meta {:doc nil, :arglists ([this text])}, :protocol Editor} {:sym line-numbers, :meta {:doc "Adds line numbers to the numbers.", :arglists ([line-count])}, :source "(defn\n line-numbers\n \"Adds line numbers to the numbers.\"\n [line-count]\n (join (for [i (range line-count)] (str \"<div>\" (inc i) \"</div>\"))))\n"} {:sym update-highlight!, :meta {:doc nil, :arglists ([content last-elem])}, :source "(defn\n update-highlight!\n [content last-elem]\n (when-let\n  [elem @last-elem]\n  (set! (.-backgroundColor (.-style elem)) nil)\n  (reset! last-elem nil))\n (when-let\n  [elem (dom/get-focused-form)]\n  (when-let\n   [color\n    (.getPropertyValue\n     (.getComputedStyle js/window (.-firstChild elem))\n     \"color\")]\n   (let\n    [new-color (-> color (replace #\"rgb\\(\" \"\") (replace #\"\\)\" \"\"))]\n    (set!\n     (.-backgroundColor (.-style elem))\n     (str \"rgba(\" new-color \", 0.1)\"))\n    (reset! last-elem elem)))))\n"} {:sym init, :meta {:doc nil, :arglists ([paren-soup opts])}, :source "(defn\n init\n [paren-soup opts]\n (.init js/rangy)\n (let\n  [opts\n   (js->clj opts :keywordize-keys true)\n   content\n   (.querySelector paren-soup \".content\")\n   events-chan\n   (chan)\n   editor\n   (create-editor paren-soup content events-chan opts)]\n  (set! (.-spellcheck paren-soup) false)\n  (when-not\n   content\n   (throw (js/Error. \"Can't find a div with class 'content'\")))\n  (initialize! editor)\n  (add-event-listeners! content events-chan opts)\n  (go\n   (while\n    true\n    (let\n     [event (<! events-chan)]\n     (when-not\n      (some->\n       opts\n       :before-change-callback\n       ((fn* [p1__17519#] (p1__17519# event))))\n      (case\n       (.-type event)\n       \"keydown\"\n       (cond\n        (and\n         (key-name? event :undo-or-redo)\n         (-> opts :disable-undo-redo? not))\n        (if (.-shiftKey event) (redo! editor) (undo! editor))\n        (key-name? event :enter)\n        (enter! editor)\n        (key-name? event :up-arrow)\n        (up! editor)\n        (key-name? event :down-arrow)\n        (down! editor)\n        (key-name? event :tab)\n        (tab! editor))\n       \"keyup\"\n       (cond\n        (key-name? event :arrows)\n        (update-cursor-position!\n         editor\n         (dom/get-cursor-position content false))\n        (key-name? event :general)\n        (refresh-after-key-event! editor event))\n       \"cut\"\n       (refresh-after-cut-paste! editor)\n       \"paste\"\n       (refresh-after-cut-paste! editor)\n       \"mouseup\"\n       (update-cursor-position!\n        editor\n        (dom/get-cursor-position\n         content\n         (some? (:console-callback opts))))\n       \"mouseenter\"\n       (show-error-message! paren-soup event)\n       \"mouseleave\"\n       (hide-error-messages! paren-soup)\n       nil)\n      (some->\n       opts\n       :change-callback\n       ((fn* [p1__17520#] (p1__17520# event))))))))\n  editor))\n"} {:sym can-undo?, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh-content!, :meta {:doc "Refreshes the content.", :arglists ([content state])}, :source "(defn\n refresh-content!\n \"Refreshes the content.\"\n [content state]\n (if-let\n  [crop (:cropped-state state)]\n  (let\n   [crop (refresh-content-element! crop)]\n   (if\n    (not= (:text state) (.-textContent content))\n    (refresh-content! content (dissoc state :cropped-state))\n    (assoc state :cropped-state crop)))\n  (do\n   (set! (.-innerHTML content) (hs/code->html (:text state)))\n   (dissoc state :cropped-state))))\n"} {:sym redo, :meta {:doc nil, :arglists ([editor])}, :source "(defn redo [editor] (redo! editor))\n"} {:sym debounce-function, :meta {:doc nil, :arglists ([f millis])}, :source "(defn debounce-function [f millis] (debounce f millis))\n"} {:sym refresh-instarepl!, :meta {:doc "Refreshes the InstaREPL.", :arglists ([instarepl content compiler-fn])}, :source "(defn\n refresh-instarepl!\n \"Refreshes the InstaREPL.\"\n [instarepl content compiler-fn]\n (let\n  [elems\n   (ir/get-collections content)\n   locations\n   (ir/elems->locations elems (.-offsetTop instarepl))\n   forms\n   (->>\n    elems\n    (map ir/collection->content)\n    (map (fn* [p1__17509#] (replace p1__17509# \\  \" \"))))]\n  (compiler-fn\n   forms\n   (fn\n    [results]\n    (when\n     (.-parentElement instarepl)\n     (set!\n      (.-innerHTML instarepl)\n      (ir/results->html results locations)))))))\n"} {:sym edit-and-refresh!, :meta {:doc nil, :arglists ([this state])}, :protocol Editor} {:sym rainbow-count, :meta {}, :source "(def rainbow-count 5)\n"} {:sym update-cursor-position!, :meta {:doc nil, :arglists ([this position])}, :protocol Editor} {:sym init-state, :meta {:doc "Returns the editor's state. If full-selection? is true, it will try to save\nthe entire selection rather than just the cursor position.", :arglists ([content crop? full-selection?])}, :source "(defn\n init-state\n \"Returns the editor's state. If full-selection? is true, it will try to save\\nthe entire selection rather than just the cursor position.\"\n [content crop? full-selection?]\n (let\n  [selection\n   (.getSelection js/rangy)\n   anchor\n   (.-anchorNode selection)\n   focus\n   (.-focusNode selection)\n   parent\n   (when (and anchor focus) (dom/common-ancestor anchor focus))\n   state\n   {:cursor-position\n    (-> content (dom/get-selection full-selection?) :cursor-position),\n    :text (.-textContent content)}]\n  (if-let\n   [cropped-selection (some-> parent (dom/get-selection false))]\n   (if\n    crop?\n    (assoc\n     state\n     :cropped-state\n     (assoc cropped-selection :text (.-textContent parent)))\n    state)\n   state)))\n"} {:sym eval!, :meta {:doc nil, :arglists ([this form callback])}, :protocol Editor} {:sym add-parinfer-after-console-start, :meta {:doc nil, :arglists ([console-start-num state])}, :source "(defn\n add-parinfer-after-console-start\n [console-start-num state]\n (let\n  [pre-text\n   (subs (:text state) 0 console-start-num)\n   post-text\n   (subs (:text state) console-start-num)\n   cleared-text\n   (str (replace pre-text #\"[^\\r^\\n]\" \" \") post-text)\n   temp-state\n   (assoc state :text cleared-text)\n   temp-state\n   (cp/add-parinfer :both temp-state)\n   new-text\n   (str pre-text (subs (:text temp-state) console-start-num))]\n  (assoc state :text new-text)))\n"} {:sym refresh-numbers!, :meta {:doc "Refreshes the line numbers.", :arglists ([numbers line-count])}, :source "(defn\n refresh-numbers!\n \"Refreshes the line numbers.\"\n [numbers line-count]\n (set! (.-innerHTML numbers) (line-numbers line-count)))\n"} {:sym refresh-after-cut-paste!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym refresh-after-key-event!, :meta {:doc nil, :arglists ([this event])}, :protocol Editor} {:sym add-newline, :meta {:doc nil, :arglists ([{:keys [text], :as state}])}, :source "(defn\n add-newline\n [{:keys [text], :as state}]\n (if-not\n  (= \\newline (last text))\n  (assoc state :text (str text \\newline))\n  state))\n"} {:sym update-edit-history!, :meta {:doc nil, :arglists ([edit-history state])}, :source "(defn\n update-edit-history!\n [edit-history state]\n (try\n  (mwm/update-edit-history! edit-history (dissoc state :cropped-state))\n  state\n  (catch js/Error _ (mwm/get-current-state edit-history))))\n"} {:sym refresh-console-content!, :meta {:doc nil, :arglists ([content state console-start-num clj?])}, :source "(defn\n refresh-console-content!\n [content state console-start-num clj?]\n (set!\n  (.-innerHTML content)\n  (if\n   clj?\n   (let\n    [pre-text\n     (subs (:text state) 0 console-start-num)\n     post-text\n     (subs (:text state) console-start-num)]\n    (str (hs/escape-html-str pre-text) (hs/code->html post-text)))\n   (hs/escape-html-str (:text state))))\n state)\n"} {:sym append-text, :meta {:doc nil, :arglists ([editor text])}, :source "(defn append-text [editor text] (append-text! editor text))\n"} {:sym prevent-default?, :meta {:doc nil, :arglists ([event opts])}, :source "(defn\n prevent-default?\n [event opts]\n (or\n  (key-name? event :undo-or-redo)\n  (key-name? event :tab)\n  (key-name? event :enter)\n  (and\n   (:console-callback opts)\n   (or (key-name? event :up-arrow) (key-name? event :down-arrow)))))\n"} {:sym initialize!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym add-parinfer, :meta {:doc nil, :arglists ([enable? console-start-num state])}, :source "(defn\n add-parinfer\n [enable? console-start-num state]\n (if\n  enable?\n  (let\n   [cropped-state\n    (:cropped-state state)\n    indent-type\n    (:indent-type state)\n    state\n    (cond\n     (pos? console-start-num)\n     (add-parinfer-after-console-start console-start-num state)\n     indent-type\n     (cp/add-indent state)\n     :else\n     (cp/add-parinfer :paren state))]\n   (if\n    (and cropped-state indent-type)\n    (assoc\n     state\n     :cropped-state\n     (merge\n      cropped-state\n      (cp/add-indent (assoc cropped-state :indent-type indent-type))))\n    state))\n  state))\n"} {:sym undo, :meta {:doc nil, :arglists ([editor])}, :source "(defn undo [editor] (undo! editor))\n"} {:sym obj?, :meta {}, :source "(def obj? (fn* [p1__17508#] (instance? js/Object p1__17508#)))\n"} {:sym down!, :meta {:doc nil, :arglists ([this])}, :protocol Editor} {:sym add-event-listeners!, :meta {:doc nil, :arglists ([content events-chan opts])}, :source "(defn\n add-event-listeners!\n [content events-chan opts]\n (doto\n  content\n  (events/removeAll)\n  (events/listen\n   \"keydown\"\n   (fn\n    [e]\n    (when (prevent-default? e opts) (.preventDefault e))\n    (put! events-chan e)))\n  (events/listen\n   \"keyup\"\n   (fn* [p1__17515#] (put! events-chan p1__17515#)))\n  (events/listen\n   \"cut\"\n   (fn* [p1__17516#] (put! events-chan p1__17516#)))\n  (events/listen\n   \"paste\"\n   (fn* [p1__17517#] (put! events-chan p1__17517#)))\n  (events/listen\n   \"mouseup\"\n   (fn* [p1__17518#] (put! events-chan p1__17518#)))))\n"} {:sym reset-edit-history!, :meta {:doc nil, :arglists ([this start])}, :protocol Editor} {:sym hide-error-messages!, :meta {:doc "Hides all error popups.", :arglists ([parent-elem])}, :source "(defn\n hide-error-messages!\n \"Hides all error popups.\"\n [parent-elem]\n (doseq\n  [elem (-> parent-elem (.querySelectorAll \".error-text\") array-seq)]\n  (.removeChild parent-elem elem)))\n"} {:sym Editor, :meta {:doc nil}, :methods (append-text! can-redo? can-undo? down! edit-and-refresh! enter! eval! initialize! redo! refresh! refresh-after-cut-paste! refresh-after-key-event! reset-edit-history! tab! undo! up! update-cursor-position!)}), cljs.tools.reader.impl.commons ({:sym match-number, :meta {:doc nil, :arglists ([s])}, :source "(defn\n match-number\n [s]\n (if\n  (matches? int-pattern s)\n  (match-int s)\n  (if\n   (matches? float-pattern s)\n   (match-float s)\n   (when (matches? ratio-pattern s) (match-ratio s)))))\n"} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :source "(defn\n skip-line\n \"Advances the reader to the end of a line. Returns the reader\"\n [reader]\n (loop [] (when-not (newline? (read-char reader)) (recur)))\n reader)\n"} {:sym int-pattern, :meta {}, :source "(def\n int-pattern\n #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n"} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :source "(defn read-comment [rdr & _] (skip-line rdr))\n"} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :source "(defn\n parse-symbol\n \"Parses a string into a vector of the namespace and symbol\"\n [token]\n (when-not\n  (or\n   (identical? \"\" token)\n   (true? (.test #\":$\" token))\n   (true? (.test #\"^::\" token)))\n  (let\n   [ns-idx\n    (.indexOf token \"/\")\n    ns\n    (when (pos? ns-idx) (subs token 0 ns-idx))]\n   (if-not\n    (nil? ns)\n    (let\n     [ns-idx (inc ns-idx)]\n     (when-not\n      (== ns-idx (count token))\n      (let\n       [sym (subs token ns-idx)]\n       (when\n        (and\n         (not (numeric? (nth sym 0)))\n         (not (identical? \"\" sym))\n         (false? (.test #\":$\" ns))\n         (or (identical? sym \"/\") (== -1 (.indexOf sym \"/\"))))\n        [ns sym]))))\n    (when\n     (or (identical? token \"/\") (== -1 (.indexOf token \"/\")))\n     [nil token])))))\n"} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :source "(defn\n number-literal?\n \"Checks whether the reader is at the start of a number literal\"\n [reader initch]\n (or\n  (numeric? initch)\n  (and\n   (or (identical? \\+ initch) (identical? \\- initch))\n   (numeric? (peek-char reader)))))\n"} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :source "(defn\n read-past\n \"Read until first character that doesn't match pred, returning\\n   char.\"\n [pred rdr]\n (loop [ch (read-char rdr)] (if (pred ch) (recur (read-char rdr)) ch)))\n"} {:sym float-pattern, :meta {}, :source "(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n"} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :source "(defn\n matches?\n [pattern s]\n (let [[match] (re-find pattern s)] (identical? match s)))\n"} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :source "(defn throwing-reader [msg] (fn [rdr & _] (reader-error rdr msg)))\n"} {:sym ratio-pattern, :meta {}, :source "(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n"}), cljs.tools.reader.edn ({:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader] (read {} reader))\n ([{:keys [eof], :as opts} reader]\n  (let\n   [eof-error? (not (contains? opts :eof))]\n   (read reader eof-error? eof opts)))\n ([reader eof-error? eof opts]\n  (try\n   (loop\n    []\n    (let\n     [ch (read-char reader)]\n     (cond\n      (whitespace? ch)\n      (recur)\n      (nil? ch)\n      (if eof-error? (err/throw-eof-error reader nil) eof)\n      (number-literal? reader ch)\n      (read-number reader ch opts)\n      :else\n      (let\n       [f (macros ch)]\n       (if\n        f\n        (let\n         [res (f reader ch opts)]\n         (if (identical? res reader) (recur) res))\n        (read-symbol reader ch))))))\n   (catch\n    js/Error\n    e\n    (if\n     (ex-info? e)\n     (let\n      [d (ex-data e)]\n      (if\n       (= :reader-exception (:type d))\n       (throw e)\n       (throw\n        (ex-info\n         (.-message e)\n         (merge\n          {:type :reader-exception}\n          d\n          (if\n           (indexing-reader? reader)\n           {:line (get-line-number reader),\n            :column (get-column-number reader),\n            :file (get-file-name reader)}))\n         e))))\n     (throw\n      (ex-info\n       (.-message e)\n       (merge\n        {:type :reader-exception}\n        (if\n         (indexing-reader? reader)\n         {:line (get-line-number reader),\n          :column (get-column-number reader),\n          :file (get-file-name reader)}))\n       e)))))))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per clojure.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per clojure.tools.reader.edn/read\"\n ([s] (read-string {:eof nil} s))\n ([opts s]\n  (when (and s (not= s \"\")) (read opts (string-push-back-reader s)))))\n"}), cljs.source-map.base64-vlq ({:sym vlq-base-shift, :meta {}, :source "(def vlq-base-shift 5)\n"} {:sym vlq-base, :meta {}, :source "(def vlq-base (bit-shift-left 1 vlq-base-shift))\n"} {:sym vlq-base-mask, :meta {}, :source "(def vlq-base-mask (dec vlq-base))\n"} {:sym vlq-continuation-bit, :meta {}, :source "(def vlq-continuation-bit vlq-base)\n"} {:sym to-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n to-vlq-signed\n [v]\n (if\n  (neg? v)\n  (inc (bit-shift-left (- v) 1))\n  (+ (bit-shift-left v 1) 0)))\n"} {:sym from-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n from-vlq-signed\n [v]\n (let\n  [neg? (= (bit-and v 1) 1) shifted (bit-shift-right v 1)]\n  (if neg? (- shifted) shifted)))\n"} {:sym encode-val, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode-val\n [n]\n (let\n  [sb (StringBuffer.) vlq (to-vlq-signed n)]\n  (loop\n   [digit\n    (bit-and vlq vlq-base-mask)\n    vlq\n    (bit-shift-right-zero-fill vlq vlq-base-shift)]\n   (if\n    (pos? vlq)\n    (let\n     [digit (bit-or digit vlq-continuation-bit)]\n     (.append sb (base64/encode digit))\n     (recur\n      (bit-and vlq vlq-base-mask)\n      (bit-shift-right-zero-fill vlq vlq-base-shift)))\n    (.append sb (base64/encode digit))))\n  (str sb)))\n"} {:sym encode, :meta {:doc nil, :arglists ([v])}, :source "(defn encode [v] (apply str (map encode-val v)))\n"} {:sym decode, :meta {:doc nil, :arglists ([s])}, :source "(defn\n decode\n [s]\n (let\n  [l (.-length s)]\n  (loop\n   [i 0 result 0 shift 0]\n   (when\n    (>= i l)\n    (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n   (let\n    [digit (base64/decode (.charAt s i))]\n    (let\n     [i\n      (inc i)\n      continuation?\n      (pos? (bit-and digit vlq-continuation-bit))\n      digit\n      (bit-and digit vlq-base-mask)\n      result\n      (+ result (bit-shift-left digit shift))\n      shift\n      (+ shift vlq-base-shift)]\n     (if\n      continuation?\n      (recur i result shift)\n      (lazy-seq\n       (cons\n        (from-vlq-signed result)\n        (let\n         [s (.substring s i)]\n         (when-not (string/blank? s) (decode s)))))))))))\n"}), oakcljs.tools.reader ({:sym bool?, :meta {:doc nil, :arglists ([x])}, :source "(defn bool? [x] (or (instance? js/Boolean x) (true? x) (false? x)))\n"} {:sym *suppress-read*, :meta {}, :source "(def *suppress-read* false)\n"} {:sym *default-data-reader-fn*, :meta {}, :source "(def\n *default-data-reader-fn*\n \"When no data reader is found for a tag and *default-data-reader-fn*\\n  is non-nil, it will be called with two arguments, the tag and the value.\\n  If *default-data-reader-fn* is nil (the default value), an exception\\n  will be thrown for the unknown tag.\"\n (fn [tag value]))\n"} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use oakclojure.tools.reader.edn/read\n\n   Note that the function signature of oakclojure.tools.reader/read and\n   oakclojure.tools.reader.edn/read is not the same for eof-handling", :arglists [[reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true.\\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\\n\\n   Opts is a persistent map with valid keys:\\n    :read-cond - :allow to process reader conditionals, or\\n                 :preserve to keep all branches\\n    :features - persistent set of feature keywords for reader conditionals\\n    :eof - on eof, return value unless :eofthrow, then throw.\\n           if not specified, will throw\\n\\n   To read data structures only, use oakclojure.tools.reader.edn/read\\n\\n   Note that the function signature of oakclojure.tools.reader/read and\\n   oakclojure.tools.reader.edn/read is not the same for eof-handling\"\n {:arglists '([] [reader] [opts reader] [reader eof-error? eof-value])}\n ([reader] (read reader true nil))\n ([{eof :eof, :as opts, :or {eof :eofthrow}} reader]\n  (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n ([reader eof-error? sentinel]\n  (read* reader eof-error? sentinel nil {} (to-array []))))\n"} {:sym default-data-readers, :meta {}, :source "(def\n default-data-readers\n \"Default map of data reader functions provided by Clojure.\\n  May be overridden by binding *data-readers*\"\n {})\n"} {:sym *data-readers*, :meta {}, :source "(def\n *data-readers*\n \"Map from reader tag symbols to data reader Vars.\\n  Reader tags without namespace qualifiers are reserved for Clojure.\\n  This light version of tools.reader has no implementation for default\\n  reader tags such as #inst and #uuid.\"\n {})\n"} {:sym *read-delim*, :meta {}, :source "(def *read-delim* false)\n"} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :source "(defn\n resolve-symbol\n \"Resolve a symbol s into its fully qualified namespace version\"\n [s]\n s)\n"} {:sym *alias-map*, :meta {}, :source "(def\n *alias-map*\n \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\\n   ns aliases.\\n\\n   Defaults to nil\"\n nil)\n"} {:sym *wrap-value-and-add-metadata?*, :meta {}, :source "(def *wrap-value-and-add-metadata?* false)\n"} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :source "(defn\n read-regex\n [rdr ch opts pending-forms]\n (let\n  [sb (StringBuffer.)]\n  (loop\n   [ch (read-char rdr)]\n   (if\n    (identical? \\\" ch)\n    (re-pattern (str sb))\n    (if\n     (nil? ch)\n     (err/throw-eof-reading rdr :regex sb)\n     (do\n      (.append sb ch)\n      (when\n       (identical? \\\\ ch)\n       (let\n        [ch (read-char rdr)]\n        (if (nil? ch) (err/throw-eof-reading rdr :regex sb))\n        (.append sb ch)))\n      (recur (read-char rdr))))))))\n"} {:sym sb, :meta {}, :source "(def sb (StringBuffer.))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use oakclojure.tools.reader.edn/read-string\n\n   Note that the function signature of oakclojure.tools.reader/read-string and\n   oakclojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   To read data structures only, use oakclojure.tools.reader.edn/read-string\\n\\n   Note that the function signature of oakclojure.tools.reader/read-string and\\n   oakclojure.tools.reader.edn/read-string is not the same for eof-handling\"\n ([s] (read-string {} s))\n ([opts s]\n  (when\n   (and s (not (identical? s \"\")))\n   (read opts (string-push-back-reader s)))))\n"} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :source "(defn\n map-func\n \"Decide which map type to use, array-map if less than 16 elements\"\n [coll]\n (if (>= (count coll) 16) 'cljs.core/hash-map 'cljs.core/array-map))\n"}), cljs.tools.reader ({:sym bool?, :meta {:doc nil, :arglists ([x])}, :source "(defn bool? [x] (or (instance? js/Boolean x) (true? x) (false? x)))\n"} {:sym *suppress-read*, :meta {}, :source "(def *suppress-read* false)\n"} {:sym *default-data-reader-fn*, :meta {}, :source "(def\n *default-data-reader-fn*\n \"When no data reader is found for a tag and *default-data-reader-fn*\\n  is non-nil, it will be called with two arguments, the tag and the value.\\n  If *default-data-reader-fn* is nil (the default value), an exception\\n  will be thrown for the unknown tag.\"\n nil)\n"} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling", :arglists [[reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true.\\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\\n\\n   Opts is a persistent map with valid keys:\\n    :read-cond - :allow to process reader conditionals, or\\n                 :preserve to keep all branches\\n    :features - persistent set of feature keywords for reader conditionals\\n    :eof - on eof, return value unless :eofthrow, then throw.\\n           if not specified, will throw\\n\\n   To read data structures only, use clojure.tools.reader.edn/read\\n\\n   Note that the function signature of clojure.tools.reader/read and\\n   clojure.tools.reader.edn/read is not the same for eof-handling\"\n {:arglists '([] [reader] [opts reader] [reader eof-error? eof-value])}\n ([reader] (read reader true nil))\n ([{eof :eof, :as opts, :or {eof :eofthrow}} reader]\n  (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n ([reader eof-error? sentinel]\n  (read* reader eof-error? sentinel nil {} (to-array []))))\n"} {:sym default-data-readers, :meta {}, :source "(def\n default-data-readers\n \"Default map of data reader functions provided by Clojure.\\n  May be overridden by binding *data-readers*\"\n {})\n"} {:sym *data-readers*, :meta {}, :source "(def\n *data-readers*\n \"Map from reader tag symbols to data reader Vars.\\n  Reader tags without namespace qualifiers are reserved for Clojure.\\n  This light version of tools.reader has no implementation for default\\n  reader tags such as #inst and #uuid.\"\n {})\n"} {:sym *read-delim*, :meta {}, :source "(def *read-delim* false)\n"} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :source "(defn\n resolve-symbol\n \"Resolve a symbol s into its fully qualified namespace version\"\n [s]\n (throw (ex-info \"resolve-symbol is not implemented\" {:sym s})))\n"} {:sym *alias-map*, :meta {}, :source "(def\n *alias-map*\n \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\\n   ns aliases.\\n\\n   Defaults to nil\"\n nil)\n"} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :source "(defn\n read-regex\n [rdr ch opts pending-forms]\n (let\n  [sb (StringBuffer.)]\n  (loop\n   [ch (read-char rdr)]\n   (if\n    (identical? \\\" ch)\n    (re-pattern (str sb))\n    (if\n     (nil? ch)\n     (err/throw-eof-reading rdr :regex sb)\n     (do\n      (.append sb ch)\n      (when\n       (identical? \\\\ ch)\n       (let\n        [ch (read-char rdr)]\n        (if (nil? ch) (err/throw-eof-reading rdr :regex sb))\n        (.append sb ch)))\n      (recur (read-char rdr))))))))\n"} {:sym sb, :meta {}, :source "(def sb (StringBuffer.))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   To read data structures only, use clojure.tools.reader.edn/read-string\\n\\n   Note that the function signature of clojure.tools.reader/read-string and\\n   clojure.tools.reader.edn/read-string is not the same for eof-handling\"\n ([s] (read-string {} s))\n ([opts s]\n  (when\n   (and s (not (identical? s \"\")))\n   (read opts (string-push-back-reader s)))))\n"} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :source "(defn\n map-func\n \"Decide which map type to use, array-map if less than 16 elements\"\n [coll]\n (if (>= (count coll) 16) 'cljs.core/hash-map 'cljs.core/array-map))\n"}), paren-soup.dom ({:sym top-level?, :meta {:doc nil, :arglists ([node])}, :source "(defn\n top-level?\n [node]\n (some-> node .-parentElement .-classList (.contains \"content\")))\n"} {:sym get-selection, :meta {:doc "Returns the objects related to selection for the given element. If full-selection? is true,\nit will use rangy instead of the native selection API in order to get the beginning and ending\nof the selection (it is, however, much slower).", :arglists ([element full-selection?])}, :source "(defn\n get-selection\n \"Returns the objects related to selection for the given element. If full-selection? is true,\\nit will use rangy instead of the native selection API in order to get the beginning and ending\\nof the selection (it is, however, much slower).\"\n [element full-selection?]\n {:element element,\n  :cursor-position\n  (cond\n   full-selection?\n   (let\n    [selection\n     (.getSelection js/rangy)\n     ranges\n     (.saveCharacterRanges selection element)]\n    (if-let\n     [char-range (some-> ranges (aget 0) (gobj/get \"characterRange\"))]\n     [(gobj/get char-range \"start\") (gobj/get char-range \"end\")]\n     [0 0]))\n   (= 0 (.-rangeCount (.getSelection js/window)))\n   [0 0]\n   :else\n   (let\n    [selection\n     (.getSelection js/window)\n     range\n     (.getRangeAt selection 0)\n     pre-caret-range\n     (doto\n      (.cloneRange range)\n      (.selectNodeContents element)\n      (.setEnd (.-endContainer range) (.-endOffset range)))\n     pos\n     (-> pre-caret-range .toString .-length)]\n    [pos pos]))})\n"} {:sym get-cursor-position, :meta {:doc "Returns the cursor position.", :arglists ([element full-selection?])}, :source "(defn\n get-cursor-position\n \"Returns the cursor position.\"\n [element full-selection?]\n (-> element (get-selection full-selection?) :cursor-position))\n"} {:sym text-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn text-node? [node] (= 3 (.-nodeType node)))\n"} {:sym get-focused-form, :meta {}, :source "(def get-focused-form (fn* [] (get-focused-elem \"collection\")))\n"} {:sym get-focused-top-level, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-focused-top-level\n []\n (when-let\n  [node (some-> js/rangy .getSelection .-anchorNode)]\n  (loop\n   [node node]\n   (if\n    (top-level? node)\n    node\n    (when-let [parent (.-parentElement node)] (recur parent))))))\n"} {:sym get-parent, :meta {:doc "Returns the nearest parent with the given class name.", :arglists ([node class-name])}, :source "(defn\n get-parent\n \"Returns the nearest parent with the given class name.\"\n [node class-name]\n (loop\n  [node node]\n  (when-let\n   [parent (.-parentElement node)]\n   (if\n    (.contains (.-classList parent) class-name)\n    parent\n    (recur parent)))))\n"} {:sym coll-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn\n coll-node?\n [node]\n (some-> node .-classList (.contains \"collection\")))\n"} {:sym get-nearest-ns, :meta {:doc nil, :arglists ([node])}, :source "(defn\n get-nearest-ns\n [node]\n (loop\n  [node node]\n  (if\n   (some-> node .-childNodes (.item 1) .-textContent (= \"ns\"))\n   (some-> node .-childNodes (.item 3) .-textContent symbol)\n   (when-let [sibling (.-previousSibling node)] (recur sibling)))))\n"} {:sym get-completion-info, :meta {:doc nil, :arglists ([])}, :source "(defn\n get-completion-info\n []\n (when-let\n  [prefix-elem (get-focused-elem \"symbol\")]\n  (let\n   [pos\n    (-> prefix-elem (get-cursor-position false) first)\n    text\n    (.-textContent prefix-elem)\n    prefix\n    (subs text 0 pos)]\n   (assoc\n    (get-completion-context (count text) (count prefix))\n    :text\n    text\n    :prefix\n    prefix))))\n"} {:sym get-focused-elem, :meta {:doc nil, :arglists ([class-name])}, :source "(defn\n get-focused-elem\n [class-name]\n (some-> js/rangy .getSelection .-anchorNode (get-parent class-name)))\n"} {:sym error-node?, :meta {:doc nil, :arglists ([node])}, :source "(defn error-node? [node] (some-> node .-classList (.contains \"error\")))\n"} {:sym get-completion-context, :meta {:doc nil, :arglists ([symbol-length cursor-offset])}, :source "(defn\n get-completion-context\n [symbol-length cursor-offset]\n (when-let\n  [top-level-elem (get-focused-top-level)]\n  (let\n   [pos\n    (-> top-level-elem (get-cursor-position false) first)\n    prefix-start\n    (- pos cursor-offset)\n    text\n    (.-textContent top-level-elem)]\n   {:ns (get-nearest-ns top-level-elem),\n    :context-before (subs text 0 prefix-start),\n    :context-after (subs text (+ prefix-start symbol-length)),\n    :start-position prefix-start})))\n"} {:sym common-ancestor, :meta {:doc "Returns the common ancestor of the given nodes.", :arglists ([first-node second-node])}, :source "(defn\n common-ancestor\n \"Returns the common ancestor of the given nodes.\"\n [first-node second-node]\n (let\n  [first-parent\n   (first (get-parents first-node \"collection\"))\n   second-parent\n   (first (get-parents second-node \"collection\"))]\n  (cond\n   (and first-parent second-parent (= first-parent second-parent))\n   first-parent\n   (and\n    (= first-node second-node)\n    (text-node? first-node)\n    (top-level? first-node))\n   first-node)))\n"} {:sym get-parents, :meta {:doc "Returns all the parents with the given class name.", :arglists ([node class-name])}, :source "(defn\n get-parents\n \"Returns all the parents with the given class name.\"\n [node class-name]\n (loop\n  [node node elems '()]\n  (if-let\n   [parent (get-parent node class-name)]\n   (recur parent (conj elems parent))\n   elems)))\n"} {:sym node?, :meta {}, :source "(def node? (fn* [p1__17503#] (instance? js/Node p1__17503#)))\n"}), reagent.ratom ({:sym make-track, :meta {:doc nil, :arglists ([f args])}, :source "(defn make-track [f args] (Track. f args nil))\n"} {:sym atom, :meta {:doc "Like clojure.core/atom, except that it keeps track of derefs.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Like clojure.core/atom, except that it keeps track of derefs.\"\n ([x] (->RAtom x nil nil nil))\n ([x & {:keys [meta validator]}] (->RAtom x meta validator nil)))\n"} {:sym make-wrapper, :meta {:doc nil, :arglists ([value callback-fn args])}, :source "(defn\n make-wrapper\n [value callback-fn args]\n (->Wrapper value (util/make-partial-fn callback-fn args) false nil))\n"} {:sym IReactiveAtom, :meta {:doc nil}, :methods ()} {:sym track, :meta {:doc nil, :arglists ([f & args])}, :source "(defn track [f & args] {:pre [(ifn? f)]} (make-track f args))\n"} {:sym dispose!, :meta {:doc nil, :arglists ([this])}, :protocol IDisposable} {:sym run, :meta {:doc nil, :arglists ([this])}, :protocol IRunnable} {:sym add-on-dispose!, :meta {:doc nil, :arglists ([this f])}, :protocol IDisposable} {:sym make-track!, :meta {:doc nil, :arglists ([f args])}, :source "(defn\n make-track!\n [f args]\n (let\n  [t\n   (make-track f args)\n   r\n   (make-reaction (fn* [] (-deref t)) :auto-run true)]\n  @r\n  r))\n"} {:sym run-in-reaction, :meta {:doc nil, :arglists ([f obj key run opts])}, :source "(defn\n run-in-reaction\n [f obj key run opts]\n (let\n  [r temp-reaction res (deref-capture f r)]\n  (when-not\n   (nil? (.-watching r))\n   (set! temp-reaction (make-reaction nil))\n   (._set-opts r opts)\n   (set! (.-f r) f)\n   (set! (.-auto-run r) (fn* [] (run obj)))\n   (aset obj key r))\n  res))\n"} {:sym IDisposable, :meta {:doc nil}, :methods (add-on-dispose! dispose!)} {:sym with-let-destroy, :meta {:doc nil, :arglists ([v])}, :source "(defn with-let-destroy [v] (when-some [f (.-destroy v)] (f)))\n"} {:sym make-reaction, :meta {:doc nil, :arglists ([f & {:keys [auto-run on-set on-dispose]}])}, :source "(defn\n make-reaction\n [f & {:keys [auto-run on-set on-dispose]}]\n (let\n  [reaction (->Reaction f nil true false nil nil nil nil)]\n  (._set-opts\n   reaction\n   {:auto-run auto-run, :on-set on-set, :on-dispose on-dispose})\n  reaction))\n"} {:sym flush!, :meta {:doc nil, :arglists ([])}, :source "(defn\n flush!\n []\n (loop\n  []\n  (let\n   [q rea-queue]\n   (when-not\n    (nil? q)\n    (set! rea-queue nil)\n    (dotimes [i (alength q)] (._queued-run (aget q i)))\n    (recur)))))\n"} {:sym debug, :meta {}, :source "(defonce debug false)\n"} {:sym cursor, :meta {:doc nil, :arglists ([src path])}, :source "(defn\n cursor\n [src path]\n (assert\n  (or\n   (satisfies? IReactiveAtom src)\n   (and (ifn? src) (not (vector? src))))\n  (str \"src must be a reactive atom or a function, not \" (pr-str src)))\n (->RCursor src path nil nil nil))\n"} {:sym running, :meta {:doc nil, :arglists ([])}, :source "(defn running [] (+ @-running))\n"} {:sym IRunnable, :meta {:doc nil}, :methods (run)} {:sym reactive?, :meta {:doc nil, :arglists ([])}, :source "(defn reactive? [] (some? *ratom-context*))\n"} {:sym with-let-values, :meta {:doc nil, :arglists ([key])}, :source "(defn\n with-let-values\n [key]\n (if-some\n  [c *ratom-context*]\n  (cached-reaction array c key nil with-let-destroy)\n  (array)))\n"} {:sym track!, :meta {:doc nil, :arglists ([f & args])}, :source "(defn track! [f & args] {:pre [(ifn? f)]} (make-track! f args))\n"} {:sym check-derefs, :meta {:doc nil, :arglists ([f])}, :source "(defn\n check-derefs\n [f]\n (let\n  [ctx (js-obj) res (in-context ctx f)]\n  [res (some? (.-captured ctx))]))\n"}), oakcljs.tools.reader.impl.errors ({:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-dispatch\n [rdr ch]\n (reader-error rdr \"No dispatch macro for \" ch \".\"))\n"} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-escape\n [rdr ch]\n (reader-error rdr \"Invalid unicode escape: \\\\u\" ch \".\"))\n"} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :source "(defn\n throw-dup-keys\n [rdr kind ks]\n (reader-error\n  rdr\n  (duplicate-keys-error\n   (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n   ks)))\n"} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-bad-ns\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Invalid value used as namespace in namespaced map: \"\n  ns-name\n  \".\"))\n"} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-unknown-reader-tag\n [rdr tag]\n (reader-error rdr \"No reader function for tag \" (i/inspect tag) \".\"))\n"} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-at-dispatch\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n"} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :source "(defn\n throw-bad-metadata-target\n [rdr target]\n (reader-error\n  rdr\n  \"Metadata can not be applied to \"\n  (i/inspect target)\n  \". \"\n  \"Metadata can only be applied to IMetas.\"))\n"} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-number\n [rdr token]\n (reader-error rdr \"Invalid number: \" token \".\"))\n"} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n reader-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :reader-error (apply str msgs)))\n"} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-literal\n [rdr token]\n (throw\n  (illegal-arg-error rdr \"Invalid unicode literal: \\\\\" token \".\")))\n"} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-ns-map-no-map\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Namespaced map with namespace \"\n  ns-name\n  \" does not specify a map.\"))\n"} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-unsupported-character\n [rdr token]\n (reader-error rdr \"Unsupported character: \" token \".\"))\n"} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :source "(defn\n throw-feature-not-keyword\n [rdr feature]\n (reader-error\n  rdr\n  \"Feature cannot be \"\n  (i/inspect feature)\n  \" Features must be keywords.\"))\n"} {:sym throw-eof-delimited, :meta {:doc nil, :arglists [[rdr kind column line] [rdr kind line column n]]}, :source "(defn\n throw-eof-delimited\n ([rdr kind column line]\n  (throw-eof-delimited rdr kind line column nil))\n ([rdr kind line column n]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading \"\n   (if n (str \"item \" n \" of \"))\n   (name kind)\n   (if line (str \", starting at line \" line \" and column \" column))\n   \".\")))\n"} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-in-character\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading character.\"))\n"} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :source "(defn\n throw-bad-char\n [rdr kind ch]\n (reader-error\n  rdr\n  \"Invalid character: \"\n  ch\n  \" found while reading \"\n  (name kind)\n  \".\"))\n"} {:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n eof-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :eof (apply str msgs)))\n"} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :source "(defn\n throw-bad-metadata\n [rdr x]\n (reader-error\n  rdr\n  \"Metadata cannot be \"\n  (i/inspect x)\n  \". Metadata must be a Symbol, Keyword, String or Map.\"))\n"} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :source "(defn\n throw-eof-reading\n [rdr kind & start]\n (let\n  [init (case kind :regex \"#\\\"\" :string \\\")]\n  (eof-error\n   rdr\n   \"Unexpected EOF reading \"\n   (name kind)\n   \" starting \"\n   (apply str init start)\n   \".\")))\n"} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :source "(defn\n throw-eof-error\n [rdr line]\n (if\n  line\n  (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n  (eof-error rdr \"EOF while reading.\")))\n"} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n illegal-arg-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :illegal-argument (apply str msgs)))\n"} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-octal-len\n [rdr token]\n (reader-error\n  rdr\n  \"Invalid octal escape sequence in a character literal:\"\n  token\n  \". Octal escape sequences must be 3 or fewer digits.\"))\n"} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-digit\n [rdr ch]\n (illegal-arg-error rdr \"Invalid digit \" ch \" in unicode character.\"))\n"} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :source "(defn\n throw-invalid-unicode-digit-in-token\n [rdr ch token]\n (illegal-arg-error\n  rdr\n  \"Invalid digit \"\n  ch\n  \" in unicode character \\\\\"\n  token\n  \".\"))\n"} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :source "(defn\n throw-invalid-unicode-len\n [rdr actual expected]\n (illegal-arg-error\n  rdr\n  \"Invalid unicode literal. Unicode literals should be \"\n  expected\n  \"characters long.  \"\n  \"value suppled is \"\n  actual\n  \"characters long.\"))\n"} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-single-colon\n [rdr]\n (reader-error rdr \"A single colon is not a valid keyword.\"))\n"} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :source "(defn\n throw-odd-map\n [rdr line col elements]\n (reader-error\n  rdr\n  \"The map literal starting with \"\n  (i/inspect (first elements))\n  (if line (str \" on line \" line \" column \" col))\n  \" contains \"\n  (count elements)\n  \" form(s). Map literals must contain an even number of forms.\"))\n"} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-bad-octal-number\n [rdr]\n (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n"} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-bad-reader-tag\n [rdr tag]\n (reader-error\n  rdr\n  \"Invalid reader tag: \"\n  (i/inspect tag)\n  \". Reader tags must be symbols.\"))\n"} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-unmatch-delimiter\n [rdr ch]\n (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n"} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-character-literal\n [rdr token]\n (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n"} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-char\n [rdr token]\n (reader-error rdr \"Invalid unicode character \\\\\" token \".\"))\n"} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-escape-char\n [rdr ch]\n (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n"} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn throw-no-dispatch [rdr ch] (throw-bad-dispatch rdr ch))\n"} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :source "(defn\n throw-eof-at-start\n [rdr kind]\n (eof-error\n  rdr\n  \"Unexpected EOF while reading start of \"\n  (name kind)\n  \".\"))\n"} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :source "(defn\n throw-invalid\n [rdr kind token]\n (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n"}), reagent.core ({:sym after-render, :meta {:doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just after any queued renders in the next animation\n  frame (and even if no renders actually occur).", :arglists ([f])}, :source "(defn\n after-render\n \"Run f using requestAnimationFrame or equivalent.\\n\\n  f will be called just after any queued renders in the next animation\\n  frame (and even if no renders actually occur).\"\n [f]\n (batch/do-after-render f))\n"} {:sym current-component, :meta {:doc "Returns the current React component (a.k.a this) in a component\n  function.", :arglists ([])}, :source "(defn\n current-component\n \"Returns the current React component (a.k.a this) in a component\\n  function.\"\n []\n comp/*current-component*)\n"} {:sym as-component, :meta {}, :source "(def as-component as-element)\n"} {:sym adapt-react-class, :meta {:doc "Returns an adapter for a native React class, that may be used\n  just like a Reagent component function or class in Hiccup forms.", :arglists [[c opts] [c]]}, :source "(defn\n adapt-react-class\n \"Returns an adapter for a native React class, that may be used\\n  just like a Reagent component function or class in Hiccup forms.\"\n ([c opts] (assert-some c \"Component\") (tmpl/adapt-react-class c opts))\n ([c] (adapt-react-class c {})))\n"} {:sym atom, :meta {:doc "Like clojure.core/atom, except that it keeps track of derefs.\n  Reagent components that derefs one of these are automatically\n  re-rendered.", :arglists [[x] [x & rest]]}, :source "(defn\n atom\n \"Like clojure.core/atom, except that it keeps track of derefs.\\n  Reagent components that derefs one of these are automatically\\n  re-rendered.\"\n ([x] (ratom/atom x))\n ([x & rest] (apply ratom/atom x rest)))\n"} {:sym merge-props, :meta {:doc "Utility function that merges two maps, handling :class and :style\n  specially, like React's transferPropsTo.", :arglists ([defaults props])}, :source "(defn\n merge-props\n \"Utility function that merges two maps, handling :class and :style\\n  specially, like React's transferPropsTo.\"\n [defaults props]\n (util/merge-props defaults props))\n"} {:sym force-update-all, :meta {:doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead.", :arglists ([])}, :source "(defn\n force-update-all\n \"Force re-rendering of all mounted Reagent components. This is\\n  probably only useful in a development environment, when you want to\\n  update components in response to some dynamic changes to code.\\n\\n  Note that force-update-all may not update root components. This\\n  happens if a component 'foo' is mounted with `(render [foo])` (since\\n  functions are passed by value, and not by reference, in\\n  ClojureScript). To get around this you'll have to introduce a layer\\n  of indirection, for example by using `(render [#'foo])` instead.\"\n []\n (ratom/flush!)\n (dom/force-update-all)\n (batch/flush-after-render))\n"} {:sym as-element, :meta {:doc "Turns a vector of Hiccup syntax into a React element. Returns form\n  unchanged if it is not a vector.", :arglists ([form])}, :source "(defn\n as-element\n \"Turns a vector of Hiccup syntax into a React element. Returns form\\n  unchanged if it is not a vector.\"\n [form]\n (tmpl/as-element form))\n"} {:sym rswap!, :meta {:doc "Swaps the value of a to be (apply f current-value-of-atom args).\n\n  rswap! works like swap!, except that recursive calls to rswap! on\n  the same atom are allowed – and it always returns nil.", :arglists ([a f & args])}, :source "(defn\n rswap!\n \"Swaps the value of a to be (apply f current-value-of-atom args).\\n\\n  rswap! works like swap!, except that recursive calls to rswap! on\\n  the same atom are allowed – and it always returns nil.\"\n [a f & args]\n {:pre [(satisfies? IAtom a) (ifn? f)]}\n (if\n  a.rswapping\n  (->\n   (or a.rswapfs (set! a.rswapfs (array)))\n   (.push (fn* [p1__17502#] (apply f p1__17502# args))))\n  (do\n   (set! a.rswapping true)\n   (try\n    (swap!\n     a\n     (fn\n      [state]\n      (loop\n       [s (apply f state args)]\n       (if-some [sf (some-> a.rswapfs .shift)] (recur (sf s)) s))))\n    (finally (set! a.rswapping false)))))\n nil)\n"} {:sym next-tick, :meta {:doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just before components are rendered.", :arglists ([f])}, :source "(defn\n next-tick\n \"Run f using requestAnimationFrame or equivalent.\\n\\n  f will be called just before components are rendered.\"\n [f]\n (batch/do-before-flush f))\n"} {:sym track, :meta {:doc "Takes a function and optional arguments, and returns a derefable\n  containing the output of that function. If the function derefs\n  Reagent atoms (or track, etc), the value will be updated whenever\n  the atom changes.\n\n  In other words, @(track foo bar) will produce the same result\n  as (foo bar), but foo will only be called again when the atoms it\n  depends on changes, and will only trigger updates of components when\n  its result changes.\n\n  track is lazy, i.e the function is only evaluated on deref.", :arglists ([f & args])}, :source "(defn\n track\n \"Takes a function and optional arguments, and returns a derefable\\n  containing the output of that function. If the function derefs\\n  Reagent atoms (or track, etc), the value will be updated whenever\\n  the atom changes.\\n\\n  In other words, @(track foo bar) will produce the same result\\n  as (foo bar), but foo will only be called again when the atoms it\\n  depends on changes, and will only trigger updates of components when\\n  its result changes.\\n\\n  track is lazy, i.e the function is only evaluated on deref.\"\n [f & args]\n {:pre [(ifn? f)]}\n (ratom/make-track f args))\n"} {:sym props, :meta {:doc "Returns the props passed to a component.", :arglists ([this])}, :source "(defn\n props\n \"Returns the props passed to a component.\"\n [this]\n (assert-component this)\n (comp/get-props this))\n"} {:sym dispose!, :meta {:doc "Stop the result of track! from updating.", :arglists ([x])}, :source "(defn\n dispose!\n \"Stop the result of track! from updating.\"\n [x]\n (ratom/dispose! x))\n"} {:sym state-atom, :meta {:doc "Returns an atom containing a components state.", :arglists ([this])}, :source "(defn\n state-atom\n \"Returns an atom containing a components state.\"\n [this]\n (assert-component this)\n (comp/state-atom this))\n"} {:sym flush, :meta {:doc "Render dirty components immediately to the DOM.\n\n  Note that this may not work in event handlers, since React.js does\n  batching of updates there.", :arglists ([])}, :source "(defn\n flush\n \"Render dirty components immediately to the DOM.\\n\\n  Note that this may not work in event handlers, since React.js does\\n  batching of updates there.\"\n []\n (batch/flush))\n"} {:sym children, :meta {:doc "Returns the children passed to a component.", :arglists ([this])}, :source "(defn\n children\n \"Returns the children passed to a component.\"\n [this]\n (assert-component this)\n (comp/get-children this))\n"} {:sym wrap, :meta {:doc "Provide a combination of value and callback, that looks like an atom.\n\n  The first argument can be any value, that will be returned when the\n  result is deref'ed.\n\n  The second argument should be a function, that is called with the\n  optional extra arguments provided to wrap, and the new value of the\n  resulting 'atom'.\n\n  Use for example like this:\n\n  (wrap (:foo @state)\n        swap! state assoc :foo)\n\n  Probably useful only for passing to child components.", :arglists ([value reset-fn & args])}, :source "(defn\n wrap\n \"Provide a combination of value and callback, that looks like an atom.\\n\\n  The first argument can be any value, that will be returned when the\\n  result is deref'ed.\\n\\n  The second argument should be a function, that is called with the\\n  optional extra arguments provided to wrap, and the new value of the\\n  resulting 'atom'.\\n\\n  Use for example like this:\\n\\n  (wrap (:foo @state)\\n        swap! state assoc :foo)\\n\\n  Probably useful only for passing to child components.\"\n [value reset-fn & args]\n (assert-callable reset-fn)\n (ratom/make-wrapper value reset-fn args))\n"} {:sym reactify-component, :meta {:doc "Returns an adapter for a Reagent component, that may be used from\n  React, for example in JSX. A single argument, props, is passed to\n  the component, converted to a map.", :arglists ([c])}, :source "(defn\n reactify-component\n \"Returns an adapter for a Reagent component, that may be used from\\n  React, for example in JSX. A single argument, props, is passed to\\n  the component, converted to a map.\"\n [c]\n (assert-some c \"Component\")\n (comp/reactify-component c))\n"} {:sym unmount-component-at-node, :meta {:doc "Remove a component from the given DOM node.", :arglists ([container])}, :source "(defn\n unmount-component-at-node\n \"Remove a component from the given DOM node.\"\n [container]\n (dom/unmount-component-at-node container))\n"} {:sym render-component, :meta {}, :source "(def render-component render)\n"} {:sym component-path, :meta {:doc nil, :arglists ([c])}, :source "(defn component-path [c] (comp/component-path c))\n"} {:sym cursor, :meta {:doc "Provide a cursor into a Reagent atom.\n\n  Behaves like a Reagent atom but focuses updates and derefs to\n  the specified path within the wrapped Reagent atom. e.g.,\n    (let [c (cursor ra [:nested :content])]\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n      )\n\n  The first parameter can also be a function, that should look\n  something like this:\n\n    (defn set-get\n      ([k] (get-in @state k))\n      ([k v] (swap! state assoc-in k v)))\n\n  The function will be called with one argument – the path passed to\n  cursor – when the cursor is deref'ed, and two arguments (path and\n  new value) when the cursor is modified.\n\n  Given that set-get function, (and that state is a Reagent atom, or\n  another cursor) these cursors are equivalent:\n  (cursor state [:foo]) and (cursor set-get [:foo]).\n\n  Note that a cursor is lazy: its value will not change until it is\n  used. This may be noticed with add-watch.", :arglists [[src path]]}, :source "(defn\n cursor\n \"Provide a cursor into a Reagent atom.\\n\\n  Behaves like a Reagent atom but focuses updates and derefs to\\n  the specified path within the wrapped Reagent atom. e.g.,\\n    (let [c (cursor ra [:nested :content])]\\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\\n      )\\n\\n  The first parameter can also be a function, that should look\\n  something like this:\\n\\n    (defn set-get\\n      ([k] (get-in @state k))\\n      ([k v] (swap! state assoc-in k v)))\\n\\n  The function will be called with one argument – the path passed to\\n  cursor – when the cursor is deref'ed, and two arguments (path and\\n  new value) when the cursor is modified.\\n\\n  Given that set-get function, (and that state is a Reagent atom, or\\n  another cursor) these cursors are equivalent:\\n  (cursor state [:foo]) and (cursor set-get [:foo]).\\n\\n  Note that a cursor is lazy: its value will not change until it is\\n  used. This may be noticed with add-watch.\"\n ([src path] (ratom/cursor src path)))\n"} {:sym state, :meta {:doc "Returns the state of a component, as set with replace-state or set-state.\n  Equivalent to (deref (r/state-atom this))", :arglists ([this])}, :source "(defn\n state\n \"Returns the state of a component, as set with replace-state or set-state.\\n  Equivalent to (deref (r/state-atom this))\"\n [this]\n (assert-component this)\n (deref (state-atom this)))\n"} {:sym dom-node, :meta {:doc "Returns the root DOM node of a mounted component.", :arglists ([this])}, :source "(defn\n dom-node\n \"Returns the root DOM node of a mounted component.\"\n [this]\n (dom/dom-node this))\n"} {:sym track!, :meta {:doc "An eager version of track. The function passed is called\n  immediately, and continues to be called when needed, until stopped\n  with dispose!.", :arglists ([f & args])}, :source "(defn\n track!\n \"An eager version of track. The function passed is called\\n  immediately, and continues to be called when needed, until stopped\\n  with dispose!.\"\n [f & args]\n {:pre [(ifn? f)]}\n (ratom/make-track! f args))\n"} {:sym is-client, :meta {}, :source "(def is-client util/is-client)\n"} {:sym replace-state, :meta {:doc "Set state of a component.\n  Equivalent to (reset! (state-atom this) new-state)", :arglists ([this new-state])}, :source "(defn\n replace-state\n \"Set state of a component.\\n  Equivalent to (reset! (state-atom this) new-state)\"\n [this new-state]\n (assert-component this)\n (assert-new-state new-state)\n (reset! (state-atom this) new-state))\n"} {:sym partial, :meta {:doc "Works just like clojure.core/partial, but the result can be compared with =", :arglists ([f & args])}, :source "(defn\n partial\n \"Works just like clojure.core/partial, but the result can be compared with =\"\n [f & args]\n (util/make-partial-fn f args))\n"} {:sym set-state, :meta {:doc "Merge component state with new-state.\n  Equivalent to (swap! (state-atom this) merge new-state)", :arglists ([this new-state])}, :source "(defn\n set-state\n \"Merge component state with new-state.\\n  Equivalent to (swap! (state-atom this) merge new-state)\"\n [this new-state]\n (assert-component this)\n (assert-new-state new-state)\n (swap! (state-atom this) merge new-state))\n"} {:sym argv, :meta {:doc "Returns the entire Hiccup form passed to the component.", :arglists ([this])}, :source "(defn\n argv\n \"Returns the entire Hiccup form passed to the component.\"\n [this]\n (assert-component this)\n (comp/get-argv this))\n"} {:sym render, :meta {:doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element.\n  The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance.", :arglists [[comp container] [comp container callback]]}, :source "(defn\n render\n \"Render a Reagent component into the DOM. The first argument may be\\n  either a vector (using Reagent's Hiccup syntax), or a React element.\\n  The second argument should be a DOM node.\\n\\n  Optionally takes a callback that is called when the component is in place.\\n\\n  Returns the mounted component instance.\"\n ([comp container] (dom/render comp container))\n ([comp container callback] (dom/render comp container callback)))\n"} {:sym force-update, :meta {:doc "Force a component to re-render immediately.\n\n  If the second argument is true, child components will also be\n  re-rendered, even is their arguments have not changed.", :arglists [[this] [this deep]]}, :source "(defn\n force-update\n \"Force a component to re-render immediately.\\n\\n  If the second argument is true, child components will also be\\n  re-rendered, even is their arguments have not changed.\"\n ([this] (force-update this false))\n ([this deep]\n  (ratom/flush!)\n  (util/force-update this deep)\n  (batch/flush-after-render)))\n"} {:sym create-class, :meta {:doc "Create a component, React style. Should be called with a map,\n  looking like this:\n\n    {:get-initial-state (fn [this])\n     :component-will-receive-props (fn [this new-argv])\n     :should-component-update (fn [this old-argv new-argv])\n     :component-will-mount (fn [this])\n     :component-did-mount (fn [this])\n     :component-will-update (fn [this new-argv])\n     :component-did-update (fn [this old-argv])\n     :component-will-unmount (fn [this])\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\n\n  Everything is optional, except either :reagent-render or :render.", :arglists ([spec])}, :source "(defn\n create-class\n \"Create a component, React style. Should be called with a map,\\n  looking like this:\\n\\n    {:get-initial-state (fn [this])\\n     :component-will-receive-props (fn [this new-argv])\\n     :should-component-update (fn [this old-argv new-argv])\\n     :component-will-mount (fn [this])\\n     :component-did-mount (fn [this])\\n     :component-will-update (fn [this new-argv])\\n     :component-did-update (fn [this old-argv])\\n     :component-will-unmount (fn [this])\\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\\n\\n  Everything is optional, except either :reagent-render or :render.\"\n [spec]\n (comp/create-class spec))\n"} {:sym create-element, :meta {:doc "Create a native React element, by calling React.createElement directly.\n\n  That means the second argument must be a javascript object (or nil), and\n  that any Reagent hiccup forms must be processed with as-element. For example\n  like this:\n\n    (r/create-element \"div\" #js{:className \"foo\"}\n       \"Hi \" (r/as-element [:strong \"world!\"])\n\n  which is equivalent to\n\n    [:div.foo \"Hi\" [:strong \"world!\"]]", :arglists [[type] [type props] [type props child] [type props child & children]]}, :source "(defn\n create-element\n \"Create a native React element, by calling React.createElement directly.\\n\\n  That means the second argument must be a javascript object (or nil), and\\n  that any Reagent hiccup forms must be processed with as-element. For example\\n  like this:\\n\\n    (r/create-element \\\"div\\\" #js{:className \\\"foo\\\"}\\n       \\\"Hi \\\" (r/as-element [:strong \\\"world!\\\"])\\n\\n  which is equivalent to\\n\\n    [:div.foo \\\"Hi\\\" [:strong \\\"world!\\\"]]\"\n ([type] (create-element type nil))\n ([type props]\n  (assert-js-object props)\n  (react/createElement type props))\n ([type props child]\n  (assert-js-object props)\n  (react/createElement type props child))\n ([type props child & children]\n  (assert-js-object props)\n  (apply react/createElement type props child children)))\n"}), dynadoc.core ({:sym add-focus, :meta {:doc nil, :arglists ([form with-focus body])}, :source "(defn\n add-focus\n [form with-focus body]\n (if-let\n  [binding (with-focus->binding with-focus)]\n  (postwalk (fn [x] (if (= x binding) form x)) body)\n  form))\n"} {:sym clj-compiler-fn, :meta {:doc nil, :arglists ([example forms cb])}, :source "(defn\n clj-compiler-fn\n [example forms cb]\n (try\n  (.send\n   XhrIo\n   \"/eval\"\n   (fn\n    [e]\n    (if\n     (.isSuccess (.-target e))\n     (->>\n      (.. e -target getResponseText)\n      read-string\n      rest\n      (mapv\n       (fn*\n        [p1__17597#]\n        (if (vector? p1__17597#) (into-array p1__17597#) p1__17597#)))\n      cb)\n     (cb [])))\n   \"POST\"\n   (pr-str\n    (into\n     [(str \"(in-ns '\" (:ns-sym @*state) \")\")]\n     (mapv (partial transform (dissoc example :with-card)) forms))))\n  (catch js/Error _ (cb []))))\n"} {:sym version, :meta {}, :source "(def version \"1.4.0\")\n"} {:sym form->serializable, :meta {:doc "Converts the input to either a string or (if an error object) an array of data", :arglists ([form])}, :source "(defn\n form->serializable\n \"Converts the input to either a string or (if an error object) an array of data\"\n [form]\n (if\n  (instance? js/Error form)\n  (array\n   (or (some-> form .-cause .-message) (.-message form))\n   (.-fileName form)\n   (.-lineNumber form))\n  (pr-str form)))\n"} {:sym init-editor, :meta {:doc nil, :arglists ([elem])}, :source "(defn\n init-editor\n [elem]\n (when-let\n  [paren-soup (or (.querySelector elem \".paren-soup\") elem)]\n  (ps/init paren-soup (js->clj {:compiler-fn (fn [])}))))\n"} {:sym add-callback, :meta {:doc nil, :arglists ([form with-callback])}, :source "(defn\n add-callback\n [form with-callback]\n (list\n  'let\n  ['es-channel\n   '(dynadoc.aliases/chan)\n   with-callback\n   '(fn [data] (dynadoc.aliases/put! es-channel data))]\n  form\n  '(dynadoc.aliases/<!! es-channel)))\n"} {:sym cljs-compiler-fn, :meta {:doc nil, :arglists ([example forms cb])}, :source "(defn\n cljs-compiler-fn\n [example forms cb]\n (es/code->results\n  (into\n   [(str \"(ns \" (:ns-sym @*state) \")\")]\n   (mapv (partial transform example) forms))\n  (fn [results] (->> results rest (mapv form->serializable) cb))\n  {:custom-load (fn [opts cb] (cb {:lang :clj, :source \"\"}))}))\n"} {:sym transform, :meta {:doc nil, :arglists ([{:keys [body id with-focus with-card with-callback]} form-str])}, :source "(defn\n transform\n [{:keys [body id with-focus with-card with-callback]} form-str]\n (if\n  (or with-focus with-card with-callback)\n  (pr-str\n   (cond->\n    (read-string form-str)\n    (some? with-focus)\n    (add-focus with-focus body)\n    (some? with-card)\n    (add-card with-card id)\n    (some? with-callback)\n    (add-callback with-callback)))\n  form-str))\n"} {:sym init, :meta {:doc nil, :arglists ([])}, :source "(defn\n init\n []\n (swap!\n  *state\n  merge\n  (->\n   (.querySelector js/document \"#initial-state\")\n   .-textContent\n   read-string))\n (rum/mount (common/app *state) (.querySelector js/document \"#app\"))\n (let\n  [{:keys [static? dev? watcher]} @*state]\n  (when (and (not static?) (not dev?)) (check-version))\n  (swap!\n   *state\n   assoc\n   :cljs-started?\n   true\n   :exportable?\n   js/COMPILED\n   :init-editor\n   init-editor\n   :init-example-editor\n   init-example-editor\n   :watcher\n   (when-not js/COMPILED (or watcher (init-watcher!)))))\n (when\n  (:var-sym @*state)\n  (doseq\n   [button (-> js/document (.querySelectorAll \".button\") array-seq)]\n   (set! (.-display (.-style button)) \"inline-block\"))))\n"} {:sym add-card, :meta {:doc nil, :arglists ([form with-card id])}, :source "(defn\n add-card\n [form with-card id]\n (list 'let [with-card (list '.getElementById 'js/document id)] form))\n"} {:sym prod, :meta {:doc nil, :arglists ([])}, :source "(defn prod [] (swap! *state assoc :prod? true))\n"} {:sym check-version, :meta {:doc nil, :arglists ([])}, :source "(defn\n check-version\n []\n (.send\n  XhrIo\n  api-url\n  (fn\n   [e]\n   (when\n    (and\n     (.isSuccess (.-target e))\n     (->>\n      (.. e -target getResponseText)\n      (.parse js/JSON)\n      ((fn* [p1__17598#] (gobj/get p1__17598# \"latest_release\")))\n      (not= version)))\n    (swap! *state assoc :update? true)))\n  \"GET\"))\n"} {:sym api-url, :meta {}, :source "(def api-url \"https://clojars.org/api/artifacts/dynadoc\")\n"} {:sym with-focus->binding, :meta {:doc nil, :arglists ([with-focus])}, :source "(defn\n with-focus->binding\n [with-focus]\n (let\n  [{:keys [binding]} with-focus [binding-type binding-val] binding]\n  (when (= :sym binding-type) binding-val)))\n"} {:sym init-example-editor, :meta {:doc nil, :arglists ([elem example])}, :source "(defn\n init-example-editor\n [elem example]\n (when-let\n  [paren-soup (or (.querySelector elem \".paren-soup\") elem)]\n  (when-let\n   [content (.querySelector paren-soup \".content\")]\n   (set! (.-contentEditable content) true))\n  (ps/init\n   paren-soup\n   (js->clj\n    {:compiler-fn\n     (if\n      (= :clj (:type @*state))\n      (partial clj-compiler-fn example)\n      (partial cljs-compiler-fn example))}))))\n"} {:sym init-watcher!, :meta {:doc nil, :arglists ([])}, :source "(defn\n init-watcher!\n []\n (let\n  [protocol\n   (if (= (.-protocol js/location) \"https:\") \"wss:\" \"ws:\")\n   host\n   (-> js/window .-location .-host)\n   sock\n   (js/WebSocket. (str protocol \"//\" host \"/watch\"))]\n  (set!\n   (.-onopen sock)\n   (fn [event] (.send sock js/window.location.pathname)))\n  (set!\n   (.-onmessage sock)\n   (fn [event] (->> (.-data event) read-string (swap! *state merge))))\n  sock))\n"}), cljs.tools.reader.impl.errors ({:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-dispatch\n [rdr ch]\n (reader-error rdr \"No dispatch macro for \" ch \".\"))\n"} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-escape\n [rdr ch]\n (reader-error rdr \"Invalid unicode escape: \\\\u\" ch \".\"))\n"} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :source "(defn\n throw-dup-keys\n [rdr kind ks]\n (reader-error\n  rdr\n  (duplicate-keys-error\n   (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n   ks)))\n"} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-bad-ns\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Invalid value used as namespace in namespaced map: \"\n  ns-name\n  \".\"))\n"} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-unknown-reader-tag\n [rdr tag]\n (reader-error rdr \"No reader function for tag \" (i/inspect tag) \".\"))\n"} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-at-dispatch\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n"} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :source "(defn\n throw-bad-metadata-target\n [rdr target]\n (reader-error\n  rdr\n  \"Metadata can not be applied to \"\n  (i/inspect target)\n  \". \"\n  \"Metadata can only be applied to IMetas.\"))\n"} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-number\n [rdr token]\n (reader-error rdr \"Invalid number: \" token \".\"))\n"} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n reader-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :reader-error (apply str msgs)))\n"} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-literal\n [rdr token]\n (throw\n  (illegal-arg-error rdr \"Invalid unicode literal: \\\\\" token \".\")))\n"} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-ns-map-no-map\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Namespaced map with namespace \"\n  ns-name\n  \" does not specify a map.\"))\n"} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-unsupported-character\n [rdr token]\n (reader-error rdr \"Unsupported character: \" token \".\"))\n"} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :source "(defn\n throw-feature-not-keyword\n [rdr feature]\n (reader-error\n  rdr\n  \"Feature cannot be \"\n  (i/inspect feature)\n  \" Features must be keywords.\"))\n"} {:sym throw-eof-delimited, :meta {:doc nil, :arglists [[rdr kind column line] [rdr kind line column n]]}, :source "(defn\n throw-eof-delimited\n ([rdr kind column line]\n  (throw-eof-delimited rdr kind line column nil))\n ([rdr kind line column n]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading \"\n   (if n (str \"item \" n \" of \"))\n   (name kind)\n   (if line (str \", starting at line \" line \" and column \" column))\n   \".\")))\n"} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-in-character\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading character.\"))\n"} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :source "(defn\n throw-bad-char\n [rdr kind ch]\n (reader-error\n  rdr\n  \"Invalid character: \"\n  ch\n  \" found while reading \"\n  (name kind)\n  \".\"))\n"} {:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n eof-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :eof (apply str msgs)))\n"} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :source "(defn\n throw-bad-metadata\n [rdr x]\n (reader-error\n  rdr\n  \"Metadata cannot be \"\n  (i/inspect x)\n  \". Metadata must be a Symbol, Keyword, String or Map.\"))\n"} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :source "(defn\n throw-eof-reading\n [rdr kind & start]\n (let\n  [init (case kind :regex \"#\\\"\" :string \\\")]\n  (eof-error\n   rdr\n   \"Unexpected EOF reading \"\n   (name kind)\n   \" starting \"\n   (apply str init start)\n   \".\")))\n"} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :source "(defn\n throw-eof-error\n [rdr line]\n (if\n  line\n  (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n  (eof-error rdr \"EOF while reading.\")))\n"} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n illegal-arg-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :illegal-argument (apply str msgs)))\n"} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-octal-len\n [rdr token]\n (reader-error\n  rdr\n  \"Invalid octal escape sequence in a character literal:\"\n  token\n  \". Octal escape sequences must be 3 or fewer digits.\"))\n"} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-digit\n [rdr ch]\n (illegal-arg-error rdr \"Invalid digit \" ch \" in unicode character.\"))\n"} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :source "(defn\n throw-invalid-unicode-digit-in-token\n [rdr ch token]\n (illegal-arg-error\n  rdr\n  \"Invalid digit \"\n  ch\n  \" in unicode character \\\\\"\n  token\n  \".\"))\n"} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :source "(defn\n throw-invalid-unicode-len\n [rdr actual expected]\n (illegal-arg-error\n  rdr\n  \"Invalid unicode literal. Unicode literals should be \"\n  expected\n  \"characters long.  \"\n  \"value suppled is \"\n  actual\n  \"characters long.\"))\n"} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-single-colon\n [rdr]\n (reader-error rdr \"A single colon is not a valid keyword.\"))\n"} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :source "(defn\n throw-odd-map\n [rdr line col elements]\n (reader-error\n  rdr\n  \"The map literal starting with \"\n  (i/inspect (first elements))\n  (if line (str \" on line \" line \" column \" col))\n  \" contains \"\n  (count elements)\n  \" form(s). Map literals must contain an even number of forms.\"))\n"} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-bad-octal-number\n [rdr]\n (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n"} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-bad-reader-tag\n [rdr tag]\n (reader-error\n  rdr\n  \"Invalid reader tag: \"\n  (i/inspect tag)\n  \". Reader tags must be symbols.\"))\n"} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-unmatch-delimiter\n [rdr ch]\n (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n"} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-character-literal\n [rdr token]\n (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n"} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-char\n [rdr token]\n (reader-error rdr \"Invalid unicode character \\\\\" token \".\"))\n"} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-escape-char\n [rdr ch]\n (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n"} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn throw-no-dispatch [rdr ch] (throw-bad-dispatch rdr ch))\n"} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :source "(defn\n throw-eof-at-start\n [rdr kind]\n (eof-error\n  rdr\n  \"Unexpected EOF while reading start of \"\n  (name kind)\n  \".\"))\n"} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :source "(defn\n throw-invalid\n [rdr kind token]\n (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n"}), cljs.js ({:sym *load-fn*, :meta {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil."}, :source "(defonce *load-fn* (fn [m cb] (throw (js/Error. \"No *load-fn* set\"))))\n"} {:sym eval, :meta {:doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :arglists [[state form cb] [state form opts cb]]}, :source "(defn\n eval\n \"Evaluate a single ClojureScript form. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   form (s-expr)\\n     the ClojureScript source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the result of evalution. If unsuccessful the map will\\n     contain a key :error with an ex-info instance describing the cause of\\n     failure.\"\n ([state form cb] (eval state form nil cb))\n ([state form opts cb]\n  (eval*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   form\n   opts\n   cb)))\n"} {:sym compile-str, :meta {:doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n compile-str\n \"Compile ClojureScript source into JavaScript. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the compilation result (string). If unsuccessful the map\\n     will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (compile-str state source nil cb))\n ([state source name cb] (compile-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (compile-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*),\n    :*sm-data* (when (:source-map opts) (sm-data))}\n   source\n   name\n   opts\n   cb)))\n"} {:sym ns->relpath, :meta {:doc "Given a namespace as a symbol return the relative path sans extension", :arglists ([ns-sym])}, :source "(defn\n ns->relpath\n \"Given a namespace as a symbol return the relative path sans extension\"\n [ns-sym]\n (string/replace (ana/munge-path ns-sym) \\. \\/))\n"} {:sym *loaded*, :meta {}, :source "(def *loaded* (atom #{}))\n"} {:sym require, :meta {:doc nil, :arglists [[name cb] [name opts cb] [bound-vars name opts cb] [bound-vars name reload opts cb]]}, :source "(defn\n require\n ([name cb] (require name nil cb))\n ([name opts cb] (require nil name opts cb))\n ([bound-vars name opts cb] (require bound-vars name nil opts cb))\n ([bound-vars name reload opts cb]\n  (let\n   [bound-vars\n    (merge\n     {:*compiler* (env/default-compiler-env),\n      :*data-readers* tags/*cljs-data-readers*,\n      :*load-macros* (:load-macros opts true),\n      :*analyze-deps* (:analyze-deps opts true),\n      :*load-fn* (or (:load opts) *load-fn*),\n      :*eval-fn* (or (:eval opts) *eval-fn*)}\n     bound-vars)\n    aname\n    (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n   (when (= :reload reload) (swap! *loaded* disj aname))\n   (when (= :reload-all reload) (reset! *loaded* #{}))\n   (when\n    (:verbose opts)\n    (debug-prn\n     (str\n      \"Loading \"\n      name\n      (when (:macros-ns opts) \" macros\")\n      \" namespace\")))\n   (if-not\n    (contains? @*loaded* aname)\n    (let\n     [env (:*env* bound-vars)]\n     (try\n      ((:*load-fn* bound-vars)\n       {:name name,\n        :macros (:macros-ns opts),\n        :path (ns->relpath name)}\n       (fn\n        [resource]\n        (assert\n         (or (map? resource) (nil? resource))\n         \"*load-fn* may only return a map or nil\")\n        (if\n         resource\n         (let\n          [{:keys [lang source cache source-map file]} resource]\n          (condp\n           keyword-identical?\n           lang\n           :clj\n           (do\n            (pre-file-side-effects\n             (:*compiler* bound-vars)\n             aname\n             file\n             opts)\n            (eval-str*\n             bound-vars\n             source\n             name\n             (assoc opts :cljs-file file)\n             (fn\n              [res]\n              (post-file-side-effects file opts)\n              (if\n               (:error res)\n               (cb res)\n               (do (swap! *loaded* conj aname) (cb {:value true}))))))\n           :js\n           (process-macros-deps\n            bound-vars\n            cache\n            opts\n            (fn\n             [res]\n             (if\n              (:error res)\n              (cb res)\n              (process-libs-deps\n               bound-vars\n               cache\n               opts\n               (fn\n                [res]\n                (if\n                 (:error res)\n                 (cb res)\n                 (let\n                  [res\n                   (try\n                    ((:*eval-fn* bound-vars) resource)\n                    (when\n                     cache\n                     (load-analysis-cache!\n                      (:*compiler* bound-vars)\n                      aname\n                      cache)\n                     (ana/register-specs cache))\n                    (when\n                     source-map\n                     (load-source-map!\n                      (:*compiler* bound-vars)\n                      aname\n                      source-map))\n                    (catch\n                     :default\n                     cause\n                     (wrap-error\n                      (ana/error\n                       env\n                       (str \"Could not require \" name)\n                       cause))))]\n                  (if\n                   (:error res)\n                   (cb res)\n                   (do\n                    (swap! *loaded* conj aname)\n                    (cb {:value true}))))))))))\n           (cb\n            (wrap-error\n             (ana/error\n              env\n              (str\n               \"Invalid :lang specified \"\n               lang\n               \", only :clj or :js allowed\"))))))\n         (cb\n          (wrap-error\n           (ana/error\n            env\n            (ana/error-message\n             (if\n              (:macros-ns opts)\n              :undeclared-macros-ns\n              :undeclared-ns)\n             {:ns-sym name, :js-provide (cljs.core/name name)})))))))\n      (catch\n       :default\n       cause\n       (cb\n        (wrap-error\n         (ana/error env (str \"Could not require \" name) cause))))))\n    (cb {:value true})))))\n"} {:sym file->ns, :meta {:doc nil, :arglists ([file])}, :source "(defn\n file->ns\n [file]\n (let\n  [lib-name (subs (string/replace file \"/\" \".\") 0 (- (count file) 5))]\n  (symbol (demunge lib-name))))\n"} {:sym eval-str, :meta {:doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n eval-str\n \"Evalute ClojureScript source given as a string. The parameters:\\n\\n  state (atom)\\n    the compiler state\\n\\n  source (string)\\n    the ClojureScript source\\n\\n  name (symbol or string)\\n    optional, the name of the source\\n\\n  opts (map)\\n    compilation options.\\n\\n    :eval             - eval function to invoke, see *eval-fn*\\n    :load             - library resolution function, see *load-fn*\\n    :source-map       - set to true to generate inline source map information\\n    :cache-source     - optional, a function to run side-effects with the\\n                        compilation result prior to actual evalution. This function\\n                        takes two arguments, the first is the eval map, the source\\n                        will be under :source. The second argument is a callback of\\n                        one argument. If an error occurs an :error key should be\\n                        supplied.\\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                        (if set to true) or the def init value (if false). Default\\n                        is false.\\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                        to aget/aset. Logs for incorrect values if :warn, throws if\\n                        :error. Defaults to false.\\n    :static-fns       - employ static dispatch to specific function arities in\\n                        emitted JavaScript, as opposed to making use of the\\n                        `call` construct. Defaults to false.\\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                        unknown functions, but instead direct invokes via\\n                        `f(a0,a1...)`. Defaults to `false`.\\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                        at the moment.\\n    :ns               - optional, the namespace in which to evaluate the source.\\n    :verbose          - optional, emit details from compiler activity. Defaults to\\n                        false.\\n    :context          - optional, sets the context for the source. Possible values\\n                     are `:expr`, `:statement` and `:return`. Defaults to\\n                      `:expr`.\\n\\n  cb (function)\\n    callback, will be invoked with a map. If succesful the map will contain\\n    a :value key with the result of evaluation and :ns the current namespace.\\n    If unsuccessful will contain a :error key with an ex-info instance describing\\n    the cause of failure.\"\n ([state source cb] (eval-str state source nil cb))\n ([state source name cb] (eval-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (eval-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym js-eval, :meta {:doc "A default JavaScript evaluation function.", :arglists ([{:keys [source], :as resource}])}, :source "(defn\n js-eval\n \"A default JavaScript evaluation function.\"\n [{:keys [source], :as resource}]\n (js/eval source))\n"} {:sym load-source-map!, :meta {:doc nil, :arglists ([state ns sm-json])}, :source "(defn\n load-source-map!\n [state ns sm-json]\n (let\n  [sm (sm/decode (.parse js/JSON sm-json))]\n  (swap! state assoc-in [:source-maps ns] sm)))\n"} {:sym analyze-str, :meta {:doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n analyze-str\n \"Analyze ClojureScript source. The compiler state will be populated with\\n   the results of analyzes. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false).\\n                          Defaults to false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value, the actual value is not meaningful. If unsuccessful the\\n     map will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (analyze-str state source nil cb))\n ([state source name cb] (analyze-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (analyze-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*passes* (or (:passes opts) ana/*passes*),\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym *eval-fn*, :meta {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value."}, :source "(defonce *eval-fn* (fn [m] (throw (js/Error. \"No *eval-fn* set\"))))\n"}), rum.core ({:sym state, :meta {:doc "Given React component, returns Rum state associated with it", :arglists ([comp])}, :source "(defn\n state\n \"Given React component, returns Rum state associated with it\"\n [comp]\n (aget (.-state comp) \":rum/state\"))\n"} {:sym build-defcs, :meta {:doc nil, :arglists ([render-body mixins display-name])}, :source "(defn\n build-defcs\n [render-body mixins display-name]\n (let\n  [render\n   (fn [state] [(apply render-body state (:rum/args state)) state])]\n  (build-ctor render mixins display-name)))\n"} {:sym build-defcc, :meta {:doc nil, :arglists ([render-body mixins display-name])}, :source "(defn\n build-defcc\n [render-body mixins display-name]\n (let\n  [render\n   (fn\n    [state]\n    [(apply render-body (:rum/react-component state) (:rum/args state))\n     state])]\n  (build-ctor render mixins display-name)))\n"} {:sym request-render, :meta {:doc "Schedules react component to be rendered on next animation frame", :arglists ([component])}, :source "(defn\n request-render\n \"Schedules react component to be rendered on next animation frame\"\n [component]\n (when (empty? @render-queue) (schedule render))\n (vswap! render-queue conj component))\n"} {:sym mount, :meta {:doc "Add component to the DOM tree. Idempotent. Subsequent mounts will just update component", :arglists ([component node])}, :source "(defn\n mount\n \"Add component to the DOM tree. Idempotent. Subsequent mounts will just update component\"\n [component node]\n (js/ReactDOM.render component node)\n nil)\n"} {:sym unmount, :meta {:doc "Removes component from the DOM tree", :arglists ([node])}, :source "(defn\n unmount\n \"Removes component from the DOM tree\"\n [node]\n (js/ReactDOM.unmountComponentAtNode node))\n"}), cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n", :examples [{:doc "Sort using a specific keyword", :body (sort-by :year < [{:name "Lisp", :year 1959} {:name "Fortran", :year 1957} {:name "Smalltalk", :year 1972}]), :body-str "(sort-by\n :year\n <\n [{:name \"Lisp\", :year 1959}\n  {:name \"Fortran\", :year 1957}\n  {:name \"Smalltalk\", :year 1972}])\n", :id "cljs.core/sort-by/0"} {:doc "Sort numbers lexicographically", :body (sort-by (fn* [p1__17599#] (.toString p1__17599#)) [5 18 83 23 40]), :body-str "(sort-by (fn* [p1__17599#] (.toString p1__17599#)) [5 18 83 23 40])\n", :id "cljs.core/sort-by/1"}]} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__17592#] (apply f p1__17592#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym take-while, :examples [{:body (do ["Get all the negative numbers up to the first non-negative"] (take-while neg? [-2 -1 0 -1 -2 3])), :body-str "(do\n [\"Get all the negative numbers up to the first non-negative\"]\n (take-while neg? [-2 -1 0 -1 -2 3]))\n", :id "cljs.core/take-while/0"}]} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n", :examples [{:doc "Add a name to a vector", :body (conj ["Alice" "Bob"] "Charlie"), :body-str "(conj [\"Alice\" \"Bob\"] \"Charlie\")\n", :id "cljs.core/conj/0"} {:doc "Add a number to a list", :body (conj (quote (2 3)) 1), :body-str "(conj '(2 3) 1)\n", :id "cljs.core/conj/1"} {:doc "Add a key-val pair to a hash map", :body (conj {:name "Alice"} [:age 30]), :body-str "(conj {:name \"Alice\"} [:age 30])\n", :id "cljs.core/conj/2"}]} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n", :examples [{:doc "Combine two seqs of unequal length", :body (interleave (repeat "a") [1 2 3]), :body-str "(interleave (repeat \"a\") [1 2 3])\n", :id "cljs.core/interleave/0"} {:doc "Create a map using two vectors", :body (apply assoc {} (interleave [:fruit :color :temp] ["grape" "red" "hot"])), :body-str "(apply\n assoc\n {}\n (interleave [:fruit :color :temp] [\"grape\" \"red\" \"hot\"]))\n", :id "cljs.core/interleave/1"}]} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__17593#] (not (sequential? p1__17593#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__17580#] (and (p1 p1__17580#) (p2 p1__17580#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__17581#]\n        (and (p1 p1__17581#) (p2 p1__17581#) (p3 p1__17581#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__17582#] (p1__17582# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__17583#] (and (p1__17583# x) (p1__17583# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__17584#]\n       (and (p1__17584# x) (p1__17584# y) (p1__17584# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__17585#] (every? p1__17585# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n"} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__17586#] (or (p1 p1__17586#) (p2 p1__17586#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__17587#]\n       (or (p1 p1__17587#) (p2 p1__17587#) (p3 p1__17587#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__17588#] (p1__17588# x)) ps))\n    ([x y]\n     (some (fn* [p1__17589#] (or (p1__17589# x) (p1__17589# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__17590#]\n       (or (p1__17590# x) (p1__17590# y) (p1__17590# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__17591#] (some p1__17591# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n"} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n", :examples [{:body (do ["Remove all non-vowel characters up to the first vowel"] (drop-while (complement #{\a \e \i \o \u}) "clojure")), :body-str "(do\n [\"Remove all non-vowel characters up to the first vowel\"]\n (drop-while (complement #{\\a \\e \\i \\o \\u}) \"clojure\"))\n", :id "cljs.core/drop-while/0"}]} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), cljs.tools.reader.reader-types ({:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n indexing-push-back-reader\n \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (indexing-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len] (indexing-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (IndexingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name)))\n"} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :source "(defn\n log-source*\n [reader f]\n (let\n  [buffer (:buffer @(.-frames reader))]\n  (try\n   (swap!\n    (.-frames reader)\n    update-in\n    [:offset]\n    conj\n    (.getLength buffer))\n   (let\n    [ret (f)]\n    (if\n     (implements? IMeta ret)\n     (merge-meta ret {:source (peek-source-log @(.-frames reader))})\n     ret))\n   (finally (swap! (.-frames reader) update-in [:offset] rest)))))\n"} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :source "(defn\n merge-meta\n \"Returns an object of the same type and value as `obj`, with its\\nmetadata merged over `m`.\"\n [obj m]\n (let\n  [orig-meta (meta obj)]\n  (with-meta obj (merge m (dissoc orig-meta :source)))))\n"} {:sym Reader, :meta {:doc nil}, :methods (peek-char read-char)} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n source-logging-push-back-reader\n \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (source-logging-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len]\n  (source-logging-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (SourceLoggingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name\n   (atom {:buffer (StringBuffer.), :offset '(0)}))))\n"} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :protocol IPushbackReader} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :protocol Reader} {:sym IPushbackReader, :meta {:doc nil}, :methods (unread)} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :source "(defn\n indexing-reader?\n \"Returns true if the reader satisfies IndexingReader\"\n [rdr]\n (implements? IndexingReader rdr))\n"} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists [[s]]}, :source "(defn\n string-reader\n \"Creates a StringReader from a given string\"\n ([s] (StringReader. s (count s) 0)))\n"} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :protocol Reader} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :protocol IndexingReader} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists [[rdr]]}, :source "(defn\n read-line\n \"Reads a line from the reader or from *in* if no reader is specified\"\n ([rdr]\n  (loop\n   [c (read-char rdr) s (StringBuffer.)]\n   (if (newline? c) (str s) (recur (read-char rdr) (.append s c))))))\n"} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists [[s] [s buf-len]]}, :source "(defn\n string-push-back-reader\n \"Creates a PushbackReader from a given string\"\n ([s] (string-push-back-reader s 1))\n ([s buf-len]\n  (PushbackReader.\n   (string-reader s)\n   (object-array buf-len)\n   buf-len\n   buf-len)))\n"} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :source "(defn\n line-start?\n \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n [rdr]\n (when (indexing-reader? rdr) (== 1 (get-column-number rdr))))\n"} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n source-logging-reader?\n [rdr]\n (instance? SourceLoggingPushbackReader rdr))\n"} {:sym IndexingReader, :meta {:doc nil}, :methods (get-column-number get-file-name get-line-number)} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :source "(defn\n node-readable-push-back-reader\n [readable]\n (PushbackReader.\n  (NodeReadableReader. readable nil)\n  (object-array 1)\n  1\n  1))\n"} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader}), paren-soup.console ({:sym create-console-history, :meta {:doc nil, :arglists ([])}, :source "(defn\n create-console-history\n []\n (atom {:current-line 0, :lines [], :start 0}))\n"} {:sym get-console-start, :meta {:doc nil, :arglists ([console-history])}, :source "(defn\n get-console-start\n [console-history]\n (-> console-history deref :start))\n"} {:sym update-console-start!, :meta {:doc nil, :arglists ([console-history start])}, :source "(defn\n update-console-start!\n [console-history start]\n (swap! console-history assoc :start start))\n"} {:sym update-console-history!, :meta {:doc "Updates the console history atom.", :arglists ([console-history line])}, :source "(defn\n update-console-history!\n \"Updates the console history atom.\"\n [console-history line]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (swap!\n   console-history\n   (fn\n    [console-history-map]\n    (let\n     [lines\n      (if\n       (and (seq line) (not= line (last lines)))\n       (conj lines line)\n       lines)]\n     (assoc\n      console-history-map\n      :current-line\n      (count lines)\n      :lines\n      lines))))))\n"} {:sym get-previous-line, :meta {:doc "Returns the previous line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n get-previous-line\n \"Returns the previous line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (get lines (dec current-line))))\n"} {:sym get-next-line, :meta {:doc "Returns the next line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n get-next-line\n \"Returns the next line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [{:keys [current-line lines]} @console-history]\n  (get lines (inc current-line))))\n"} {:sym up!, :meta {:doc "Changes the current line and returns the previous line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n up!\n \"Changes the current line and returns the previous line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [line (get-previous-line console-history)]\n  (if\n   line\n   (swap! console-history update :current-line dec)\n   (swap! console-history assoc :current-line -1))\n  line))\n"} {:sym down!, :meta {:doc "Changes the current line and returns the next line from console-history, or nil if there is none.", :arglists ([console-history])}, :source "(defn\n down!\n \"Changes the current line and returns the next line from console-history, or nil if there is none.\"\n [console-history]\n (let\n  [line (get-next-line console-history)]\n  (if\n   line\n   (swap! console-history update :current-line inc)\n   (swap!\n    console-history\n    assoc\n    :current-line\n    (-> @console-history :lines count)))\n  line))\n"}), cljs.core.async ({:sym Pub, :meta {:doc nil}, :methods (sub* unsub* unsub-all*)} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :arglists ([f init ch])}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. Returns a channel containing\\n  the single result of applying f to init and the first item from the\\n  channel, then applying f to that result and the 2nd item, etc. If\\n  the channel closes without yielding items, returns init and f is not\\n  called. ch must close before reduce produces a result.\"\n [f init ch]\n (go-loop\n  [ret init]\n  (let\n   [v (<! ch)]\n   (if\n    (nil? v)\n    ret\n    (let [ret' (f ret v)] (if (reduced? ret') @ret' (recur ret')))))))\n"} {:sym remove>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n remove>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (filter> (complement p) ch))\n"} {:sym timeout, :meta {:doc "Returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"Returns a channel that will close after msecs\"\n [msecs]\n (timers/timeout msecs))\n"} {:sym unsub*, :meta {:doc nil, :arglists ([p v ch])}, :protocol Pub} {:sym admix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym unmix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym mix, :meta {:doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :arglists ([out])}, :source "(defn\n mix\n \"Creates and returns a mix of one or more input channels which will\\n  be put on the supplied out channel. Input sources can be added to\\n  the mix with 'admix', and removed with 'unmix'. A mix supports\\n  soloing, muting and pausing multiple inputs atomically using\\n  'toggle', and can solo using either muting or pausing as determined\\n  by 'solo-mode'.\\n\\n  Each channel can have zero or more boolean modes set via 'toggle':\\n\\n  :solo - when true, only this (ond other soloed) channel(s) will appear\\n          in the mix output channel. :mute and :pause states of soloed\\n          channels are ignored. If solo-mode is :mute, non-soloed\\n          channels are muted, if :pause, non-soloed channels are\\n          paused.\\n\\n  :mute - muted channels will have their contents consumed but not included in the mix\\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\\n\"\n [out]\n (let\n  [cs\n   (atom {})\n   solo-modes\n   #{:pause :mute}\n   attrs\n   (conj solo-modes :solo)\n   solo-mode\n   (atom :mute)\n   change\n   (chan)\n   changed\n   (fn* [] (put! change true))\n   pick\n   (fn\n    [attr chs]\n    (reduce-kv (fn [ret c v] (if (attr v) (conj ret c) ret)) #{} chs))\n   calc-state\n   (fn\n    []\n    (let\n     [chs\n      @cs\n      mode\n      @solo-mode\n      solos\n      (pick :solo chs)\n      pauses\n      (pick :pause chs)]\n     {:solos solos,\n      :mutes (pick :mute chs),\n      :reads\n      (conj\n       (if\n        (and (= mode :pause) (not (empty? solos)))\n        (vec solos)\n        (vec (remove pauses (keys chs))))\n       change)}))\n   m\n   (reify\n    Mux\n    (muxch* [_] out)\n    Mix\n    (admix* [_ ch] (swap! cs assoc ch {}) (changed))\n    (unmix* [_ ch] (swap! cs dissoc ch) (changed))\n    (unmix-all* [_] (reset! cs {}) (changed))\n    (toggle*\n     [_ state-map]\n     (swap! cs (partial merge-with cljs.core/merge) state-map)\n     (changed))\n    (solo-mode*\n     [_ mode]\n     (assert\n      (solo-modes mode)\n      (str \"mode must be one of: \" solo-modes))\n     (reset! solo-mode mode)\n     (changed)))]\n  (go-loop\n   [{:keys [solos mutes reads], :as state} (calc-state)]\n   (let\n    [[v c] (alts! reads)]\n    (if\n     (or (nil? v) (= c change))\n     (do (when (nil? v) (swap! cs dissoc c)) (recur (calc-state)))\n     (if\n      (or (solos c) (and (empty? solos) (not (mutes c))))\n      (when (>! out v) (recur state))\n      (recur state)))))\n  m))\n"} {:sym pub, :meta {:doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :arglists [[ch topic-fn] [ch topic-fn buf-fn]]}, :source "(defn\n pub\n \"Creates and returns a pub(lication) of the supplied channel,\\n  partitioned into topics by the topic-fn. topic-fn will be applied to\\n  each value on the channel and the result will determine the 'topic'\\n  on which that value will be put. Channels can be subscribed to\\n  receive copies of topics using 'sub', and unsubscribed using\\n  'unsub'. Each topic will be handled by an internal mult on a\\n  dedicated channel. By default these internal channels are\\n  unbuffered, but a buf-fn can be supplied which, given a topic,\\n  creates a buffer with desired properties.\\n\\n  Each item is distributed to all subs in parallel and synchronously,\\n  i.e. each sub must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow subs from holding up the pub.\\n\\n  Items received when there are no matching subs get dropped.\\n\\n  Note that if buf-fns are used then each topic is handled\\n  asynchronously, i.e. if a channel is subscribed to more than one\\n  topic it should not expect them to be interleaved identically with\\n  the source.\"\n ([ch topic-fn] (pub ch topic-fn (constantly nil)))\n ([ch topic-fn buf-fn]\n  (let\n   [mults\n    (atom {})\n    ensure-mult\n    (fn\n     [topic]\n     (or\n      (get @mults topic)\n      (get\n       (swap!\n        mults\n        (fn*\n         [p1__17537#]\n         (if\n          (p1__17537# topic)\n          p1__17537#\n          (assoc p1__17537# topic (mult (chan (buf-fn topic)))))))\n       topic)))\n    p\n    (reify\n     Mux\n     (muxch* [_] ch)\n     Pub\n     (sub*\n      [p topic ch close?]\n      (let [m (ensure-mult topic)] (tap m ch close?)))\n     (unsub*\n      [p topic ch]\n      (when-let [m (get @mults topic)] (untap m ch)))\n     (unsub-all* [_] (reset! mults {}))\n     (unsub-all* [_ topic] (swap! mults dissoc topic)))]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (doseq [m (vals @mults)] (close! (muxch* m)))\n      (let\n       [topic (topic-fn val) m (get @mults topic)]\n       (when\n        m\n        (when-not (>! (muxch* m) val) (swap! mults dissoc topic)))\n       (recur)))))\n   p)))\n"} {:sym take, :meta {:doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return chanel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n take\n \"Returns a channel that will return, at most, n items from ch. After n items\\n   have been returned, or ch has been closed, the return chanel will close.\\n\\n  The output channel is unbuffered by default, unless buf-or-n is given.\"\n ([n ch] (take n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [x 0]\n     (when\n      (< x n)\n      (let\n       [v (<! ch)]\n       (when (not (nil? v)) (>! out v) (recur (inc x))))))\n    (close! out))\n   out)))\n"} {:sym unsub-all*, :meta {:doc nil, :arglists ([p] [p v])}, :protocol Pub} {:sym <!, :meta {:doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.\n  Returns true unless port is already closed", :arglists ([port])}, :source "(defn\n <!\n \"takes a val from port. Must be called inside a (go ...) block. Will\\n  return nil if closed. Will park if nothing is available.\\n  Returns true unless port is already closed\"\n [port]\n (throw (js/Error. \"<! used not in (go ...) block\")))\n"} {:sym map, :meta {:doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :arglists [[f chs] [f chs buf-or-n]]}, :source "(defn\n map\n \"Takes a function and a collection of source channels, and returns a\\n  channel which contains the values produced by applying f to the set\\n  of first items taken from each source channel, followed by applying\\n  f to the set of second items from each channel, until any one of the\\n  channels is closed, at which point the output channel will be\\n  closed. The returned channel will be unbuffered by default, or a\\n  buf-or-n can be supplied\"\n ([f chs] (map f chs nil))\n ([f chs buf-or-n]\n  (let\n   [chs\n    (vec chs)\n    out\n    (chan buf-or-n)\n    cnt\n    (count chs)\n    rets\n    (object-array cnt)\n    dchan\n    (chan 1)\n    dctr\n    (atom nil)\n    done\n    (mapv\n     (fn\n      [i]\n      (fn\n       [ret]\n       (aset rets i ret)\n       (when (zero? (swap! dctr dec)) (put! dchan (.slice rets 0)))))\n     (range cnt))]\n   (go-loop\n    []\n    (reset! dctr cnt)\n    (dotimes\n     [i cnt]\n     (try\n      (take! (chs i) (done i))\n      (catch js/Object e (swap! dctr dec))))\n    (let\n     [rets (<! dchan)]\n     (if\n      (some nil? rets)\n      (close! out)\n      (do (>! out (apply f rets)) (recur)))))\n   out)))\n"} {:sym Mux, :meta {:doc nil}, :methods (muxch*)} {:sym mapcat>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f out] [f out buf-or-n]]}, :source "(defn\n mapcat>\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f out] (mapcat> f out nil))\n ([f out buf-or-n] (let [in (chan buf-or-n)] (mapcat* f in out) in)))\n"} {:sym buffer, :meta {:doc "Returns a fixed buffer of size n. When full, puts will block/park.", :arglists ([n])}, :source "(defn\n buffer\n \"Returns a fixed buffer of size n. When full, puts will block/park.\"\n [n]\n (buffers/fixed-buffer n))\n"} {:sym close!, :meta {:doc nil, :arglists [[port]]}, :source "(defn close! ([port] (impl/close! port)))\n"} {:sym offer!, :meta {:doc "Puts a val into port if it's possible to do so immediately.\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.", :arglists ([port val])}, :source "(defn\n offer!\n \"Puts a val into port if it's possible to do so immediately.\\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.\"\n [port val]\n (let\n  [ret (impl/put! port val (fn-handler nop false))]\n  (when ret @ret)))\n"} {:sym chan, :meta {:doc "Creates a channel with an optional buffer, an optional transducer (like (map f),\n  (filter p) etc or a composition thereof), and an optional exception handler.\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\n  transducer is supplied a buffer must be specified. ex-handler must be a\n  fn of one argument - if an exception occurs during transformation it will be called\n  with the thrown value as an argument, and any non-nil return value will be placed\n  in the channel.", :arglists [[] [buf-or-n] [buf-or-n xform] [buf-or-n xform ex-handler]]}, :source "(defn\n chan\n \"Creates a channel with an optional buffer, an optional transducer (like (map f),\\n  (filter p) etc or a composition thereof), and an optional exception handler.\\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\\n  transducer is supplied a buffer must be specified. ex-handler must be a\\n  fn of one argument - if an exception occurs during transformation it will be called\\n  with the thrown value as an argument, and any non-nil return value will be placed\\n  in the channel.\"\n ([] (chan nil))\n ([buf-or-n] (chan buf-or-n nil nil))\n ([buf-or-n xform] (chan buf-or-n xform nil))\n ([buf-or-n xform ex-handler]\n  (let\n   [buf-or-n (if (= buf-or-n 0) nil buf-or-n)]\n   (when\n    xform\n    (assert buf-or-n \"buffer must be supplied when transducer is\"))\n   (channels/chan\n    (if (number? buf-or-n) (buffer buf-or-n) buf-or-n)\n    xform\n    ex-handler))))\n"} {:sym solo-mode*, :meta {:doc nil, :arglists ([m mode])}, :protocol Mix} {:sym tap, :meta {:doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[mult ch] [mult ch close?]]}, :source "(defn\n tap\n \"Copies the mult source onto the supplied channel.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([mult ch] (tap mult ch true))\n ([mult ch close?] (tap* mult ch close?) ch))\n"} {:sym admix, :meta {:doc "Adds ch as an input to the mix", :arglists ([mix ch])}, :source "(defn admix \"Adds ch as an input to the mix\" [mix ch] (admix* mix ch))\n"} {:sym promise-chan, :meta {:doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :arglists [[] [xform] [xform ex-handler]]}, :source "(defn\n promise-chan\n \"Creates a promise channel with an optional transducer, and an optional\\n  exception-handler. A promise channel can take exactly one value that consumers\\n  will receive. Once full, puts complete but val is dropped (no transfer).\\n  Consumers will block until either a value is placed in the channel or the\\n  channel is closed. See chan for the semantics of xform and ex-handler.\"\n ([] (promise-chan nil))\n ([xform] (promise-chan xform nil))\n ([xform ex-handler] (chan (buffers/promise-buffer) xform ex-handler)))\n"} {:sym unique, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[ch] [ch buf-or-n]]}, :source "(defn\n unique\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([ch] (unique ch nil))\n ([ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [last nil]\n     (let\n      [v (<! ch)]\n      (when\n       (not (nil? v))\n       (if (= v last) (recur last) (do (>! out v) (recur v))))))\n    (close! out))\n   out)))\n"} {:sym muxch*, :meta {:doc nil, :arglists ([_])}, :protocol Mux} {:sym solo-mode, :meta {:doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :arglists ([mix mode])}, :source "(defn\n solo-mode\n \"Sets the solo mode of the mix. mode must be one of :mute or :pause\"\n [mix mode]\n (solo-mode* mix mode))\n"} {:sym transduce, :meta {:doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :arglists ([xform f init ch])}, :source "(defn\n transduce\n \"async/reduces a channel with a transformation (xform f).\\n  Returns a channel containing the result.  ch must close before\\n  transduce produces a result.\"\n [xform f init ch]\n (let [f (xform f)] (go (let [ret (<! (reduce f init ch))] (f ret)))))\n"} {:sym onto-chan, :meta {:doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :arglists [[ch coll] [ch coll close?]]}, :source "(defn\n onto-chan\n \"Puts the contents of coll into the supplied channel.\\n\\n  By default the channel will be closed after the items are copied,\\n  but can be determined by the close? parameter.\\n\\n  Returns a channel which will close after the items are copied.\"\n ([ch coll] (onto-chan ch coll true))\n ([ch coll close?]\n  (go-loop\n   [vs (seq coll)]\n   (if\n    (and vs (>! ch (first vs)))\n    (recur (next vs))\n    (when close? (close! ch))))))\n"} {:sym to-chan, :meta {:doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :arglists ([coll])}, :source "(defn\n to-chan\n \"Creates and returns a channel which contains the contents of coll,\\n  closing when exhausted.\"\n [coll]\n (let [ch (chan (bounded-count 100 coll))] (onto-chan ch coll) ch))\n"} {:sym dropping-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :arglists ([n])}, :source "(defn\n dropping-buffer\n \"Returns a buffer of size n. When full, puts will complete but\\n  val will be dropped (no transfer).\"\n [n]\n (buffers/dropping-buffer n))\n"} {:sym untap-all, :meta {:doc "Disconnects all target channels from a mult", :arglists ([mult])}, :source "(defn\n untap-all\n \"Disconnects all target channels from a mult\"\n [mult]\n (untap-all* mult))\n"} {:sym into, :meta {:doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :arglists ([coll ch])}, :source "(defn\n into\n \"Returns a channel containing the single (collection) result of the\\n  items taken from the channel conjoined to the supplied\\n  collection. ch must close before into produces a result.\"\n [coll ch]\n (reduce conj coll ch))\n"} {:sym pipeline, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes.\n\n  Note this is supplied for API compatibility with the Clojure version.\n  Values of N > 1 will not result in actual concurrency in a\n  single-threaded runtime.", :arglists [[n to xf from] [n to xf from close?] [n to xf from close? ex-handler]]}, :source "(defn\n pipeline\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the transducer xf, with parallelism n. Because\\n  it is parallel, the transducer will be applied independently to each\\n  element, not across elements, and may produce zero or more outputs\\n  per input.  Outputs will be returned in order relative to the\\n  inputs. By default, the to channel will be closed when the from\\n  channel closes, but can be determined by the close?  parameter. Will\\n  stop consuming the from channel if the to channel closes.\\n\\n  Note this is supplied for API compatibility with the Clojure version.\\n  Values of N > 1 will not result in actual concurrency in a\\n  single-threaded runtime.\"\n ([n to xf from] (pipeline n to xf from true))\n ([n to xf from close?] (pipeline n to xf from close? nil))\n ([n to xf from close? ex-handler]\n  (pipeline* n to xf from close? ex-handler :compute)))\n"} {:sym sub, :meta {:doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[p topic ch] [p topic ch close?]]}, :source "(defn\n sub\n \"Subscribes a channel to a topic of a pub.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([p topic ch] (sub p topic ch true))\n ([p topic ch close?] (sub* p topic ch close?)))\n"} {:sym map>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch (f val) fn1))))\n"} {:sym pipe, :meta {:doc "Takes elements from the from channel and supplies them to the to\n   channel. By default, the to channel will be closed when the from\n   channel closes, but can be determined by the close?  parameter. Will\n   stop consuming the from channel if the to channel closes", :arglists [[from to] [from to close?]]}, :source "(defn\n pipe\n \"Takes elements from the from channel and supplies them to the to\\n   channel. By default, the to channel will be closed when the from\\n   channel closes, but can be determined by the close?  parameter. Will\\n   stop consuming the from channel if the to channel closes\"\n ([from to] (pipe from to true))\n ([from to close?]\n  (go-loop\n   []\n   (let\n    [v (<! from)]\n    (if (nil? v) (when close? (close! to)) (when (>! to v) (recur)))))\n  to))\n"} {:sym unmix, :meta {:doc "Removes ch as an input to the mix", :arglists ([mix ch])}, :source "(defn\n unmix\n \"Removes ch as an input to the mix\"\n [mix ch]\n (unmix* mix ch))\n"} {:sym filter<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n filter<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (filter< p ch nil))\n ([p ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (close! out)\n      (do (when (p val) (>! out val)) (recur)))))\n   out)))\n"} {:sym sub*, :meta {:doc nil, :arglists ([p v ch close?])}, :protocol Pub} {:sym remove<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n remove<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (remove< p ch nil))\n ([p ch buf-or-n] (filter< (complement p) ch buf-or-n)))\n"} {:sym untap*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mult} {:sym toggle, :meta {:doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :arglists ([mix state-map])}, :source "(defn\n toggle\n \"Atomically sets the state(s) of one or more channels in a mix. The\\n  state map is a map of channels -> channel-state-map. A\\n  channel-state-map is a map of attrs -> boolean, where attr is one or\\n  more of :mute, :pause or :solo. Any states supplied are merged with\\n  the current state.\\n\\n  Note that channels can be added to a mix via toggle, which can be\\n  used to add channels in a particular (e.g. paused) state.\"\n [mix state-map]\n (toggle* mix state-map))\n"} {:sym untap-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mult} {:sym sliding-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :arglists ([n])}, :source "(defn\n sliding-buffer\n \"Returns a buffer of size n. When full, puts will complete, and be\\n  buffered, but oldest elements in buffer will be dropped (not\\n  transferred).\"\n [n]\n (buffers/sliding-buffer n))\n"} {:sym partition, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n partition\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([n ch] (partition n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [arr (make-array n) idx 0]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (do\n        (aset arr idx v)\n        (let\n         [new-idx (inc idx)]\n         (if\n          (< new-idx n)\n          (recur arr new-idx)\n          (do (>! out (vec arr)) (recur (make-array n) 0)))))\n       (do (when (> idx 0) (>! out (vec arr))) (close! out))))))\n   out)))\n"} {:sym Mult, :meta {:doc nil}, :methods (tap* untap* untap-all*)} {:sym merge, :meta {:doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :arglists [[chs] [chs buf-or-n]]}, :source "(defn\n merge\n \"Takes a collection of source channels and returns a channel which\\n  contains all values taken from them. The returned channel will be\\n  unbuffered by default, or a buf-or-n can be supplied. The channel\\n  will close after all the source channels have closed.\"\n ([chs] (merge chs nil))\n ([chs buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    [cs (vec chs)]\n    (if\n     (pos? (count cs))\n     (let\n      [[v c] (alts! cs)]\n      (if\n       (nil? v)\n       (recur (filterv (fn* [p1__17538#] (not= c p1__17538#)) cs))\n       (do (>! out v) (recur cs))))\n     (close! out)))\n   out)))\n"} {:sym partition-by, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f ch] [f ch buf-or-n]]}, :source "(defn\n partition-by\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f ch] (partition-by f ch nil))\n ([f ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [lst (make-array 0) last :clojure.core/nothing]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (let\n        [new-itm (f v)]\n        (if\n         (or\n          (= new-itm last)\n          (keyword-identical? last :clojure.core/nothing))\n         (do (.push lst v) (recur lst new-itm))\n         (do\n          (>! out (vec lst))\n          (let\n           [new-lst (make-array 0)]\n           (.push new-lst v)\n           (recur new-lst new-itm)))))\n       (do\n        (when (> (alength lst) 0) (>! out (vec lst)))\n        (close! out))))))\n   out)))\n"} {:sym unsub-all, :meta {:doc "Unsubscribes all channels from a pub, or a topic of a pub", :arglists [[p] [p topic]]}, :source "(defn\n unsub-all\n \"Unsubscribes all channels from a pub, or a topic of a pub\"\n ([p] (unsub-all* p))\n ([p topic] (unsub-all* p topic)))\n"} {:sym >!, :meta {:doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :arglists ([port val])}, :source "(defn\n >!\n \"puts a val into port. nil values are not allowed. Must be called\\n  inside a (go ...) block. Will park if no buffer space is available.\\n  Returns true unless port is already closed.\"\n [port val]\n (throw (js/Error. \">! used not in (go ...) block\")))\n"} {:sym unmix-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mix} {:sym split, :meta {:doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :arglists [[p ch] [p ch t-buf-or-n f-buf-or-n]]}, :source "(defn\n split\n \"Takes a predicate and a source channel and returns a vector of two\\n  channels, the first of which will contain the values for which the\\n  predicate returned true, the second those for which it returned\\n  false.\\n\\n  The out channels will be unbuffered by default, or two buf-or-ns can\\n  be supplied. The channels will close after the source channel has\\n  closed.\"\n ([p ch] (split p ch nil nil))\n ([p ch t-buf-or-n f-buf-or-n]\n  (let\n   [tc (chan t-buf-or-n) fc (chan f-buf-or-n)]\n   (go-loop\n    []\n    (let\n     [v (<! ch)]\n     (if\n      (nil? v)\n      (do (close! tc) (close! fc))\n      (when (>! (if (p v) tc fc) v) (recur)))))\n   [tc fc])))\n"} {:sym unmix-all, :meta {:doc "removes all inputs from the mix", :arglists ([mix])}, :source "(defn\n unmix-all\n \"removes all inputs from the mix\"\n [mix]\n (unmix-all* mix))\n"} {:sym filter>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n filter>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put!\n   [_ val fn1]\n   (if\n    (p val)\n    (impl/put! ch val fn1)\n    (channels/box (not (impl/closed? ch)))))))\n"} {:sym tap*, :meta {:doc nil, :arglists ([m ch close?])}, :protocol Mult} {:sym untap, :meta {:doc "Disconnects a target channel from a mult", :arglists ([mult ch])}, :source "(defn\n untap\n \"Disconnects a target channel from a mult\"\n [mult ch]\n (untap* mult ch))\n"} {:sym alts!, :meta {:doc "Completes at most one of several channel operations. Must be called\n   inside a (go ...) block. ports is a vector of channel endpoints,\n   which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :arglists ([ports & {:as opts}])}, :source "(defn\n alts!\n \"Completes at most one of several channel operations. Must be called\\n   inside a (go ...) block. ports is a vector of channel endpoints,\\n   which can be either a channel to take from or a vector of\\n  [channel-to-put-to val-to-put], in any combination. Takes will be\\n  made as if by <!, and puts will be made as if by >!. Unless\\n  the :priority option is true, if more than one port operation is\\n  ready a non-deterministic choice will be made. If no operation is\\n  ready and a :default value is supplied, [default-val :default] will\\n  be returned, otherwise alts! will park until the first operation to\\n  become ready completes. Returns [val port] of the completed\\n  operation, where val is the value taken for takes, and a\\n  boolean (true unless already closed, as per put!) for puts.\\n\\n  opts are passed as :key val ... Supported options:\\n\\n  :default val - the value to use if none of the operations are immediately ready\\n  :priority true - (default nil) when true, the operations will be tried in order.\\n\\n  Note: there is no guarantee that the port exps or val exprs will be\\n  used, nor in what order should they be, so they should not be\\n  depended upon for side effects.\"\n [ports & {:as opts}]\n (throw (js/Error. \"alts! used not in (go ...) block\")))\n"} {:sym unsub, :meta {:doc "Unsubscribes a channel from a topic of a pub", :arglists ([p topic ch])}, :source "(defn\n unsub\n \"Unsubscribes a channel from a topic of a pub\"\n [p topic ch]\n (unsub* p topic ch))\n"} {:sym poll!, :meta {:doc "Takes a val from port if it's possible to do so immediately.\n  Never blocks. Returns value if successful, nil otherwise.", :arglists ([port])}, :source "(defn\n poll!\n \"Takes a val from port if it's possible to do so immediately.\\n  Never blocks. Returns value if successful, nil otherwise.\"\n [port]\n (let [ret (impl/take! port (fn-handler nop false))] (when ret @ret)))\n"} {:sym map<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map<\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take!\n   [_ fn1]\n   (let\n    [ret\n     (impl/take!\n      ch\n      (reify\n       impl/Handler\n       (active? [_] (impl/active? fn1))\n       (blockable? [_] true)\n       (commit\n        [_]\n        (let\n         [f1 (impl/commit fn1)]\n         (fn*\n          [p1__17539#]\n          (f1 (if (nil? p1__17539#) nil (f p1__17539#))))))))]\n    (if (and ret (not (nil? @ret))) (channels/box (f @ret)) ret)))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch val fn1))))\n"} {:sym do-alts, :meta {:doc "returns derefable [val port] if immediate, nil if enqueued", :arglists ([fret ports opts])}, :source "(defn\n do-alts\n \"returns derefable [val port] if immediate, nil if enqueued\"\n [fret ports opts]\n (let\n  [flag\n   (alt-flag)\n   n\n   (count ports)\n   idxs\n   (random-array n)\n   priority\n   (:priority opts)\n   ret\n   (loop\n    [i 0]\n    (when\n     (< i n)\n     (let\n      [idx\n       (if priority i (aget idxs i))\n       port\n       (nth ports idx)\n       wport\n       (when (vector? port) (port 0))\n       vbox\n       (if\n        wport\n        (let\n         [val (port 1)]\n         (impl/put!\n          wport\n          val\n          (alt-handler\n           flag\n           (fn* [p1__17535#] (fret [p1__17535# wport])))))\n        (impl/take!\n         port\n         (alt-handler\n          flag\n          (fn* [p1__17536#] (fret [p1__17536# port])))))]\n      (if\n       vbox\n       (channels/box [@vbox (or wport port)])\n       (recur (inc i))))))]\n  (or\n   ret\n   (when\n    (contains? opts :default)\n    (when-let\n     [got (and (impl/active? flag) (impl/commit flag))]\n     (channels/box [(:default opts) :default]))))))\n"} {:sym pipeline-async, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  whose completion/callback will manipulate the result channel. Outputs\n  will be returned in order relative to  the inputs. By default, the to\n  channel will be closed when the from channel closes, but can be\n  determined by the close?  parameter. Will stop consuming the from\n  channel if the to channel closes.", :arglists [[n to af from] [n to af from close?]]}, :source "(defn\n pipeline-async\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the async function af, with parallelism n. af\\n  must be a function of two arguments, the first an input value and\\n  the second a channel on which to place the result(s). af must close!\\n  the channel before returning.  The presumption is that af will\\n  return immediately, having launched some asynchronous operation\\n  whose completion/callback will manipulate the result channel. Outputs\\n  will be returned in order relative to  the inputs. By default, the to\\n  channel will be closed when the from channel closes, but can be\\n  determined by the close?  parameter. Will stop consuming the from\\n  channel if the to channel closes.\"\n ([n to af from] (pipeline-async n to af from true))\n ([n to af from close?] (pipeline* n to af from close? nil :async)))\n"} {:sym Mix, :meta {:doc nil}, :methods (admix* solo-mode* toggle* unmix* unmix-all*)} {:sym toggle*, :meta {:doc nil, :arglists ([m state-map])}, :protocol Mix} {:sym mult, :meta {:doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :arglists ([ch])}, :source "(defn\n mult\n \"Creates and returns a mult(iple) of the supplied channel. Channels\\n  containing copies of the channel can be created with 'tap', and\\n  detached with 'untap'.\\n\\n  Each item is distributed to all taps in parallel and synchronously,\\n  i.e. each tap must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow taps from holding up the mult.\\n\\n  Items received when there are no taps get dropped.\\n\\n  If a tap puts to a closed channel, it will be removed from the mult.\"\n [ch]\n (let\n  [cs\n   (atom {})\n   m\n   (reify\n    Mux\n    (muxch* [_] ch)\n    Mult\n    (tap* [_ ch close?] (swap! cs assoc ch close?) nil)\n    (untap* [_ ch] (swap! cs dissoc ch) nil)\n    (untap-all* [_] (reset! cs {}) nil))\n   dchan\n   (chan 1)\n   dctr\n   (atom nil)\n   done\n   (fn [_] (when (zero? (swap! dctr dec)) (put! dchan true)))]\n  (go-loop\n   []\n   (let\n    [val (<! ch)]\n    (if\n     (nil? val)\n     (doseq [[c close?] @cs] (when close? (close! c)))\n     (let\n      [chs (keys @cs)]\n      (reset! dctr (count chs))\n      (doseq\n       [c chs]\n       (when-not (put! c val done) (done nil) (untap* m c)))\n      (when (seq chs) (<! dchan))\n      (recur)))))\n  m))\n"} {:sym mapcat<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f in] [f in buf-or-n]]}, :source "(defn\n mapcat<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f in] (mapcat< f in nil))\n ([f in buf-or-n] (let [out (chan buf-or-n)] (mapcat* f in out) out)))\n"} {:sym ioc-alts!, :meta {:doc nil, :arglists ([state cont-block ports & {:as opts}])}, :source "(defn\n ioc-alts!\n [state cont-block ports & {:as opts}]\n (ioc/aset-all! state helpers/STATE-IDX cont-block)\n (when-let\n  [cb\n   (cljs.core.async/do-alts\n    (fn\n     [val]\n     (ioc/aset-all! state helpers/VALUE-IDX val)\n     (helpers/run-state-machine-wrapped state))\n    ports\n    opts)]\n  (ioc/aset-all! state helpers/VALUE-IDX @cb)\n  :recur))\n"} {:sym unblocking-buffer?, :meta {:doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :arglists ([buff])}, :source "(defn\n unblocking-buffer?\n \"Returns true if a channel created with buff will never block. That is to say,\\n   puts into this buffer will never cause the buffer to be full. \"\n [buff]\n (satisfies? impl/UnblockingBuffer buff))\n"} {:sym put!, :meta {:doc "Asynchronously puts a val into port, calling fn0 (if supplied) when\n   complete. nil values are not allowed. Will throw if closed. If\n   on-caller? (default true) is true, and the put is immediately\n   accepted, will call fn0 on calling thread.  Returns nil.", :arglists [[port val] [port val fn1] [port val fn1 on-caller?]]}, :source "(defn\n put!\n \"Asynchronously puts a val into port, calling fn0 (if supplied) when\\n   complete. nil values are not allowed. Will throw if closed. If\\n   on-caller? (default true) is true, and the put is immediately\\n   accepted, will call fn0 on calling thread.  Returns nil.\"\n ([port val] (if-let [ret (impl/put! port val fhnop)] @ret true))\n ([port val fn1] (put! port val fn1 true))\n ([port val fn1 on-caller?]\n  (if-let\n   [retb (impl/put! port val (fn-handler fn1))]\n   (let\n    [ret @retb]\n    (if on-caller? (fn1 ret) (dispatch/run (fn* [] (fn1 ret))))\n    ret)\n   true)))\n"} {:sym take!, :meta {:doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :arglists [[port fn1] [port fn1 on-caller?]]}, :source "(defn\n take!\n \"Asynchronously takes a val from port, passing to fn1. Will pass nil\\n   if closed. If on-caller? (default true) is true, and value is\\n   immediately available, will call fn1 on calling thread.\\n   Returns nil.\"\n ([port fn1] (take! port fn1 true))\n ([port fn1 on-caller?]\n  (let\n   [ret (impl/take! port (fn-handler fn1))]\n   (when\n    ret\n    (let\n     [val @ret]\n     (if on-caller? (fn1 val) (dispatch/run (fn* [] (fn1 val))))))\n   nil)))\n"}), reagent.impl.template ({:sym valid-tag?, :meta {:doc nil, :arglists ([x])}, :source "(defn\n valid-tag?\n [x]\n (or (hiccup-tag? x) (ifn? x) (instance? NativeWrapper x)))\n"} {:sym adapt-react-class, :meta {:doc nil, :arglists [[c {:keys [synthetic-input]}] [c]]}, :source "(defn\n adapt-react-class\n ([c {:keys [synthetic-input]}]\n  (let\n   [on-update\n    (:on-update synthetic-input)\n    on-change\n    (:on-change synthetic-input)]\n   (when\n    synthetic-input\n    (assert (fn? on-update))\n    (assert (fn? on-change)))\n   (let\n    [wrapped\n     (doto (->NativeWrapper) ($! :name c) ($! :id nil) ($! :class nil))\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticInput true))\n      wrapped)\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticOnChange on-change))\n      wrapped)\n     wrapped\n     (if\n      synthetic-input\n      (doto wrapped ($! :syntheticOnUpdate on-update))\n      wrapped)]\n    wrapped)))\n ([c] (adapt-react-class c {})))\n"} {:sym synthetic-input-spec, :meta {}, :source "(def\n synthetic-input-spec\n {:display-name \"ReagentSyntheticInput\",\n  :component-did-update input-component-set-value,\n  :component-will-unmount input-unmount,\n  :reagent-render\n  (fn\n   [on-update on-change argv comp jsprops first-child]\n   (let\n    [this comp/*current-component*]\n    (input-render-setup\n     this\n     jsprops\n     {:synthetic-on-update on-update, :synthetic-on-change on-change})\n    (make-element argv comp jsprops first-child)))})\n"} {:sym has-selection-api?, :meta {:doc nil, :arglists ([input-type])}, :source "(defn\n has-selection-api?\n [input-type]\n (contains? these-inputs-have-selection-api input-type))\n"} {:sym str-coll, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n str-coll\n [coll]\n (if\n  (dev?)\n  (str\n   (prewalk\n    (fn\n     [x]\n     (if\n      (fn? x)\n      (let [n (util/fun-name x)] (case n \"\" x (symbol n)))\n      x))\n    coll))\n  (str coll)))\n"} {:sym get-key, :meta {:doc nil, :arglists ([x])}, :source "(defn get-key [x] (when (map? x) (try-get-key x)))\n"} {:sym re-tag, :meta {:doc "Regular expression that parses a CSS-style id and class\n             from a tag name."}, :source "(def re-tag #\"([^\\s\\.#]+)(?:#([^\\s\\.#]+))?(?:\\.([^\\s#]+))?\")\n"} {:sym as-element, :meta {:doc nil, :arglists ([x])}, :source "(defn\n as-element\n [x]\n (cond\n  (js-val? x)\n  x\n  (vector? x)\n  (vec-to-elem x)\n  (seq? x)\n  (if (dev?) (expand-seq-check x) (expand-seq x))\n  (named? x)\n  (name x)\n  (satisfies? IPrintWithWriter x)\n  (pr-str x)\n  :else\n  x))\n"} {:sym input-component?, :meta {:doc nil, :arglists ([x])}, :source "(defn input-component? [x] (case x (\"input\" \"textarea\") true false))\n"} {:sym input-render-setup, :meta {:doc nil, :arglists [[this jsprops {:keys [synthetic-on-update synthetic-on-change]}] [this jsprops]]}, :source "(defn\n input-render-setup\n ([this jsprops {:keys [synthetic-on-update synthetic-on-change]}]\n  (when\n   (and\n    (some? jsprops)\n    (.hasOwnProperty jsprops \"onChange\")\n    (.hasOwnProperty jsprops \"value\"))\n   (assert\n    find-dom-node\n    \"reagent.dom needs to be loaded for controlled input to work\")\n   (when\n    synthetic-on-update\n    ($! this :cljsSyntheticOnUpdate synthetic-on-update))\n   (let\n    [v\n     ($ jsprops :value)\n     value\n     (if (nil? v) \"\" v)\n     on-change\n     ($ jsprops :onChange)\n     on-change\n     (if\n      synthetic-on-change\n      (partial synthetic-on-change on-change)\n      on-change)]\n    (when-not\n     ($ this :cljsInputLive)\n     ($! this :cljsInputLive true)\n     ($! this :cljsDOMValue value))\n    ($! this :cljsRenderedValue value)\n    (js-delete jsprops \"value\")\n    (doto\n     jsprops\n     ($! :defaultValue value)\n     ($!\n      :onChange\n      (fn*\n       [p1__17498#]\n       (input-handle-change this on-change p1__17498#)))))))\n ([this jsprops] (input-render-setup this jsprops {})))\n"} {:sym input-component-set-value, :meta {:doc nil, :arglists ([this])}, :source "(defn\n input-component-set-value\n [this]\n (when\n  ($ this :cljsInputLive)\n  ($! this :cljsInputDirty false)\n  (let\n   [rendered-value\n    ($ this :cljsRenderedValue)\n    dom-value\n    ($ this :cljsDOMValue)\n    node\n    (find-dom-node this)\n    synthetic-on-update\n    ($ this :cljsSyntheticOnUpdate)]\n   (when\n    (not= rendered-value dom-value)\n    (if\n     (fn? synthetic-on-update)\n     (synthetic-on-update\n      input-node-set-value\n      node\n      rendered-value\n      dom-value\n      this)\n     (input-node-set-value node rendered-value dom-value this {}))))))\n"} {:sym stringify-class, :meta {:doc nil, :arglists ([{:keys [class], :as props}])}, :source "(defn\n stringify-class\n [{:keys [class], :as props}]\n (if\n  (coll? class)\n  (->> class (filter identity) (string/join \" \") (assoc props :class))\n  props))\n"} {:sym oget, :meta {:doc nil, :arglists ([o k])}, :source "(defn oget [o k] (if (nil? o) nil (aget o k)))\n"} {:sym hiccup-tag?, :meta {:doc nil, :arglists ([x])}, :source "(defn hiccup-tag? [x] (or (named? x) (string? x)))\n"} {:sym set-id-class, :meta {:doc nil, :arglists ([p id-class])}, :source "(defn\n set-id-class\n [p id-class]\n (let\n  [id\n   ($ id-class :id)\n   p\n   (if (and (some? id) (nil? (oget p \"id\"))) (oset p \"id\" id) p)]\n  (if-some\n   [class ($ id-class :className)]\n   (let\n    [old (oget p \"className\")]\n    (oset p \"className\" (if (nil? old) class (str class \" \" old))))\n   p)))\n"} {:sym reagent-synthetic-input, :meta {:doc nil, :arglists ([])}, :source "(defn\n reagent-synthetic-input\n []\n (when\n  (nil? reagent-synthetic-input-class)\n  (set!\n   reagent-synthetic-input-class\n   (comp/create-class synthetic-input-spec)))\n reagent-synthetic-input-class)\n"} {:sym input-node-set-value, :meta {:doc nil, :arglists ([node rendered-value dom-value component {:keys [on-write]}])}, :source "(defn\n input-node-set-value\n [node rendered-value dom-value component {:keys [on-write]}]\n (if-not\n  (and\n   (identical? node ($ js/document :activeElement))\n   (has-selection-api? ($ node :type))\n   (string? rendered-value)\n   (string? dom-value))\n  (do\n   ($! component :cljsDOMValue rendered-value)\n   ($! node :value rendered-value)\n   (when (fn? on-write) (on-write rendered-value)))\n  (let\n   [node-value ($ node :value)]\n   (if\n    (not= node-value dom-value)\n    (batch/do-after-render\n     (fn* [] (input-component-set-value component)))\n    (let\n     [existing-offset-from-end\n      (- (count node-value) ($ node :selectionStart))\n      new-cursor-offset\n      (- (count rendered-value) existing-offset-from-end)]\n     ($! component :cljsDOMValue rendered-value)\n     ($! node :value rendered-value)\n     (when (fn? on-write) (on-write rendered-value))\n     ($! node :selectionStart new-cursor-offset)\n     ($! node :selectionEnd new-cursor-offset))))))\n"} {:sym convert-props, :meta {:doc nil, :arglists ([props id-class])}, :source "(defn\n convert-props\n [props id-class]\n (-> props stringify-class convert-prop-value (set-id-class id-class)))\n"} {:sym hiccup-err, :meta {:doc nil, :arglists ([v & msg])}, :source "(defn\n hiccup-err\n [v & msg]\n (str (apply str msg) \": \" (str-coll v) \"\\n\" (comp/comp-name)))\n"} {:sym named?, :meta {:doc nil, :arglists ([x])}, :source "(defn named? [x] (or (keyword? x) (symbol? x)))\n"} {:sym kv-conv, :meta {:doc nil, :arglists ([o k v])}, :source "(defn\n kv-conv\n [o k v]\n (doto o (aset (cached-prop-name k) (convert-prop-value v))))\n"} {:sym key-from-vec, :meta {:doc nil, :arglists ([v])}, :source "(defn\n key-from-vec\n [v]\n (if-some [k (-> (meta v) get-key)] k (-> v (nth 1 nil) get-key)))\n"} {:sym js-val?, :meta {:doc nil, :arglists ([x])}, :source "(defn js-val? [x] (not (identical? \"object\" (goog/typeOf x))))\n"} {:sym input-unmount, :meta {:doc nil, :arglists ([this])}, :source "(defn input-unmount [this] ($! this :cljsInputLive nil))\n"} {:sym reagent-input-class, :meta {}, :source "(def reagent-input-class nil)\n"} {:sym native-element, :meta {:doc nil, :arglists ([parsed argv first])}, :source "(defn\n native-element\n [parsed argv first]\n (let\n  [comp ($ parsed :name) synthetic-input ($ parsed :syntheticInput)]\n  (let\n   [props\n    (nth argv first nil)\n    hasprops\n    (or (nil? props) (map? props))\n    jsprops\n    (convert-props (if hasprops props) parsed)\n    first-child\n    (+ first (if hasprops 1 0))]\n   (if\n    (or synthetic-input (input-component? comp))\n    (->\n     (if\n      synthetic-input\n      [(reagent-synthetic-input)\n       ($ parsed :syntheticOnUpdate)\n       ($ parsed :syntheticOnChange)\n       argv\n       comp\n       jsprops\n       first-child]\n      [(reagent-input) argv comp jsprops first-child])\n     (with-meta (meta argv))\n     as-element)\n    (let\n     [key\n      (-> (meta argv) get-key)\n      p\n      (if (nil? key) jsprops (oset jsprops \"key\" key))]\n     (make-element argv comp p first-child))))))\n"} {:sym reagent-input, :meta {:doc nil, :arglists ([])}, :source "(defn\n reagent-input\n []\n (when\n  (nil? reagent-input-class)\n  (set! reagent-input-class (comp/create-class input-spec)))\n reagent-input-class)\n"} {:sym cache-get, :meta {:doc nil, :arglists ([o k])}, :source "(defn cache-get [o k] (when (.hasOwnProperty o k) (aget o k)))\n"} {:sym input-handle-change, :meta {:doc nil, :arglists ([this on-change e])}, :source "(defn\n input-handle-change\n [this on-change e]\n ($! this :cljsDOMValue (-> e .-target .-value))\n (when-not\n  ($ this :cljsInputDirty)\n  ($! this :cljsInputDirty true)\n  (batch/do-after-render (fn* [] (input-component-set-value this))))\n (on-change e))\n"} {:sym input-spec, :meta {}, :source "(def\n input-spec\n {:display-name \"ReagentInput\",\n  :component-did-update input-component-set-value,\n  :component-will-unmount input-unmount,\n  :reagent-render\n  (fn\n   [argv comp jsprops first-child]\n   (let\n    [this comp/*current-component*]\n    (input-render-setup this jsprops)\n    (make-element argv comp jsprops first-child)))})\n"} {:sym expand-seq-dev, :meta {:doc nil, :arglists ([s o])}, :source "(defn\n expand-seq-dev\n [s o]\n (let\n  [a (into-array s)]\n  (dotimes\n   [i (alength a)]\n   (let\n    [val (aget a i)]\n    (when\n     (and (vector? val) (nil? (key-from-vec val)))\n     ($! o :no-key true))\n    (aset a i (as-element val))))\n  a))\n"} {:sym cached-prop-name, :meta {:doc nil, :arglists ([k])}, :source "(defn\n cached-prop-name\n [k]\n (if\n  (named? k)\n  (if-some\n   [k' (cache-get prop-name-cache (name k))]\n   k'\n   (aset prop-name-cache (name k) (util/dash-to-camel k)))\n  k))\n"} {:sym these-inputs-have-selection-api, :meta {}, :source "(def\n these-inputs-have-selection-api\n #{\"url\" \"tel\" \"text\" \"textarea\" \"password\" \"search\"})\n"} {:sym expand-seq, :meta {:doc nil, :arglists ([s])}, :source "(defn\n expand-seq\n [s]\n (let\n  [a (into-array s)]\n  (dotimes [i (alength a)] (aset a i (as-element (aget a i))))\n  a))\n"} {:sym reagent-synthetic-input-class, :meta {}, :source "(def reagent-synthetic-input-class nil)\n"} {:sym find-dom-node, :meta {}, :source "(defonce find-dom-node nil)\n"} {:sym cached-parse, :meta {:doc nil, :arglists ([x])}, :source "(defn\n cached-parse\n [x]\n (if-some\n  [s (cache-get tag-name-cache x)]\n  s\n  (aset tag-name-cache x (parse-tag x))))\n"} {:sym try-get-key, :meta {:doc nil, :arglists ([x])}, :source "(defn try-get-key [x] (try (get x :key) (catch :default e)))\n"}), reagent.impl.batching ({:sym fake-raf, :meta {:doc nil, :arglists ([f])}, :source "(defn fake-raf [f] (js/setTimeout f 16))\n"} {:sym do-before-flush, :meta {:doc nil, :arglists ([f])}, :source "(defn do-before-flush [f] (.add-before-flush render-queue f))\n"} {:sym flush-after-render, :meta {:doc nil, :arglists ([])}, :source "(defn flush-after-render [] (.flush-after-render render-queue))\n"} {:sym queue-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n queue-render\n [c]\n (when-not\n  ($ c :cljsIsDirty)\n  ($! c :cljsIsDirty true)\n  (.queue-render render-queue c)))\n"} {:sym next-tick, :meta {}, :source "(def\n next-tick\n (if-not\n  is-client\n  fake-raf\n  (let\n   [w js/window]\n   (or\n    ($ w :requestAnimationFrame)\n    ($ w :webkitRequestAnimationFrame)\n    ($ w :mozRequestAnimationFrame)\n    ($ w :msRequestAnimationFrame)\n    fake-raf))))\n"} {:sym flush, :meta {:doc nil, :arglists ([])}, :source "(defn flush [] (.flush-queues render-queue))\n"} {:sym mark-rendered, :meta {:doc nil, :arglists ([c])}, :source "(defn mark-rendered [c] ($! c :cljsIsDirty false))\n"} {:sym schedule, :meta {:doc nil, :arglists ([])}, :source "(defn\n schedule\n []\n (when (false? (.-scheduled? render-queue)) (.schedule render-queue)))\n"} {:sym render-queue, :meta {}, :source "(defonce render-queue (->RenderQueue false))\n"} {:sym compare-mount-order, :meta {:doc nil, :arglists ([c1 c2])}, :source "(defn\n compare-mount-order\n [c1 c2]\n (- ($ c1 :cljsMountOrder) ($ c2 :cljsMountOrder)))\n"} {:sym mount-count, :meta {}, :source "(defonce mount-count 0)\n"} {:sym next-mount-count, :meta {:doc nil, :arglists ([])}, :source "(defn next-mount-count [] (set! mount-count (inc mount-count)))\n"} {:sym do-after-render, :meta {:doc nil, :arglists ([f])}, :source "(defn do-after-render [f] (.add-after-render render-queue f))\n"} {:sym run-queue, :meta {:doc nil, :arglists ([a])}, :source "(defn\n run-queue\n [a]\n (.sort a compare-mount-order)\n (dotimes\n  [i (alength a)]\n  (let\n   [c (aget a i)]\n   (when (true? ($ c :cljsIsDirty)) ($ c forceUpdate)))))\n"} {:sym ratom-flush, :meta {}, :source "(defonce ratom-flush (fn []))\n"}), cljs.core.async.impl.buffers ({:sym acopy, :meta {:doc nil, :arglists ([src src-start dest dest-start len])}, :source "(defn\n acopy\n [src src-start dest dest-start len]\n (loop\n  [cnt 0]\n  (when\n   (< cnt len)\n   (aset dest (+ dest-start cnt) (aget src (+ src-start cnt)))\n   (recur (inc cnt)))))\n"} {:sym ring-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn\n ring-buffer\n [n]\n (assert (> n 0) \"Can't create a ring buffer of size 0\")\n (RingBuffer. 0 0 0 (make-array n)))\n"} {:sym fixed-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn fixed-buffer [n] (FixedBuffer. (ring-buffer n) n))\n"} {:sym dropping-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn dropping-buffer [n] (DroppingBuffer. (ring-buffer n) n))\n"} {:sym sliding-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn sliding-buffer [n] (SlidingBuffer. (ring-buffer n) n))\n"} {:sym promise-buffer, :meta {:doc nil, :arglists ([])}, :source "(defn promise-buffer [] (PromiseBuffer. NO-VAL))\n"}), cljs.core.async.impl.protocols ({:sym remove!, :meta {:doc "remove and return next item from buffer, called under chan mutex", :arglists ([b])}, :protocol Buffer} {:sym close-buf!, :meta {:doc "called on chan closed under chan mutex, return ignored", :arglists ([b])}, :protocol Buffer} {:sym close!, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym Handler, :meta {:doc nil}, :methods (active? blockable? commit)} {:sym blockable?, :meta {:doc "returns true if this handler may be blocked, otherwise it must not block", :arglists ([h])}, :protocol Handler} {:sym active?, :meta {:doc "returns true if has callback. Must work w/o lock", :arglists ([h])}, :protocol Handler} {:sym Buffer, :meta {:doc nil}, :methods (add!* close-buf! full? remove!)} {:sym full?, :meta {:doc "returns true if buffer cannot accept put", :arglists ([b])}, :protocol Buffer} {:sym add!, :meta {:doc nil, :arglists [[b] [b itm]]}, :source "(defn add! ([b] b) ([b itm] (assert (not (nil? itm))) (add!* b itm)))\n"} {:sym add!*, :meta {:doc "if room, add item to the buffer, returns b, called under chan mutex", :arglists ([b itm])}, :protocol Buffer} {:sym ReadPort, :meta {:doc nil}, :methods (take!)} {:sym Channel, :meta {:doc nil}, :methods (close! closed?)} {:sym closed?, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym UnblockingBuffer, :meta {:doc nil}, :methods ()} {:sym MAX-QUEUE-SIZE, :meta {}, :source "(def MAX-QUEUE-SIZE 1024)\n"} {:sym commit, :meta {:doc "commit to fulfilling its end of the transfer, returns cb. Must be called within lock", :arglists ([h])}, :protocol Handler} {:sym put!, :meta {:doc "derefable boolean (false if already closed) if handled, nil if put was enqueued.\n                               Must throw on nil val.", :arglists ([port val fn1-handler])}, :protocol WritePort} {:sym take!, :meta {:doc "derefable val if taken, nil if take was enqueued", :arglists ([port fn1-handler])}, :protocol ReadPort} {:sym WritePort, :meta {:doc nil}, :methods (put!)}), cljs.tools.reader.impl.inspect ({:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists [[x] [truncate x]]}, :source "(defn\n inspect\n \"Return a string description of the value supplied.\\n   May be the a string version of the value itself (e.g. \\\"true\\\")\\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\\n   If truncate is true then return a very terse version of\\n   the inspection.\"\n ([x] (inspect* false x))\n ([truncate x] (inspect* truncate x)))\n"}), sablono.core ({:sym wrap-attrs, :meta {:doc "Add an optional attribute argument to a function that returns a element vector.", :arglists ([func])}, :source "(defn\n wrap-attrs\n \"Add an optional attribute argument to a function that returns a element vector.\"\n [func]\n (fn\n  [& args]\n  (if\n   (map? (first args))\n   (let\n    [[tag & body] (apply func (rest args))]\n    (if\n     (map? (first body))\n     (into [tag (merge (first body) (first args))] (rest body))\n     (into [tag (first args)] body)))\n   (apply func args))))\n"} {:sym include-css, :meta {:doc "Include a list of external stylesheet files.", :arglists ([& styles])}, :source "(defn\n include-css\n \"Include a list of external stylesheet files.\"\n [& styles]\n (for\n  [style styles]\n  [:link {:type \"text/css\", :href (as-str style), :rel \"stylesheet\"}]))\n"} {:sym include-react, :meta {:doc "Include Facebook's React JavaScript library.", :arglists ([])}, :source "(defn\n include-react\n \"Include Facebook's React JavaScript library.\"\n []\n (include-js \"http://fb.me/react-0.12.2.js\"))\n"} {:sym *group*, :meta {}, :source "(def *group* [])\n"} {:sym file-upload, :meta {}, :source "(def file-upload file-field)\n"}), clojure.set ({:sym union, :meta {:doc "Return a set that is the union of the input sets", :arglists [[] [s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n union\n \"Return a set that is the union of the input sets\"\n ([] #{})\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce conj s2 s1)\n   (reduce conj s1 s2)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n   (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym map-invert, :meta {:doc "Returns the map with the vals mapped to the keys.", :arglists ([m])}, :source "(defn\n map-invert\n \"Returns the map with the vals mapped to the keys.\"\n [m]\n (reduce (fn [m [k v]] (assoc m v k)) {} m))\n"} {:sym join, :meta {:doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :arglists [[xrel yrel] [xrel yrel km]]}, :source "(defn\n join\n \"When passed 2 rels, returns the rel corresponding to the natural\\n  join. When passed an additional keymap, joins on the corresponding\\n  keys.\"\n ([xrel yrel]\n  (if\n   (and (seq xrel) (seq yrel))\n   (let\n    [ks\n     (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n     [r s]\n     (if (<= (count xrel) (count yrel)) [xrel yrel] [yrel xrel])\n     idx\n     (index r ks)]\n    (reduce\n     (fn\n      [ret x]\n      (let\n       [found (idx (select-keys x ks))]\n       (if\n        found\n        (reduce\n         (fn*\n          [p1__17485# p2__17486#]\n          (conj p1__17485# (merge p2__17486# x)))\n         ret\n         found)\n        ret)))\n     #{}\n     s))\n   #{}))\n ([xrel yrel km]\n  (let\n   [[r s k]\n    (if\n     (<= (count xrel) (count yrel))\n     [xrel yrel (map-invert km)]\n     [yrel xrel km])\n    idx\n    (index r (vals k))]\n   (reduce\n    (fn\n     [ret x]\n     (let\n      [found (idx (rename-keys (select-keys x (keys k)) k))]\n      (if\n       found\n       (reduce\n        (fn*\n         [p1__17487# p2__17488#]\n         (conj p1__17487# (merge p2__17488# x)))\n        ret\n        found)\n       ret)))\n    #{}\n    s))))\n"} {:sym select, :meta {:doc "Returns a set of the elements for which pred is true", :arglists ([pred xset])}, :source "(defn\n select\n \"Returns a set of the elements for which pred is true\"\n [pred xset]\n (reduce (fn [s k] (if (pred k) s (disj s k))) xset xset))\n"} {:sym intersection, :meta {:doc "Return a set that is the intersection of the input sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n intersection\n \"Return a set that is the intersection of the input sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s2) (count s1))\n   (recur s2 s1)\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) result (disj result item)))\n    s1\n    s1)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets\n    (bubble-max-key\n     (fn* [p1__17482#] (- (count p1__17482#)))\n     (conj sets s2 s1))]\n   (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym superset?, :meta {:doc "Is set1 a superset of set2?", :arglists ([set1 set2])}, :source "(defn\n superset?\n \"Is set1 a superset of set2?\"\n [set1 set2]\n (and\n  (>= (count set1) (count set2))\n  (every? (fn* [p1__17490#] (contains? set1 p1__17490#)) set2)))\n"} {:sym index, :meta {:doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :arglists ([xrel ks])}, :source "(defn\n index\n \"Returns a map of the distinct values of ks in the xrel mapped to a\\n  set of the maps in xrel with the corresponding values of ks.\"\n [xrel ks]\n (reduce\n  (fn\n   [m x]\n   (let [ik (select-keys x ks)] (assoc m ik (conj (get m ik #{}) x))))\n  {}\n  xrel))\n"} {:sym subset?, :meta {:doc "Is set1 a subset of set2?", :arglists ([set1 set2])}, :source "(defn\n subset?\n \"Is set1 a subset of set2?\"\n [set1 set2]\n (and\n  (<= (count set1) (count set2))\n  (every? (fn* [p1__17489#] (contains? set2 p1__17489#)) set1)))\n"} {:sym rename, :meta {:doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :arglists ([xrel kmap])}, :source "(defn\n rename\n \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n [xrel kmap]\n (set (map (fn* [p1__17484#] (rename-keys p1__17484# kmap)) xrel)))\n"} {:sym rename-keys, :meta {:doc "Returns the map with the keys in kmap renamed to the vals in kmap", :arglists ([map kmap])}, :source "(defn\n rename-keys\n \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n [map kmap]\n (reduce\n  (fn\n   [m [old new]]\n   (if (contains? map old) (assoc m new (get map old)) m))\n  (apply dissoc map (keys kmap))\n  kmap))\n"} {:sym project, :meta {:doc "Returns a rel of the elements of xrel with only the keys in ks", :arglists ([xrel ks])}, :source "(defn\n project\n \"Returns a rel of the elements of xrel with only the keys in ks\"\n [xrel ks]\n (set (map (fn* [p1__17483#] (select-keys p1__17483# ks)) xrel)))\n"} {:sym difference, :meta {:doc "Return a set that is the first set without elements of the remaining sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n difference\n \"Return a set that is the first set without elements of the remaining sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) (disj result item) result))\n    s1\n    s1)\n   (reduce disj s1 s2)))\n ([s1 s2 & sets] (reduce difference s1 (conj sets s2))))\n"}), reagent.impl.component ({:sym get-props, :meta {:doc nil, :arglists ([c])}, :source "(defn\n get-props\n [c]\n (let\n  [p ($ c :props)]\n  (if-some [v ($ p :argv)] (extract-props v) (shallow-obj-to-map p))))\n"} {:sym get-wrapper, :meta {:doc nil, :arglists ([key f name])}, :source "(defn\n get-wrapper\n [key f name]\n (let\n  [wrap (custom-wrapper key f)]\n  (when (and wrap f) (assert-callable f))\n  (or wrap f)))\n"} {:sym get-argv, :meta {:doc nil, :arglists ([c])}, :source "(defn get-argv [c] (props-argv c ($ c :props)))\n"} {:sym wrap-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n wrap-render\n [c]\n (let\n  [f\n   ($ c :reagentRender)\n   _\n   (assert-callable f)\n   res\n   (if\n    (true? ($ c :cljsLegacyRender))\n    (.call f c c)\n    (let\n     [v (get-argv c) n (count v)]\n     (case\n      n\n      1\n      (.call f c)\n      2\n      (.call f c (nth v 1))\n      3\n      (.call f c (nth v 1) (nth v 2))\n      4\n      (.call f c (nth v 1) (nth v 2) (nth v 3))\n      5\n      (.call f c (nth v 1) (nth v 2) (nth v 3) (nth v 4))\n      (.apply f c (.slice (into-array v) 1)))))]\n  (cond\n   (vector? res)\n   (as-element res)\n   (ifn? res)\n   (let\n    [f\n     (if\n      (reagent-class? res)\n      (fn [& args] (as-element (apply vector res args)))\n      res)]\n    ($! c :reagentRender f)\n    (recur c))\n   :else\n   res)))\n"} {:sym rat-opts, :meta {}, :source "(def rat-opts {:no-cache true})\n"} {:sym obligatory, :meta {}, :source "(def\n obligatory\n {:shouldComponentUpdate nil,\n  :componentWillMount nil,\n  :componentWillUnmount nil})\n"} {:sym props-argv, :meta {:doc nil, :arglists ([c p])}, :source "(defn\n props-argv\n [c p]\n (if-some [a ($ p :argv)] a [(.-constructor c) (shallow-obj-to-map p)]))\n"} {:sym as-element, :meta {}, :source "(defonce as-element nil)\n"} {:sym do-render, :meta {:doc nil, :arglists ([c])}, :source "(defn\n do-render\n [c]\n (binding\n  [*current-component* c]\n  (if\n   (dev?)\n   (let\n    [ok (array false)]\n    (try\n     (let [res (wrap-render c)] (aset ok 0 true) res)\n     (finally\n      (when-not\n       (aget ok 0)\n       (error (str \"Error rendering component\" (comp-name)))))))\n   (wrap-render c))))\n"} {:sym comp-name, :meta {:doc nil, :arglists ([])}, :source "(defn\n comp-name\n []\n (if\n  (dev?)\n  (let\n   [c\n    *current-component*\n    n\n    (or (component-path c) (some-> c .-constructor util/fun-name))]\n   (if-not (empty? n) (str \" (in \" n \")\") \"\"))\n  \"\"))\n"} {:sym add-obligatory, :meta {:doc nil, :arglists ([fun-map])}, :source "(defn add-obligatory [fun-map] (merge obligatory fun-map))\n"} {:sym cached-react-class, :meta {:doc nil, :arglists ([c])}, :source "(defn cached-react-class [c] ($ c :cljsReactClass))\n"} {:sym state-atom, :meta {:doc nil, :arglists ([this])}, :source "(defn\n state-atom\n [this]\n (let\n  [sa ($ this :cljsState)]\n  (if-not (nil? sa) sa ($! this :cljsState (ratom/atom nil)))))\n"} {:sym fiber-component-path, :meta {:doc nil, :arglists ([fiber])}, :source "(defn\n fiber-component-path\n [fiber]\n (let\n  [name\n   (some-> fiber ($ :type) ($ :displayName))\n   parent\n   (some-> fiber ($ :return))\n   path\n   (some-> parent fiber-component-path (str \" > \"))\n   res\n   (str path name)]\n  (when-not (empty? res) res)))\n"} {:sym dash-to-camel, :meta {}, :source "(def dash-to-camel (util/memoize-1 util/dash-to-camel))\n"} {:sym reagent-component?, :meta {:doc nil, :arglists ([c])}, :source "(defn reagent-component? [c] (some? ($ c :reagentRender)))\n"} {:sym static-fns, :meta {}, :source "(def\n static-fns\n {:render\n  (fn\n   render\n   []\n   (this-as\n    c\n    (if\n     util/*non-reactive*\n     (do-render c)\n     (let\n      [rat ($ c :cljsRatom)]\n      (batch/mark-rendered c)\n      (if\n       (nil? rat)\n       (ratom/run-in-reaction\n        (fn* [] (do-render c))\n        c\n        \"cljsRatom\"\n        batch/queue-render\n        rat-opts)\n       (._run rat false))))))})\n"} {:sym as-class, :meta {:doc nil, :arglists ([tag])}, :source "(defn\n as-class\n [tag]\n (if-some\n  [cached-class (cached-react-class tag)]\n  cached-class\n  (fn-to-class tag)))\n"} {:sym reagent-class?, :meta {:doc nil, :arglists ([c])}, :source "(defn\n reagent-class?\n [c]\n (and (fn? c) (some? (some-> c .-prototype ($ :reagentRender)))))\n"} {:sym fn-to-class, :meta {:doc nil, :arglists ([f])}, :source "(defn\n fn-to-class\n [f]\n (assert-callable f)\n (warn-unless\n  (not (and (react-class? f) (not (reagent-class? f))))\n  \"Using native React classes directly in Hiccup forms \"\n  \"is not supported. Use create-element or \"\n  \"adapt-react-class instead: \"\n  (let [n (util/fun-name f)] (if (empty? n) f n))\n  (comp-name))\n (if\n  (reagent-class? f)\n  (cache-react-class f f)\n  (let\n   [spec\n    (meta f)\n    withrender\n    (assoc spec :reagent-render f)\n    res\n    (create-class withrender)]\n   (cache-react-class f res))))\n"} {:sym reactify-component, :meta {:doc nil, :arglists ([comp])}, :source "(defn\n reactify-component\n [comp]\n (if (react-class? comp) comp (as-class comp)))\n"} {:sym extract-children, :meta {:doc nil, :arglists ([v])}, :source "(defn\n extract-children\n [v]\n (let\n  [p (nth v 1 nil) first-child (if (or (nil? p) (map? p)) 2 1)]\n  (if (> (count v) first-child) (subvec v first-child))))\n"} {:sym component-path, :meta {:doc nil, :arglists ([c])}, :source "(defn\n component-path\n [c]\n (if-let\n  [fiber (some-> c ($ :_reactInternalFiber))]\n  (fiber-component-path fiber)\n  (let\n   [elem\n    (or\n     (some->\n      (or (some-> c ($ :_reactInternalInstance)) c)\n      ($ :_currentElement)))\n    name\n    (some-> elem ($ :type) ($ :displayName))\n    path\n    (some-> elem ($ :_owner) component-path (str \" > \"))\n    res\n    (str path name)]\n   (when-not (empty? res) res))))\n"} {:sym extract-props, :meta {:doc nil, :arglists ([v])}, :source "(defn extract-props [v] (let [p (nth v 1 nil)] (if (map? p) p)))\n"} {:sym get-children, :meta {:doc nil, :arglists ([c])}, :source "(defn\n get-children\n [c]\n (let\n  [p ($ c :props)]\n  (if-some\n   [v ($ p :argv)]\n   (extract-children v)\n   (->> ($ p :children) (react/Children.toArray) (into [])))))\n"} {:sym camelify-map-keys, :meta {:doc nil, :arglists ([fun-map])}, :source "(defn\n camelify-map-keys\n [fun-map]\n (reduce-kv\n  (fn [m k v] (assoc m (-> k dash-to-camel keyword) v))\n  {}\n  fun-map))\n"} {:sym shallow-obj-to-map, :meta {:doc nil, :arglists ([o])}, :source "(defn\n shallow-obj-to-map\n [o]\n (let\n  [ks (js-keys o) len (alength ks)]\n  (loop\n   [m {} i 0]\n   (if\n    (< i len)\n    (let\n     [k (aget ks i)]\n     (recur (assoc m (keyword k) (aget o k)) (inc i)))\n    m))))\n"} {:sym cljsify, :meta {:doc nil, :arglists ([body])}, :source "(defn\n cljsify\n [body]\n (-> body camelify-map-keys add-obligatory wrap-funs map-to-js))\n"} {:sym react-class?, :meta {:doc nil, :arglists ([c])}, :source "(defn\n react-class?\n [c]\n (and (fn? c) (some? (some-> c .-prototype ($ :render)))))\n"} {:sym cache-react-class, :meta {:doc nil, :arglists ([c constructor])}, :source "(defn\n cache-react-class\n [c constructor]\n ($! c :cljsReactClass constructor))\n"} {:sym custom-wrapper, :meta {:doc nil, :arglists ([key f])}, :source "(defn\n custom-wrapper\n [key f]\n (case\n  key\n  :getDefaultProps\n  (throw (js/Error. \"getDefaultProps not supported\"))\n  :getInitialState\n  (fn\n   getInitialState\n   []\n   (this-as c (reset! (state-atom c) (.call f c c))))\n  :componentWillReceiveProps\n  (fn\n   componentWillReceiveProps\n   [nextprops]\n   (this-as c (.call f c c (props-argv c nextprops))))\n  :shouldComponentUpdate\n  (fn\n   shouldComponentUpdate\n   [nextprops nextstate]\n   (or\n    util/*always-update*\n    (this-as\n     c\n     (let\n      [old-argv\n       ($ c :props.argv)\n       new-argv\n       ($ nextprops :argv)\n       noargv\n       (or (nil? old-argv) (nil? new-argv))]\n      (cond\n       (nil? f)\n       (or noargv (not= old-argv new-argv))\n       noargv\n       (.call f c c (get-argv c) (props-argv c nextprops))\n       :else\n       (.call f c c old-argv new-argv))))))\n  :componentWillUpdate\n  (fn\n   componentWillUpdate\n   [nextprops]\n   (this-as c (.call f c c (props-argv c nextprops))))\n  :componentDidUpdate\n  (fn\n   componentDidUpdate\n   [oldprops]\n   (this-as c (.call f c c (props-argv c oldprops))))\n  :componentWillMount\n  (fn\n   componentWillMount\n   []\n   (this-as\n    c\n    ($! c :cljsMountOrder (batch/next-mount-count))\n    (when-not (nil? f) (.call f c c))))\n  :componentDidMount\n  (fn componentDidMount [] (this-as c (.call f c c)))\n  :componentWillUnmount\n  (fn\n   componentWillUnmount\n   []\n   (this-as\n    c\n    (some-> ($ c :cljsRatom) ratom/dispose!)\n    (batch/mark-rendered c)\n    (when-not (nil? f) (.call f c c))))\n  :componentDidCatch\n  (fn\n   componentDidCatch\n   [error info]\n   (this-as c (.call f c c error info)))\n  nil))\n"} {:sym create-class, :meta {:doc nil, :arglists ([body])}, :source "(defn\n create-class\n [body]\n {:pre [(map? body)]}\n (->> body cljsify create-react-class))\n"} {:sym wrap-funs, :meta {:doc nil, :arglists ([fmap])}, :source "(defn\n wrap-funs\n [fmap]\n (when\n  (dev?)\n  (let\n   [renders\n    (select-keys fmap [:render :reagentRender :componentFunction])\n    render-fun\n    (-> renders vals first)]\n   (assert (pos? (count renders)) \"Missing reagent-render\")\n   (assert (== 1 (count renders)) \"Too many render functions supplied\")\n   (assert-callable render-fun)))\n (let\n  [render-fun\n   (or (:reagentRender fmap) (:componentFunction fmap))\n   legacy-render\n   (nil? render-fun)\n   render-fun\n   (or render-fun (:render fmap))\n   name\n   (str (or (:displayName fmap) (util/fun-name render-fun)))\n   name\n   (case name \"\" (str (gensym \"reagent\")) name)\n   fmap\n   (reduce-kv (fn [m k v] (assoc m k (get-wrapper k v name))) {} fmap)]\n  (assoc\n   fmap\n   :displayName\n   name\n   :autobind\n   false\n   :cljsLegacyRender\n   legacy-render\n   :reagentRender\n   render-fun\n   :render\n   (:render static-fns))))\n"}), paren-soup.instarepl ({:sym elem?, :meta {}, :source "(def elem? (fn* [p1__17504#] (instance? js/Element p1__17504#)))\n"} {:sym elems->locations, :meta {:doc "Returns the location of each elem.", :arglists ([elems top-offset])}, :source "(defn\n elems->locations\n \"Returns the location of each elem.\"\n [elems top-offset]\n (loop\n  [i 0 locations (transient [])]\n  (if-let\n   [elem (get elems i)]\n   (let\n    [top\n     (-> elem .-offsetTop (- top-offset))\n     height\n     (-> elem .-offsetHeight)]\n    (recur (inc i) (conj! locations {:top top, :height height})))\n   (persistent! locations))))\n"} {:sym results->html, :meta {:doc "Returns HTML for the given eval results.", :arglists ([results locations])}, :source "(defn\n results->html\n \"Returns HTML for the given eval results.\"\n [results locations]\n (loop\n  [i 0 evals (transient [])]\n  (let\n   [res (get results i) {:keys [top height]} (get locations i)]\n   (if\n    (and res top height)\n    (recur\n     (inc i)\n     (conj!\n      evals\n      (format\n       \"<div class='%s' style='top: %spx; height: %spx; min-height: %spx'>%s</div>\"\n       (if (array? res) \"result error\" \"result\")\n       top\n       height\n       height\n       (some-> (if (array? res) (first res) res) hs/escape-html-str))))\n    (join (persistent! evals))))))\n"} {:sym get-collections, :meta {:doc "Returns collections from the given DOM node.", :arglists ([element])}, :source "(defn\n get-collections\n \"Returns collections from the given DOM node.\"\n [element]\n (vec\n  (for\n   [elem\n    (-> element .-children array-seq)\n    :let\n    [classes (.-classList elem)]\n    :when\n    (or (.contains classes \"collection\") (.contains classes \"symbol\"))]\n   elem)))\n"} {:sym collection->content, :meta {:doc nil, :arglists ([elem])}, :source "(defn\n collection->content\n [elem]\n (loop\n  [e elem content (.-textContent elem)]\n  (if-let\n   [prev (.-previousSibling e)]\n   (if\n    (text-node? prev)\n    (recur prev (str (.-textContent prev) content))\n    content)\n   content)))\n"} {:sym create-compiler-fn, :meta {:doc nil, :arglists ([])}, :source "(defn\n create-compiler-fn\n []\n (try\n  (let\n   [eval-worker (js/Worker. \"paren-soup-compiler.js\")]\n   (fn\n    [coll receive-fn]\n    (set!\n     (.-onmessage eval-worker)\n     (fn* [p1__17505#] (receive-fn (vec (.-data p1__17505#)))))\n    (.postMessage eval-worker (into-array coll))))\n  (catch js/Error _ (fn [_ _] (throw js/Error \"Can't compile!\")))))\n"}), dynadoc.state ({:sym *state, :meta {}, :source "(defonce *state (atom {}))\n"}), oakcljs.tools.reader.impl.inspect ({:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists [[x] [truncate x]]}, :source "(defn\n inspect\n \"Return a string description of the value supplied.\\n   May be the a string version of the value itself (e.g. \\\"true\\\")\\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\\n   If truncate is true then return a very terse version of\\n   the inspection.\"\n ([x] (inspect* false x))\n ([truncate x] (inspect* truncate x)))\n"}), cljs.tools.reader.impl.utils ({:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :source "(defn\n reader-conditional\n \"Construct a data representation of a reader conditional.\\n  If true, splicing? indicates read-cond-splicing.\"\n [form splicing?]\n (ReaderConditional. splicing? form))\n"} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :source "(defn\n whitespace?\n \"Checks whether a given character is whitespace\"\n [ch]\n (when-not (nil? ch) (if (identical? ch \\,) true (.test ws-rx ch))))\n"} {:sym last-id, :meta {}, :source "(def last-id (atom 0))\n"} {:sym char, :meta {:doc nil, :arglists ([x])}, :source "(defn char [x] (when-not (nil? x) (cljs.core/char x)))\n"} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :source "(defn\n numeric?\n \"Checks whether a given character is numeric\"\n [ch]\n (when-not (nil? ch) (gstring/isNumeric ch)))\n"} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :source "(defn second' [[a b]] (when-not a b))\n"} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :source "(defn\n desugar-meta\n \"Resolves syntactical sugar in metadata\"\n [f]\n (cond\n  (keyword? f)\n  {f true}\n  (symbol? f)\n  {:tag f}\n  (string? f)\n  {:tag f}\n  :else\n  f))\n"} {:sym next-id, :meta {:doc nil, :arglists ([])}, :source "(defn next-id [] (swap! last-id inc))\n"} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :source "(defn ex-info? [ex] (instance? cljs.core.ExceptionInfo ex))\n"} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :source "(defn\n reader-conditional?\n \"Return true if the value is the data representation of a reader conditional\"\n [value]\n (instance? ReaderConditional value))\n"} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :source "(defn\n newline?\n \"Checks whether the character is a newline\"\n [c]\n (or (identical? \\newline c) (identical? \"\\n\" c) (nil? c)))\n"} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :source "(defn\n namespace-keys\n [ns keys]\n (for\n  [key keys]\n  (if\n   (or (symbol? key) (keyword? key))\n   (let\n    [[key-ns key-name]\n     ((juxt namespace name) key)\n     ->key\n     (if (symbol? key) symbol keyword)]\n    (cond\n     (nil? key-ns)\n     (->key ns key-name)\n     (= \"_\" key-ns)\n     (->key key-name)\n     :else\n     key))\n   key)))\n"} {:sym ws-rx, :meta {}, :source "(def ws-rx #\"[\\s]\")\n"}), basic-lein-cljs.core ({:sym clicks, :meta {:doc "Shows the number of times the user clicked the button.", :arglists ([button-text])}, :source "(defn\n clicks\n \"Shows the number of times the user clicked the button.\"\n [button-text]\n (let\n  [state (r/atom {:clicks 0})]\n  (fn\n   []\n   [:div\n    [:p \"You clicked \" (:clicks @state) \" times\"]\n    [:button\n     {:on-click (fn [] (swap! state update :clicks inc))}\n     button-text]])))\n", :examples [{:with-card card, :with-focus {:binding [:sym focus], :init-expr [clicks "Click me!"]}, :body (do (reagent.core/unmount-component-at-node card) (reagent.core/render-component focus card) nil), :body-str "[clicks \"Click me!\"]\n", :id "basic-lein-cljs.core/clicks/0"}]} {:sym get-lib-version, :meta {:doc "Queries Clojars for the version of the given library, providing it in a\n  callback. If it can't find it, the callback receives an error object.", :arglists ([lib-name callback])}, :source "(defn\n get-lib-version\n \"Queries Clojars for the version of the given library, providing it in a\\n  callback. If it can't find it, the callback receives an error object.\"\n [lib-name callback]\n (.send\n  XhrIo\n  (str \"https://clojars.org/api/artifacts/\" lib-name)\n  (fn\n   [e]\n   (callback\n    (or\n     (when\n      (.isSuccess (.-target e))\n      (->\n       e\n       .-target\n       .getResponseText\n       js/JSON.parse\n       (gobj/get \"latest_release\")))\n     (js/Error. (str \"Can't find version for: \" lib-name)))))\n  \"GET\"))\n", :examples [{:with-callback callback, :body (get-lib-version "dynadoc" callback), :body-str "(get-lib-version \"dynadoc\" callback)\n", :id "basic-lein-cljs.core/get-lib-version/0"}]}), oakcljs.tools.reader.reader-types ({:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n indexing-push-back-reader\n \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (indexing-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len] (indexing-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (IndexingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name)))\n"} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :source "(defn\n log-source*\n [reader f]\n (let\n  [buffer (:buffer @(.-frames reader))]\n  (try\n   (swap!\n    (.-frames reader)\n    update-in\n    [:offset]\n    conj\n    (.getLength buffer))\n   (let\n    [ret (f)]\n    (if\n     (implements? IMeta ret)\n     (merge-meta ret {:source (peek-source-log @(.-frames reader))})\n     ret))\n   (finally (swap! (.-frames reader) update-in [:offset] rest)))))\n"} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :source "(defn\n merge-meta\n \"Returns an object of the same type and value as `obj`, with its\\nmetadata merged over `m`.\"\n [obj m]\n (let\n  [orig-meta (meta obj)]\n  (with-meta obj (merge m (dissoc orig-meta :source)))))\n"} {:sym Reader, :meta {:doc nil}, :methods (peek-char read-char)} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n source-logging-push-back-reader\n \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (source-logging-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len]\n  (source-logging-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (SourceLoggingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name\n   (atom {:buffer (StringBuffer.), :offset '(0)}))))\n"} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :protocol IPushbackReader} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :protocol Reader} {:sym IPushbackReader, :meta {:doc nil}, :methods (unread)} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :source "(defn\n indexing-reader?\n \"Returns true if the reader satisfies IndexingReader\"\n [rdr]\n (implements? IndexingReader rdr))\n"} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists [[s]]}, :source "(defn\n string-reader\n \"Creates a StringReader from a given string\"\n ([s] (StringReader. s (count s) 0)))\n"} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :protocol Reader} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :protocol IndexingReader} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists [[rdr]]}, :source "(defn\n read-line\n \"Reads a line from the reader or from *in* if no reader is specified\"\n ([rdr]\n  (loop\n   [c (read-char rdr) s (StringBuffer.)]\n   (if (newline? c) (str s) (recur (read-char rdr) (.append s c))))))\n"} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists [[s] [s buf-len]]}, :source "(defn\n string-push-back-reader\n \"Creates a PushbackReader from a given string\"\n ([s] (string-push-back-reader s 1))\n ([s buf-len]\n  (PushbackReader.\n   (string-reader s)\n   (object-array buf-len)\n   buf-len\n   buf-len)))\n"} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :source "(defn\n line-start?\n \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n [rdr]\n (when (indexing-reader? rdr) (== 1 (get-column-number rdr))))\n"} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n source-logging-reader?\n [rdr]\n (instance? SourceLoggingPushbackReader rdr))\n"} {:sym IndexingReader, :meta {:doc nil}, :methods (get-column-number get-file-name get-line-number)} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :source "(defn\n node-readable-push-back-reader\n [readable]\n (PushbackReader.\n  (NodeReadableReader. readable nil)\n  (object-array 1)\n  1\n  1))\n"} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader}), cljs.source-map ({:sym update-result, :meta {:doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-result\n \"Helper for decode. Take a source map and update it based on a\\n  segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:line line, :col col, :source source}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [gline]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [gcol]\n      (fnil (fn* [p1__17525#] (conj p1__17525# d)) [])))\n    (sorted-map)))))\n"} {:sym invert-reverse-map, :meta {:doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :arglists ([reverse-map])}, :source "(defn\n invert-reverse-map\n \"Given a ClojureScript to JavaScript source map, invert it. Useful when\\n   mapping JavaScript stack traces when environment support is unavailable.\"\n [reverse-map]\n (let\n  [inverted (atom (sorted-map))]\n  (doseq\n   [[line columns] reverse-map]\n   (doseq\n    [[column column-info] columns]\n    (doseq\n     [{:keys [gline gcol name]} column-info]\n     (swap!\n      inverted\n      update-in\n      [gline]\n      (fnil\n       (fn\n        [columns]\n        (update-in\n         columns\n         [gcol]\n         (fnil conj [])\n         {:line line, :col column, :name name}))\n       (sorted-map))))))\n  @inverted))\n"} {:sym decode, :meta {:doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode\n \"Convert a v3 source map JSON object into a source map mapping\\n  generated JavaScript source locations to the original\\n  ClojureScript.\"\n ([source-map] (decode (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline 0 lines lines relseg relseg-init result {}]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym seg->map, :meta {:doc "Take a source map segment represented as a vector\n   and return a map.", :arglists ([seg source-map])}, :source "(defn\n seg->map\n \"Take a source map segment represented as a vector\\n   and return a map.\"\n [seg source-map]\n (let\n  [[gcol source line col name] seg]\n  {:gcol gcol,\n   :source (aget (gobj/get source-map \"sources\") source),\n   :line line,\n   :col col,\n   :name\n   (when-let\n    [name (-> seg meta :name)]\n    (aget (gobj/get source-map \"names\") name))}))\n"} {:sym source-compare, :meta {:doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :arglists ([sources])}, :source "(defn\n source-compare\n \"Take a seq of source file names and return a comparator\\n   that can be used to construct a sorted map. For reverse\\n   source maps.\"\n [sources]\n (let\n  [sources (indexed-sources sources)]\n  (fn [a b] (compare (sources a) (sources b)))))\n"} {:sym decode-reverse, :meta {:doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode-reverse\n \"Convert a v3 source map JSON object into a reverse source map\\n  mapping original ClojureScript source locations to the generated\\n  JavaScript.\"\n ([source-map]\n  (decode-reverse (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline\n     0\n     lines\n     lines\n     relseg\n     relseg-init\n     result\n     (sorted-map-by (source-compare sources))]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-reverse-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym lines->segs, :meta {:doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :arglists ([lines])}, :source "(defn\n lines->segs\n \"Take a nested sorted map encoding line and column information\\n   for a file and return a vector of vectors of encoded segments.\\n   Each vector represents a line, and the internal vectors are segments\\n   representing the contents of the line.\"\n [lines]\n (let\n  [relseg (atom [0 0 0 0 0])]\n  (reduce\n   (fn\n    [segs cols]\n    (swap!\n     relseg\n     (fn [[_ source line col name]] [0 source line col name]))\n    (conj\n     segs\n     (reduce\n      (fn\n       [cols [gcol sidx line col name :as seg]]\n       (let\n        [offset (map - seg @relseg)]\n        (swap!\n         relseg\n         (fn [[_ _ _ _ lname]] [gcol sidx line col (or name lname)]))\n        (conj cols (base64-vlq/encode offset))))\n      []\n      cols)))\n   []\n   lines)))\n"} {:sym merge-source-maps, :meta {:doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :arglists ([cljs-map js-map])}, :source "(defn\n merge-source-maps\n \"Merge an internal source map representation of a single\\n   ClojureScript file mapping original to generated with a\\n   second source map mapping original JS to generated JS.\\n   The is to support source maps that work through multiple\\n   compilation steps like Google Closure optimization passes.\"\n [cljs-map js-map]\n (loop\n  [line-map-seq (seq cljs-map) new-lines (sorted-map)]\n  (if\n   line-map-seq\n   (let\n    [[line col-map]\n     (first line-map-seq)\n     new-cols\n     (loop\n      [col-map-seq (seq col-map) new-cols (sorted-map)]\n      (if\n       col-map-seq\n       (let\n        [[col infos] (first col-map-seq)]\n        (recur\n         (next col-map-seq)\n         (assoc\n          new-cols\n          col\n          (reduce\n           (fn\n            [v {:keys [gline gcol]}]\n            (into v (get-in js-map [gline gcol])))\n           []\n           infos))))\n       new-cols))]\n    (recur (next line-map-seq) (assoc new-lines line new-cols)))\n   new-lines)))\n"} {:sym update-reverse-result, :meta {:doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-reverse-result\n \"Helper for decode-reverse. Take a reverse source map and\\n  update it with a segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:gline gline, :gcol gcol}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [source]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [line]\n      (fnil\n       (fn [m] (update-in m [col] (fnil (fn [v] (conj v d)) [])))\n       (sorted-map))))\n    (sorted-map)))))\n"} {:sym indexed-sources, :meta {:doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :arglists ([sources])}, :source "(defn\n indexed-sources\n \"Take a seq of source file names and return a map from\\n   file number to integer index. For reverse source maps.\"\n [sources]\n (->>\n  sources\n  (map-indexed (fn [a b] [a b]))\n  (reduce (fn [m [i v]] (assoc m v i)) {})))\n"} {:sym seg-combine, :meta {:doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :arglists ([seg relseg])}, :source "(defn\n seg-combine\n \"Combine a source map segment vector and a relative\\n   source map segment vector and combine them to get\\n   an absolute segment posititon information as a vector.\"\n [seg relseg]\n (let\n  [[gcol source line col name]\n   seg\n   [rgcol rsource rline rcol rname]\n   relseg\n   nseg\n   [(+ gcol rgcol)\n    (+ (or source 0) rsource)\n    (+ (or line 0) rline)\n    (+ (or col 0) rcol)\n    (+ (or name 0) rname)]]\n  (if name (with-meta nseg {:name (+ name rname)}) nseg)))\n"}), oakcljs.tools.reader.impl.commons ({:sym match-number, :meta {:doc nil, :arglists ([s])}, :source "(defn\n match-number\n [s]\n (if\n  (matches? int-pattern s)\n  (match-int s)\n  (if\n   (matches? float-pattern s)\n   (match-float s)\n   (when (matches? ratio-pattern s) (match-ratio s)))))\n"} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :source "(defn\n skip-line\n \"Advances the reader to the end of a line. Returns the reader\"\n [reader]\n (loop [] (when-not (newline? (read-char reader)) (recur)))\n reader)\n"} {:sym int-pattern, :meta {}, :source "(def\n int-pattern\n #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n"} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :source "(defn read-comment [rdr & _] (skip-line rdr))\n"} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :source "(defn\n parse-symbol\n \"Parses a string into a vector of the namespace and symbol\"\n [token]\n (when-not\n  (or\n   (identical? \"\" token)\n   (true? (.test #\":$\" token))\n   (true? (.test #\"^::\" token)))\n  (let\n   [ns-idx\n    (.indexOf token \"/\")\n    ns\n    (when (pos? ns-idx) (subs token 0 ns-idx))]\n   (if-not\n    (nil? ns)\n    (let\n     [ns-idx (inc ns-idx)]\n     (when-not\n      (== ns-idx (count token))\n      (let\n       [sym (subs token ns-idx)]\n       (when\n        (and\n         (not (numeric? (nth sym 0)))\n         (not (identical? \"\" sym))\n         (false? (.test #\":$\" ns))\n         (or (identical? sym \"/\") (== -1 (.indexOf sym \"/\"))))\n        [ns sym]))))\n    (when\n     (or (identical? token \"/\") (== -1 (.indexOf token \"/\")))\n     [nil token])))))\n"} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :source "(defn\n number-literal?\n \"Checks whether the reader is at the start of a number literal\"\n [reader initch]\n (or\n  (numeric? initch)\n  (and\n   (or (identical? \\+ initch) (identical? \\- initch))\n   (numeric? (peek-char reader)))))\n"} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :source "(defn\n read-past\n \"Read until first character that doesn't match pred, returning\\n   char.\"\n [pred rdr]\n (loop [ch (read-char rdr)] (if (pred ch) (recur (read-char rdr)) ch)))\n"} {:sym float-pattern, :meta {}, :source "(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n"} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :source "(defn\n matches?\n [pattern s]\n (let [[match] (re-find pattern s)] (identical? match s)))\n"} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :source "(defn throwing-reader [msg] (fn [rdr & _] (reader-error rdr msg)))\n"} {:sym ratio-pattern, :meta {}, :source "(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n"}), reagent.debug ({:sym has-console, :meta {}, :source "(def has-console (exists? js/console))\n"} {:sym tracking, :meta {}, :source "(def tracking false)\n"} {:sym warnings, :meta {}, :source "(defonce warnings (atom nil))\n"} {:sym track-warnings, :meta {:doc nil, :arglists ([f])}, :source "(defn\n track-warnings\n [f]\n (set! tracking true)\n (reset! warnings nil)\n (f)\n (let\n  [warns @warnings]\n  (reset! warnings nil)\n  (set! tracking false)\n  warns))\n"}), cljs.core.async.impl.ioc-helpers ({:sym EXCEPTION-FRAMES, :meta {}, :source "(def EXCEPTION-FRAMES 4)\n"} {:sym process-exception, :meta {:doc nil, :arglists ([state])}, :source "(defn\n process-exception\n [state]\n (let\n  [exception-frame\n   (aget-object state EXCEPTION-FRAMES)\n   catch-block\n   (:catch-block exception-frame)\n   catch-exception\n   (:catch-exception exception-frame)\n   exception\n   (aget-object state CURRENT-EXCEPTION)]\n  (cond\n   (and exception (not exception-frame))\n   (throw exception)\n   (and\n    exception\n    catch-block\n    (or\n     (= :default catch-exception)\n     (instance? catch-exception exception)))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    catch-block\n    VALUE-IDX\n    exception\n    CURRENT-EXCEPTION\n    nil\n    EXCEPTION-FRAMES\n    (assoc exception-frame :catch-block nil :catch-exception nil))\n   (and\n    exception\n    (not catch-block)\n    (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all! state EXCEPTION-FRAMES (:prev exception-frame))\n    (recur state))\n   (and exception (not catch-block) (:finally-block exception-frame))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    (:finally-block exception-frame)\n    EXCEPTION-FRAMES\n    (assoc exception-frame :finally-block nil))\n   (and (not exception) (:finally-block exception-frame))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:finally-block exception-frame)\n     EXCEPTION-FRAMES\n     (assoc exception-frame :finally-block nil)))\n   (and (not exception) (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:continue-block exception-frame)\n     EXCEPTION-FRAMES\n     (:prev exception-frame)))\n   :else\n   (throw (js/Error. \"No matching clause\")))))\n"} {:sym STATE-IDX, :meta {}, :source "(def STATE-IDX 1)\n"} {:sym aset-object, :meta {:doc nil, :arglists ([arr idx o])}, :source "(defn aset-object [arr idx o] (aget arr idx o))\n"} {:sym add-exception-frame, :meta {:doc nil, :arglists ([state catch-block catch-exception finally-block continue-block])}, :source "(defn\n add-exception-frame\n [state catch-block catch-exception finally-block continue-block]\n (ioc/aset-all!\n  state\n  EXCEPTION-FRAMES\n  (->ExceptionFrame\n   catch-block\n   catch-exception\n   finally-block\n   continue-block\n   (aget-object state EXCEPTION-FRAMES))))\n"} {:sym run-state-machine-wrapped, :meta {:doc nil, :arglists ([state])}, :source "(defn\n run-state-machine-wrapped\n [state]\n (try\n  (run-state-machine state)\n  (catch\n   js/Object\n   ex\n   (impl/close! (aget-object state USER-START-IDX))\n   (throw ex))))\n"} {:sym FN-IDX, :meta {}, :source "(def FN-IDX 0)\n"} {:sym aget-object, :meta {:doc nil, :arglists ([arr idx])}, :source "(defn aget-object [arr idx] (aget arr idx))\n"} {:sym return-chan, :meta {:doc nil, :arglists ([state value])}, :source "(defn\n return-chan\n [state value]\n (let\n  [c (aget state USER-START-IDX)]\n  (when-not (nil? value) (impl/put! c value (fn-handler (fn [] nil))))\n  (impl/close! c)\n  c))\n"} {:sym BINDINGS-IDX, :meta {}, :source "(def BINDINGS-IDX 3)\n"} {:sym CURRENT-EXCEPTION, :meta {}, :source "(def CURRENT-EXCEPTION 5)\n"} {:sym run-state-machine, :meta {:doc nil, :arglists ([state])}, :source "(defn run-state-machine [state] ((aget-object state FN-IDX) state))\n"} {:sym finished?, :meta {:doc "Returns true if the machine is in a finished state", :arglists ([state-array])}, :source "(defn\n finished?\n \"Returns true if the machine is in a finished state\"\n [state-array]\n (keyword-identical? (aget state-array STATE-IDX) :finished))\n"} {:sym USER-START-IDX, :meta {}, :source "(def USER-START-IDX 6)\n"} {:sym put!, :meta {:doc nil, :arglists ([state blk c val])}, :source "(defn\n put!\n [state blk c val]\n (if-let\n  [cb\n   (impl/put!\n    c\n    val\n    (fn-handler\n     (fn\n      [ret-val]\n      (ioc/aset-all! state VALUE-IDX ret-val STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym take!, :meta {:doc nil, :arglists ([state blk c])}, :source "(defn\n take!\n [state blk c]\n (if-let\n  [cb\n   (impl/take!\n    c\n    (fn-handler\n     (fn\n      [x]\n      (ioc/aset-all! state VALUE-IDX x STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym VALUE-IDX, :meta {}, :source "(def VALUE-IDX 2)\n"}), clojure.string ({:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :source "(defn\n ends-with?\n \"True if s ends with substr.\"\n [s substr]\n (gstring/endsWith s substr))\n"} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :source "(defn\n capitalize\n \"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"\n [s]\n (gstring/capitalize s))\n"} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :source "(defn\n reverse\n \"Returns s with its characters reversed.\"\n [s]\n (->\n  (.replace s re-surrogate-pair \"$2$1\")\n  (.. (split \"\") (reverse) (join \"\"))))\n"} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists [[coll] [separator coll]]}, :source "(defn\n join\n \"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"\n ([coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (recur (. sb (append (str (first coll)))) (next coll))\n    (.toString sb))))\n ([separator coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (do\n     (. sb (append (str (first coll))))\n     (let\n      [coll (next coll)]\n      (when-not (nil? coll) (. sb (append separator)))\n      (recur sb coll)))\n    (.toString sb)))))\n"} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace-first\n \"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (.replace s match replacement))\n"} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :source "(defn\n starts-with?\n \"True if s starts with substr.\"\n [s substr]\n (gstring/startsWith s substr))\n"} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :source "(defn\n escape\n \"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n [s cmap]\n (let\n  [buffer (StringBuffer.) length (.-length s)]\n  (loop\n   [index 0]\n   (if\n    (== length index)\n    (. buffer (toString))\n    (let\n     [ch (.charAt s index) replacement (get cmap ch)]\n     (if-not\n      (nil? replacement)\n      (.append buffer (str replacement))\n      (.append buffer ch))\n     (recur (inc index)))))))\n"} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n last-index-of\n \"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.lastIndexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.lastIndexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :source "(defn\n includes?\n \"True if s includes substr.\"\n [s substr]\n (gstring/contains s substr))\n"} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace\n \"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (cond\n  (string? match)\n  (.replace\n   s\n   (js/RegExp. (gstring/regExpEscape match) \"g\")\n   replacement)\n  (instance? js/RegExp match)\n  (if\n   (string? replacement)\n   (replace-all s match replacement)\n   (replace-all s match (replace-with replacement)))\n  :else\n  (throw (str \"Invalid match arg: \" match))))\n"} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :source "(defn split-lines \"Splits s on \\n or \\r\\n.\" [s] (split s #\"\\n|\\r\\n\"))\n"} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :source "(defn\n lower-case\n \"Converts string to all lower-case.\"\n [s]\n (.toLowerCase s))\n"} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :source "(defn\n trim-newline\n \"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"\n [s]\n (loop\n  [index (.-length s)]\n  (if\n   (zero? index)\n   \"\"\n   (let\n    [ch (get s (dec index))]\n    (if\n     (or (identical? \\newline ch) (identical? \\return ch))\n     (recur (dec index))\n     (.substring s 0 index))))))\n"} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :source "(defn\n upper-case\n \"Converts string to all upper-case.\"\n [s]\n (.toUpperCase s))\n"} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists [[s re] [s re limit]]}, :source "(defn\n split\n \"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n ([s re] (split s re 0))\n ([s re limit]\n  (discard-trailing-if-needed\n   limit\n   (if\n    (identical? \"/(?:)/\" (str re))\n    (split-with-empty-regex s limit)\n    (if\n     (< limit 1)\n     (vec (.split (str s) re))\n     (loop\n      [s s limit limit parts []]\n      (if\n       (== 1 limit)\n       (conj parts s)\n       (let\n        [m (re-find re s)]\n        (if-not\n         (nil? m)\n         (let\n          [index (.indexOf s m)]\n          (recur\n           (.substring s (+ index (count m)))\n           (dec limit)\n           (conj parts (.substring s 0 index))))\n         (conj parts s))))))))))\n"} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :source "(defn\n trimr\n \"Removes whitespace from the right side of string.\"\n [s]\n (gstring/trimRight s))\n"} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n index-of\n \"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.indexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.indexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :source "(defn\n trim\n \"Removes whitespace from both ends of string.\"\n [s]\n (gstring/trim s))\n"} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :source "(defn\n triml\n \"Removes whitespace from the left side of string.\"\n [s]\n (gstring/trimLeft s))\n"} {:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :source "(defn\n blank?\n \"True is s is nil, empty, or contains only whitespace.\"\n [s]\n (gstring/isEmptySafe s))\n"}), cljs.spec.alpha ({:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :source "(defn form \"returns the spec as data\" [spec] (describe* (specize spec)))\n"} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :source "(defn\n nilable-impl\n \"Do not call this directly, use 'nilable'\"\n [form pred gfn]\n (let\n  [spec (specize pred form)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (if (nil? x) nil (conform* spec x)))\n   (unform* [_ x] (if (nil? x) nil (unform* spec x)))\n   (explain*\n    [_ path via in x]\n    (when-not\n     (c/or (pvalid? spec x) (nil? x))\n     (conj\n      (explain-1 form pred (conj path :clojure.core/pred) via in x)\n      {:path (conj path :clojure.core/nil),\n       :pred 'nil?,\n       :val x,\n       :via via,\n       :in in})))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gen/frequency\n      [[1 (gen/delay (gen/return nil))]\n       [9\n        (gen/delay\n         (gensub\n          pred\n          overrides\n          (conj path :clojure.core/pred)\n          rmap\n          form))]])))\n   (with-gen* [_ gfn] (nilable-impl form pred gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nilable)\n       (clojure.core/list (s/mres form)))))))))\n"} {:sym *recursion-limit*, :meta {}, :source "(def\n *recursion-limit*\n \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\\n  can be recursed through during generation. After this a\\n  non-recursive branch will be chosen.\"\n 4)\n"} {:sym *coll-error-limit*, :meta {}, :source "(def\n *coll-error-limit*\n \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n 20)\n"} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :source "(defn\n explain-printer\n \"Default printer for explain-data. nil indicates a successful validation.\"\n [ed]\n (if\n  ed\n  (let\n   [problems\n    (sort-by\n     (fn* [p1__17544#] (- (count (:path p1__17544#))))\n     (:clojure.core/problems ed))]\n   (print\n    (with-out-str\n     (doseq\n      [{:keys [path pred val reason via in], :as prob} problems]\n      (when-not (empty? in) (print \"In:\" (pr-str in) \"\"))\n      (print \"val: \")\n      (pr val)\n      (print \" fails\")\n      (when-not (empty? via) (print \" spec:\" (pr-str (last via))))\n      (when-not (empty? path) (print \" at:\" (pr-str path)))\n      (print \" predicate: \")\n      (pr (abbrev pred))\n      (when reason (print \", \" reason))\n      (doseq\n       [[k v] prob]\n       (when-not\n        (#{:path :pred :via :val :reason :in} k)\n        (print \"\\n\\t\" (pr-str k) \" \")\n        (pr v)))\n      (newline))\n     (doseq\n      [[k v] ed]\n      (when-not\n       (#{:clojure.core/problems} k)\n       (print (pr-str k) \" \")\n       (pr v)\n       (newline))))))\n  (println \"Success!\")))\n"} {:sym Specize, :meta {:doc nil}, :methods (specize*)} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :source "(defn\n alt-impl\n \"Do not call this directly, use 'alt'\"\n [ks ps forms]\n (assoc (alt* ps ks forms) :id (random-uuid)))\n"} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :source "(defn\n def-impl\n \"Do not call this directly, use 'def'\"\n [k form spec]\n (assert\n  (c/and (ident? k) (namespace k))\n  \"k must be namespaced keyword or resolveable symbol\")\n (let\n  [spec\n   (if\n    (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n    spec\n    (spec-impl form spec nil nil))]\n  (swap! registry-ref assoc k (with-name spec k))\n  k))\n"} {:sym *explain-out*, :meta {}, :source "(def *explain-out* explain-printer)\n"} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :source "(defn\n regex-spec-impl\n \"Do not call this directly, use 'spec' with a regex op argument\"\n [re gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-conform re (seq x))\n    :clojure.core/invalid))\n  (unform* [_ x] (op-unform re x))\n  (explain*\n   [_ path via in x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-explain path via in re (seq x))\n    [{:path path, :pred (op-describe re), :val x, :via via, :in in}]))\n  (gen*\n   [_ overrides path rmap]\n   (if gfn (gfn) (re-gen re overrides path rmap (op-describe re))))\n  (with-gen* [_ gfn] (regex-spec-impl re gfn))\n  (describe* [_] (op-describe re))))\n"} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :source "(defn\n merge-spec-impl\n \"Do not call this directly, use 'merge'\"\n [forms preds gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (let\n    [ms\n     (map\n      (fn* [p1__17556# p2__17557#] (dt p1__17556# x p2__17557#))\n      preds\n      forms)]\n    (if (some invalid? ms) :clojure.core/invalid (apply c/merge ms))))\n  (unform*\n   [_ x]\n   (apply\n    c/merge\n    (map (fn* [p1__17558#] (unform p1__17558# x)) (reverse preds))))\n  (explain*\n   [_ path via in x]\n   (apply\n    concat\n    (map\n     (fn*\n      [p1__17559# p2__17560#]\n      (explain-1 p1__17559# p2__17560# path via in x))\n     forms\n     preds)))\n  (gen*\n   [_ overrides path rmap]\n   (if\n    gfn\n    (gfn)\n    (gen/fmap\n     (fn* [p1__17561#] (apply c/merge p1__17561#))\n     (apply\n      gen/tuple\n      (map\n       (fn*\n        [p1__17562# p2__17563#]\n        (gensub p1__17562# overrides path rmap p2__17563#))\n       preds\n       forms)))))\n  (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n  (describe*\n   [_]\n   (clojure.core/sequence\n    (clojure.core/seq\n     (clojure.core/concat\n      (clojure.core/list 'clojure.core/merge)\n      forms))))))\n"} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :source "(defn\n explain-data*\n [spec path via in x]\n (when-let\n  [probs (explain* (specize spec) path via in x)]\n  (when-not\n   (empty? probs)\n   {:clojure.core/problems probs,\n    :clojure.core/spec spec,\n    :clojure.core/value x})))\n"} {:sym MAX_INT, :meta {}, :source "(def MAX_INT 9007199254740991)\n"} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :source "(defn\n check-asserts\n \"Enable or disable spec asserts that have been compiled\\nwith '*compile-asserts*' true.  See 'assert'.\\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\\nDefaults to false.\"\n [flag]\n (set! *runtime-asserts* flag))\n"} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :source "(defn\n assert*\n \"Do not call this directly, use 'assert'.\"\n [spec x]\n (if\n  (valid? spec x)\n  x\n  (let\n   [ed\n    (c/merge\n     (assoc\n      (explain-data* spec [] [] [] x)\n      :clojure.core/failure\n      :assertion-failed))]\n   (throw\n    (js/Error.\n     (str\n      \"Spec assertion failed\\n\"\n      (with-out-str (explain-out ed))))))))\n"} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :source "(defn\n inst-in-range?\n \"Return true if inst at or after start and before end\"\n [start end inst]\n (c/and\n  (inst? inst)\n  (let\n   [t (inst-ms inst)]\n   (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n"} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :source "(defn\n and-spec-impl\n \"Do not call this directly, use 'and'\"\n [forms preds gfn]\n (let\n  [specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (conform* (specs 1) ret))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (let\n        [ret (conform* (specs 1) ret)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (conform* (specs 2) ret))))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [ret x i 0]\n       (if\n        (< i (count specs))\n        (let\n         [nret (conform* (specs i) ret)]\n         (if\n          (invalid? nret)\n          :clojure.core/invalid\n          (recur nret (inc i))))\n        ret)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform*\n    [_ x]\n    (reduce\n     (fn* [p1__17555# p2__17554#] (unform p2__17554# p1__17555#))\n     x\n     (reverse preds)))\n   (explain*\n    [_ path via in x]\n    (explain-pred-list forms preds path via in x))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gensub (first preds) overrides path rmap (first forms))))\n   (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/and)\n       forms)))))))\n"} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :protocol Spec} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :source "(defn\n map-spec-impl\n \"Do not call this directly, use 'spec' with a map argument\"\n [{:keys\n   [req-un\n    opt-un\n    keys-pred\n    pred-exprs\n    opt-keys\n    req-specs\n    req\n    req-keys\n    opt-specs\n    pred-forms\n    opt\n    gfn],\n   :as argm}]\n (let\n  [k->s\n   (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n   keys->specnames\n   (fn* [p1__17546#] (c/or (k->s p1__17546#) p1__17546#))\n   id\n   (random-uuid)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ m]\n    (if\n     (keys-pred m)\n     (let\n      [reg (registry)]\n      (loop\n       [ret m [[k v] & ks :as keys] m]\n       (if\n        keys\n        (let\n         [sname (keys->specnames k)]\n         (if-let\n          [s (get reg sname)]\n          (let\n           [cv (conform s v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (if (identical? cv v) ret (assoc ret k cv)) ks)))\n          (recur ret ks)))\n        ret)))\n     :clojure.core/invalid))\n   (unform*\n    [_ m]\n    (let\n     [reg (registry)]\n     (loop\n      [ret m [k & ks :as keys] (c/keys m)]\n      (if\n       keys\n       (if\n        (contains? reg (keys->specnames k))\n        (let\n         [cv (get m k) v (unform (keys->specnames k) cv)]\n         (recur (if (identical? cv v) ret (assoc ret k v)) ks))\n        (recur ret ks))\n       ret))))\n   (explain*\n    [_ path via in x]\n    (if-not\n     (map? x)\n     [{:path path, :pred 'map?, :val x, :via via, :in in}]\n     (let\n      [reg (registry)]\n      (apply\n       concat\n       (when-let\n        [probs\n         (->>\n          (map\n           (fn [pred form] (when-not (pred x) form))\n           pred-exprs\n           pred-forms)\n          (keep identity)\n          seq)]\n        (map\n         (fn*\n          [p1__17547#]\n          (identity\n           {:path path, :pred p1__17547#, :val x, :via via, :in in}))\n         probs))\n       (map\n        (fn\n         [[k v]]\n         (when-not\n          (c/or\n           (not (contains? reg (keys->specnames k)))\n           (pvalid? (keys->specnames k) v k))\n          (explain-1\n           (keys->specnames k)\n           (keys->specnames k)\n           (conj path k)\n           via\n           (conj in k)\n           v)))\n        (seq x))))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [rmap\n       (inck rmap id)\n       gen\n       (fn [k s] (gensub s overrides (conj path k) rmap k))\n       ogen\n       (fn\n        [k s]\n        (when-not\n         (recur-limit? rmap id path k)\n         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n       req-gens\n       (map gen req-keys req-specs)\n       opt-gens\n       (remove nil? (map ogen opt-keys opt-specs))]\n      (when\n       (every? identity (concat req-gens opt-gens))\n       (let\n        [reqs (zipmap req-keys req-gens) opts (into {} opt-gens)]\n        (gen/bind\n         (gen/choose 0 (count opts))\n         (fn*\n          [p1__17548#]\n          (let\n           [args\n            (concat (seq reqs) (when (seq opts) (shuffle (seq opts))))]\n           (->>\n            args\n            (take (c/+ p1__17548# (count reqs)))\n            (apply concat)\n            (apply gen/hash-map))))))))))\n   (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n   (describe*\n    [_]\n    (cons\n     'clojure.core/keys\n     (cond->\n      []\n      req\n      (conj :req req)\n      opt\n      (conj :opt opt)\n      req-un\n      (conj :req-un req-un)\n      opt-un\n      (conj :opt-un opt-un)))))))\n"} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :source "(defn\n explain\n \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n [spec x]\n (explain-out (explain-data spec x)))\n"} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :protocol Spec} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :source "(defn\n or-spec-impl\n \"Do not call this directly, use 'or'\"\n [keys forms preds gfn]\n (let\n  [id\n   (random-uuid)\n   kps\n   (zipmap keys preds)\n   specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         (let\n          [ret (conform* (specs 2) x)]\n          (if\n           (invalid? ret)\n           :clojure.core/invalid\n           (tagged-ret [(keys 2) ret])))\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [i 0]\n       (if\n        (< i (count specs))\n        (let\n         [spec (specs i)]\n         (let\n          [ret (conform* spec x)]\n          (if\n           (invalid? ret)\n           (recur (inc i))\n           (tagged-ret [(keys i) ret]))))\n        :clojure.core/invalid)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform* [_ [k x]] (unform (kps k) x))\n   (explain*\n    [this path via in x]\n    (when-not\n     (pvalid? this x)\n     (apply\n      concat\n      (map\n       (fn\n        [k form pred]\n        (when-not\n         (pvalid? pred x)\n         (explain-1 form pred (conj path k) via in x)))\n       keys\n       forms\n       preds))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [gen\n       (fn\n        [k p f]\n        (let\n         [rmap (inck rmap id)]\n         (when-not\n          (recur-limit? rmap id path k)\n          (gen/delay (gensub p overrides (conj path k) rmap f)))))\n       gs\n       (remove nil? (map gen keys preds forms))]\n      (when-not (empty? gs) (gen/one-of gs)))))\n   (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/or)\n       (mapcat vector keys forms))))))))\n"} {:sym *fspec-iterations*, :meta {}, :source "(def\n *fspec-iterations*\n \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n 21)\n"} {:sym Spec, :meta {:doc nil}, :methods (conform* describe* explain* gen* unform* with-gen*)} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :source "(defn\n unform\n \"Given a spec and a value created by or compliant with a call to\\n  'conform' with the same spec, returns a value with all conform\\n   destructuring undone.\"\n [spec x]\n (unform* (specize spec) x))\n"} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists [[spec x] [spec x form]]}, :source "(defn\n valid?\n \"Helper function that returns true when x is valid for spec.\"\n ([spec x]\n  (let [spec (specize spec)] (not (invalid? (conform* spec x)))))\n ([spec x form]\n  (let [spec (specize spec form)] (not (invalid? (conform* spec x))))))\n"} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists [[spec] [spec overrides]]}, :source "(defn\n gen\n \"Given a spec, returns the generator for it, or throws if none can\\n  be constructed. Optionally an overrides map can be provided which\\n  should map spec names or paths (vectors of keywords) to no-arg\\n  generator-creating fns. These will be used instead of the generators at those\\n  names/paths. Note that parent generator (in the spec or overrides\\n  map) will supersede those of any subtrees. A generator for a regex\\n  op must always return a sequential collection (i.e. a generator for\\n  s/? should return either an empty sequence/vector or a\\n  sequence/vector with one item in it)\"\n ([spec] (gen spec nil))\n ([spec overrides]\n  (gensub\n   spec\n   overrides\n   []\n   {:clojure.core/recursion-limit *recursion-limit*}\n   spec)))\n"} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :source "(defn\n nonconforming\n \"takes a spec and returns a spec that has the same properties except\\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n [spec]\n (let\n  [spec (specize spec)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ x]\n    (let\n     [ret (conform* spec x)]\n     (if (invalid? ret) :clojure.core/invalid x)))\n   (unform* [_ x] (unform* spec x))\n   (explain* [_ path via in x] (explain* spec path via in x))\n   (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n   (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nonconforming)\n       (clojure.core/list (describe* spec)))))))))\n"} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :protocol Spec} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :source "(defn\n abbrev\n [form]\n (cond\n  (seq? form)\n  (walk/postwalk\n   (fn\n    [form]\n    (cond\n     (c/and (symbol? form) (namespace form))\n     (-> form name symbol)\n     (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n     (last form)\n     :else\n     form))\n   form)\n  (c/and (symbol? form) (namespace form))\n  (-> form name symbol)\n  :else\n  form))\n"} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :source "(defn\n regex?\n \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n [x]\n (c/and (:clojure.core/op x) x))\n"} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :source "(defn\n int-in-range?\n \"Return true if start <= val, val < end and val is a fixed\\n  precision integer.\"\n [start end val]\n (cond\n  (integer? val)\n  (c/and (<= start val) (< val end))\n  (instance? goog.math.Long val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  (instance? goog.math.Integer val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  :else\n  false))\n"} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :source "(defn\n spec?\n \"returns x if x is a spec object, else logical false\"\n [x]\n (when (implements? Spec x) x))\n"} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :source "(defn\n registry\n \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n []\n @registry-ref)\n"} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :source "(defn\n rep+impl\n \"Do not call this directly, use '+'\"\n [form p]\n (pcat*\n  {:ps [p (rep* p p [] true form)],\n   :forms\n   (clojure.core/vec\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list form)\n       (clojure.core/list\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/*)\n           (clojure.core/list form))))))))),\n   :ret [],\n   :rep+ form}))\n"} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists [[spec] [spec n] [spec n overrides]]}, :source "(defn\n exercise\n \"generates a number (default 10) of values compatible with spec and maps conform over them,\\n  returning a sequence of [val conformed-val] tuples. Optionally takes\\n  a generator overrides map as per gen\"\n ([spec] (exercise spec 10))\n ([spec n] (exercise spec n nil))\n ([spec n overrides]\n  (map\n   (fn* [p1__17579#] (vector p1__17579# (conform spec p1__17579#)))\n   (gen/sample (gen spec overrides) n))))\n"} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :source "(defn\n explain-data\n \"Given a spec and a value x which ought to conform, returns nil if x\\n  conforms, else a map with at least the key ::problems whose value is\\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\\n  keys describing the predicate and the value that failed at that\\n  path.\"\n [spec x]\n (explain-data*\n  spec\n  []\n  (if-let [name (spec-name spec)] [name] [])\n  []\n  x))\n"} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists [[forms preds] [forms preds gfn]]}, :source "(defn\n tuple-impl\n \"Do not call this directly, use 'tuple'\"\n ([forms preds] (tuple-impl forms preds nil))\n ([forms preds gfn]\n  (let\n   [specs (delay (mapv specize preds forms)) cnt (count preds)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [specs @specs]\n      (if-not\n       (c/and (vector? x) (= (count x) cnt))\n       :clojure.core/invalid\n       (loop\n        [ret x i 0]\n        (if\n         (= i cnt)\n         ret\n         (let\n          [v (x i) cv (conform* (specs i) v)]\n          (if\n           (invalid? cv)\n           :clojure.core/invalid\n           (recur\n            (if (identical? cv v) ret (assoc ret i cv))\n            (inc i)))))))))\n    (unform*\n     [_ x]\n     (assert (c/and (vector? x) (= (count x) (count preds))))\n     (loop\n      [ret x i 0]\n      (if\n       (= i (count x))\n       ret\n       (let\n        [cv (x i) v (unform (preds i) cv)]\n        (recur (if (identical? cv v) ret (assoc ret i v)) (inc i))))))\n    (explain*\n     [_ path via in x]\n     (cond\n      (not (vector? x))\n      [{:path path, :pred 'vector?, :val x, :via via, :in in}]\n      (not= (count x) (count preds))\n      [{:path path,\n        :pred\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/=)\n           (clojure.core/list\n            (clojure.core/sequence\n             (clojure.core/seq\n              (clojure.core/concat\n               (clojure.core/list 'clojure.core/count)\n               (clojure.core/list '%)))))\n           (clojure.core/list (count preds))))),\n        :val x,\n        :via via,\n        :in in}]\n      :else\n      (apply\n       concat\n       (map\n        (fn\n         [i form pred]\n         (let\n          [v (x i)]\n          (when-not\n           (pvalid? pred v)\n           (explain-1 form pred (conj path i) via (conj in i) v))))\n        (range (count preds))\n        forms\n        preds))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn [i p f] (gensub p overrides (conj path i) rmap f))\n        gs\n        (map gen (range (count preds)) preds forms)]\n       (when (every? identity gs) (apply gen/tuple gs)))))\n    (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/tuple)\n        forms))))))))\n"} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists [[form mmvar retag] [form mmvar retag gfn]]}, :source "(defn\n multi-spec-impl\n \"Do not call this directly, use 'multi-spec'\"\n ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n ([form mmvar retag gfn]\n  (let\n   [id\n    (random-uuid)\n    predx\n    (fn*\n     [p1__17549#]\n     (let\n      [mm @mmvar]\n      (c/and\n       (-get-method mm ((-dispatch-fn mm) p1__17549#))\n       (mm p1__17549#))))\n    dval\n    (fn* [p1__17550#] ((-dispatch-fn @mmvar) p1__17550#))\n    tag\n    (if\n     (keyword? retag)\n     (fn* [p1__17551# p2__17552#] (assoc p1__17551# retag p2__17552#))\n     retag)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (if-let [pred (predx x)] (dt pred x form) :clojure.core/invalid))\n    (unform*\n     [_ x]\n     (if-let\n      [pred (predx x)]\n      (unform pred x)\n      (throw\n       (js/Error.\n        (str\n         \"No method of: \"\n         form\n         \" for dispatch value: \"\n         (dval x))))))\n    (explain*\n     [_ path via in x]\n     (let\n      [dv (dval x) path (conj path dv)]\n      (if-let\n       [pred (predx x)]\n       (explain-1 form pred path via in x)\n       [{:path path,\n         :pred form,\n         :val x,\n         :reason \"no method\",\n         :via via,\n         :in in}])))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn\n         [[k f]]\n         (let\n          [p (f nil)]\n          (let\n           [rmap (inck rmap id)]\n           (when-not\n            (recur-limit? rmap id path k)\n            (gen/delay\n             (gen/fmap\n              (fn* [p1__17553#] (tag p1__17553# k))\n              (gensub\n               p\n               overrides\n               (conj path k)\n               rmap\n               (list 'method form k))))))))\n        gs\n        (->>\n         (methods @mmvar)\n         (remove (fn [[k]] (invalid? k)))\n         (map gen)\n         (remove nil?))]\n       (when (every? identity gs) (gen/one-of gs)))))\n    (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/multi-spec)\n        (clojure.core/list form)\n        (clojure.core/list retag)))))))))\n"} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :source "(defn\n conform\n \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\\n  not match spec, else the (possibly destructured) value.\"\n [spec x]\n (conform* (specize spec) x))\n"} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :protocol Spec} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :source "(defn\n fspec-impl\n \"Do not call this directly, use 'fspec'\"\n [argspec aform retspec rform fnspec fform gfn]\n (let\n  [specs {:args argspec, :ret retspec, :fn fnspec}]\n  (reify\n   ILookup\n   (-lookup [this k] (get specs k))\n   (-lookup [_ k not-found] (get specs k not-found))\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ f]\n    (if\n     (ifn? f)\n     (if\n      (identical? f (validate-fn f specs *fspec-iterations*))\n      f\n      :clojure.core/invalid)\n     :clojure.core/invalid))\n   (unform* [_ f] f)\n   (explain*\n    [_ path via in f]\n    (if\n     (ifn? f)\n     (let\n      [args (validate-fn f specs 100)]\n      (if\n       (identical? f args)\n       nil\n       (let\n        [ret (try (apply f args) (catch js/Error t t))]\n        (if\n         (instance? js/Error ret)\n         [{:path path,\n           :pred '(apply fn),\n           :val args,\n           :reason (.-message ret),\n           :via via,\n           :in in}]\n         (let\n          [cret (dt retspec ret rform)]\n          (if\n           (invalid? cret)\n           (explain-1 rform retspec (conj path :ret) via in ret)\n           (when\n            fnspec\n            (let\n             [cargs (conform argspec args)]\n             (explain-1\n              fform\n              fnspec\n              (conj path :fn)\n              via\n              in\n              {:args cargs, :ret cret})))))))))\n     [{:path path, :pred 'ifn?, :val f, :via via, :in in}]))\n   (gen*\n    [_ overrides _ _]\n    (if\n     gfn\n     (gfn)\n     (gen/return\n      (fn\n       [& args]\n       (assert\n        (pvalid? argspec args)\n        (with-out-str (explain argspec args)))\n       (gen/generate (gen retspec overrides))))))\n   (with-gen*\n    [_ gfn]\n    (fspec-impl argspec aform retspec rform fnspec fform gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/fspec)\n       (clojure.core/list :args)\n       (clojure.core/list aform)\n       (clojure.core/list :ret)\n       (clojure.core/list rform)\n       (clojure.core/list :fn)\n       (clojure.core/list fform))))))))\n"} {:sym *coll-check-limit*, :meta {}, :source "(def\n *coll-check-limit*\n \"The number of items validated in a collection spec'ed with 'every'\"\n 101)\n"} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :source "(defn\n get-spec\n \"Returns spec registered for keyword/symbol/var k, or nil.\"\n [k]\n (get (registry) (if (keyword? k) k (->sym k))))\n"} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists [[form pred opts] [form pred {gen-into :into, describe-form :clojure.core/describe, :keys [kind :clojure.core/kind-form count max-count min-count distinct gen-max :clojure.core/kfn :clojure.core/cpred conform-keys :clojure.core/conform-all], :or {gen-max 20}, :as opts} gfn]]}, :source "(defn\n every-impl\n \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n ([form pred opts] (every-impl form pred opts nil))\n ([form\n   pred\n   {gen-into :into,\n    describe-form :clojure.core/describe,\n    :keys\n    [kind\n     :clojure.core/kind-form\n     count\n     max-count\n     min-count\n     distinct\n     gen-max\n     :clojure.core/kfn\n     :clojure.core/cpred\n     conform-keys\n     :clojure.core/conform-all],\n    :or {gen-max 20},\n    :as opts}\n   gfn]\n  (let\n   [conform-into\n    gen-into\n    spec\n    (delay (specize pred))\n    check?\n    (fn* [p1__17564#] (valid? @spec p1__17564#))\n    kfn\n    (c/or kfn (fn [i v] i))\n    addcv\n    (fn [ret i v cv] (conj ret cv))\n    cfns\n    (fn\n     [x]\n     (cond\n      (c/and\n       (vector? x)\n       (c/or (not conform-into) (vector? conform-into)))\n      [identity\n       (fn [ret i v cv] (if (identical? v cv) ret (assoc ret i cv)))\n       identity]\n      (c/and\n       (map? x)\n       (c/or (c/and kind (not conform-into)) (map? conform-into)))\n      [(if conform-keys empty identity)\n       (fn\n        [ret i v cv]\n        (if\n         (c/and (identical? v cv) (not conform-keys))\n         ret\n         (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n       identity]\n      (c/or\n       (list? conform-into)\n       (seq? conform-into)\n       (c/and (not conform-into) (c/or (list? x) (seq? x))))\n      [empty addcv reverse]\n      :else\n      [(fn* [p1__17565#] (empty (c/or conform-into p1__17565#)))\n       addcv\n       identity]))]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [spec @spec]\n      (cond\n       (not (cpred x))\n       :clojure.core/invalid\n       conform-all\n       (let\n        [[init add complete] (cfns x)]\n        (loop\n         [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n         (if\n          vseq\n          (let\n           [cv (conform* spec v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (add ret i v cv) (inc i) vs)))\n          (complete ret))))\n       :else\n       (if\n        (indexed? x)\n        (let\n         [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n         (loop\n          [i 0]\n          (if\n           (>= i (c/count x))\n           x\n           (if\n            (valid? spec (nth x i))\n            (recur (c/+ i step))\n            :clojure.core/invalid))))\n        (let\n         [limit *coll-check-limit*]\n         (loop\n          [i 0 [v & vs :as vseq] (seq x)]\n          (cond\n           (c/or (nil? vseq) (= i limit))\n           x\n           (valid? spec v)\n           (recur (inc i) vs)\n           :else\n           :clojure.core/invalid)))))))\n    (unform*\n     [_ x]\n     (if\n      conform-all\n      (let\n       [spec @spec [init add complete] (cfns x)]\n       (loop\n        [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n        (if\n         (>= i (c/count x))\n         (complete ret)\n         (recur (add ret i v (unform* spec v)) (inc i) vs))))\n      x))\n    (explain*\n     [_ path via in x]\n     (c/or\n      (coll-prob\n       x\n       kind\n       kind-form\n       distinct\n       count\n       min-count\n       max-count\n       path\n       via\n       in)\n      (apply\n       concat\n       ((if conform-all identity (partial take *coll-error-limit*))\n        (keep\n         identity\n         (map\n          (fn\n           [i v]\n           (let\n            [k (kfn i v)]\n            (when-not\n             (check? v)\n             (let\n              [prob (explain-1 form pred path via (conj in k) v)]\n              prob))))\n          (range)\n          x))))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [pgen (gensub pred overrides path rmap form)]\n       (gen/bind\n        (cond\n         gen-into\n         (gen/return (empty gen-into))\n         kind\n         (gen/fmap\n          (fn*\n           [p1__17566#]\n           (if (empty? p1__17566#) p1__17566# (empty p1__17566#)))\n          (gensub kind overrides path rmap form))\n         :else\n         (gen/return []))\n        (fn\n         [init]\n         (gen/fmap\n          (fn*\n           [p1__17567#]\n           (if (vector? init) p1__17567# (into init p1__17567#)))\n          (cond\n           distinct\n           (if\n            count\n            (gen/vector-distinct\n             pgen\n             {:num-elements count, :max-tries 100})\n            (gen/vector-distinct\n             pgen\n             {:min-elements (c/or min-count 0),\n              :max-elements\n              (c/or\n               max-count\n               (max gen-max (c/* 2 (c/or min-count 0)))),\n              :max-tries 100}))\n           count\n           (gen/vector pgen count)\n           (c/or min-count max-count)\n           (gen/vector\n            pgen\n            (c/or min-count 0)\n            (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n           :else\n           (gen/vector pgen 0 gen-max))))))))\n    (with-gen* [_ gfn] (every-impl form pred opts gfn))\n    (describe*\n     [_]\n     (c/or\n      describe-form\n      (clojure.core/sequence\n       (clojure.core/seq\n        (clojure.core/concat\n         (clojure.core/list 'clojure.core/every)\n         (clojure.core/list (s/mres form))\n         (mapcat identity opts))))))))))\n"} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists [[form pred gfn cpred?] [form pred gfn cpred? unc]]}, :source "(defn\n spec-impl\n \"Do not call this directly, use 'spec'\"\n ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n ([form pred gfn cpred? unc]\n  (cond\n   (spec? pred)\n   (cond-> pred gfn (with-gen gfn))\n   (regex? pred)\n   (regex-spec-impl pred gfn)\n   (ident? pred)\n   (cond-> (the-spec pred) gfn (with-gen gfn))\n   :else\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [ret (pred x)]\n      (if cpred? ret (if ret x :clojure.core/invalid))))\n    (unform*\n     [_ x]\n     (if\n      cpred?\n      (if unc (unc x) (throw (js/Error. \"no unform fn for conformer\")))\n      x))\n    (explain*\n     [_ path via in x]\n     (when\n      (invalid? (dt pred x form cpred?))\n      [{:path path, :pred form, :val x, :via via, :in in}]))\n    (gen* [_ _ _ _] (if gfn (gfn) (gen/gen-for-pred pred)))\n    (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n    (describe* [_] form)))))\n"} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :source "(defn\n invalid?\n \"tests the validity of a conform return value\"\n [ret]\n (keyword-identical? :clojure.core/invalid ret))\n"} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :source "(defn\n amp-impl\n \"Do not call this directly, use '&'\"\n [re preds pred-forms]\n {:clojure.core/op :clojure.core/amp,\n  :p1 re,\n  :ps preds,\n  :forms pred-forms})\n"} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :source "(defn\n cat-impl\n \"Do not call this directly, use 'cat'\"\n [ks ps forms]\n (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n"} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :source "(defn\n explain-str\n \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n [spec x]\n (with-out-str (explain spec x)))\n"} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."}, :source "(defonce *compile-asserts* (s/init-compile-asserts))\n"} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :source "(defn\n with-gen\n \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n [spec gen-fn]\n (let\n  [spec (reg-resolve spec)]\n  (if\n   (regex? spec)\n   (assoc spec :clojure.core/gfn gen-fn)\n   (with-gen* (specize spec) gen-fn))))\n"} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :protocol Spec} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :source "(defn\n check-asserts?\n \"Returns the value set by check-asserts.\"\n []\n *runtime-asserts*)\n"} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :source "(defn\n rep-impl\n \"Do not call this directly, use '*'\"\n [form p]\n (rep* p p [] false form))\n"} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :source "(defn\n describe\n \"returns an abbreviated description of the spec as data\"\n [spec]\n (abbrev (form spec)))\n"} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :source "(defn\n explain-out\n \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\\n    by default explain-printer.\"\n [ed]\n (*explain-out* ed))\n"} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :protocol Specize} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :source "(defn\n maybe-impl\n \"Do not call this directly, use '?'\"\n [p form]\n (assoc\n  (alt* [p (accept :clojure.core/nil)] nil [form :clojure.core/nil])\n  :maybe\n  form))\n"} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :protocol Spec}), cljs.reader ({:sym *default-data-reader-fn*, :meta {}, :source "(def *default-data-reader-fn* (atom nil))\n"} {:sym read, :meta {:doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader]\n  (edn/read\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   reader))\n ([{:keys [eof], :as opts} reader]\n  (edn/read\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   reader))\n ([reader eof-error? eof opts]\n  (edn/read\n   reader\n   eof-error?\n   eof\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m))))))\n"} {:sym *tag-table*, :meta {}, :source "(def\n *tag-table*\n (atom\n  (add-data-readers\n   {'inst read-date, 'uuid read-uuid, 'queue read-queue, 'js read-js})))\n"} {:sym parse-and-validate-timestamp, :meta {:doc nil, :arglists ([s])}, :source "(defn\n parse-and-validate-timestamp\n [s]\n (let\n  [[_\n    years\n    months\n    days\n    hours\n    minutes\n    seconds\n    fraction\n    offset-sign\n    offset-hours\n    offset-minutes\n    :as\n    v]\n   (re-matches timestamp-regex s)]\n  (if-not\n   v\n   (throw (js/Error. (str \"Unrecognized date/time syntax: \" s)))\n   (let\n    [years\n     (parse-int years)\n     months\n     (or (parse-int months) 1)\n     days\n     (or (parse-int days) 1)\n     hours\n     (or (parse-int hours) 0)\n     minutes\n     (or (parse-int minutes) 0)\n     seconds\n     (or (parse-int seconds) 0)\n     fraction\n     (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n     offset-sign\n     (if (= offset-sign \"-\") -1 1)\n     offset-hours\n     (or (parse-int offset-hours) 0)\n     offset-minutes\n     (or (parse-int offset-minutes) 0)\n     offset\n     (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n    [years\n     (check 1 months 12 \"timestamp month field must be in range 1..12\")\n     (check\n      1\n      days\n      (days-in-month months (leap-year? years))\n      \"timestamp day field must be in range 1..last day in month\")\n     (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n     (check\n      0\n      minutes\n      59\n      \"timestamp minute field must be in range 0..59\")\n     (check\n      0\n      seconds\n      (if (= minutes 59) 60 59)\n      \"timestamp second field must be in range 0..60\")\n     (check\n      0\n      fraction\n      999\n      \"timestamp millisecond field must be in range 0..999\")\n     offset]))))\n"} {:sym register-tag-parser!, :meta {:doc nil, :arglists ([tag f])}, :source "(defn\n register-tag-parser!\n [tag f]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* assoc tag f)\n  old-parser))\n"} {:sym register-default-tag-parser!, :meta {:doc nil, :arglists ([f])}, :source "(defn\n register-default-tag-parser!\n [f]\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] f))\n  old-parser))\n"} {:sym deregister-default-tag-parser!, :meta {:doc nil, :arglists ([])}, :source "(defn\n deregister-default-tag-parser!\n []\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] nil))\n  old-parser))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per cljs.tools.reader.edn/read\"\n ([s]\n  (edn/read-string\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   s))\n ([opts s]\n  (edn/read-string\n   (update\n    (merge {:default @*default-data-reader-fn*} opts)\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   s)))\n"} {:sym deregister-tag-parser!, :meta {:doc nil, :arglists ([tag])}, :source "(defn\n deregister-tag-parser!\n [tag]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* dissoc tag)\n  old-parser))\n"} {:sym parse-timestamp, :meta {:doc nil, :arglists ([ts])}, :source "(defn\n parse-timestamp\n [ts]\n (if-let\n  [[years months days hours minutes seconds ms offset]\n   (parse-and-validate-timestamp ts)]\n  (js/Date.\n   (-\n    (.UTC js/Date years (dec months) days hours minutes seconds ms)\n    (* offset 60 1000)))\n  (throw (js/Error. (str \"Unrecognized date/time syntax: \" ts)))))\n"}), clojure.walk ({:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :source "(defn\n walk\n \"Traverses form, an arbitrary data structure.  inner and outer are\\n  functions.  Applies inner to each element of form, building up a\\n  data structure of the same type, then applies outer to the result.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [inner outer form]\n (cond\n  (list? form)\n  (outer (apply list (map inner form)))\n  (seq? form)\n  (outer (doall (map inner form)))\n  (record? form)\n  (outer (reduce (fn [r x] (conj r (inner x))) form form))\n  (coll? form)\n  (outer (into (empty form) (map inner form)))\n  :else\n  (outer form)))\n"} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :source "(defn\n postwalk\n \"Performs a depth-first, post-order traversal of form.  Calls f on\\n  each sub-form, uses f's return value in place of the original.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial postwalk f) f form))\n"} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :source "(defn\n prewalk\n \"Like postwalk, but does pre-order traversal.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial prewalk f) identity (f form)))\n"} {:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :source "(defn\n keywordize-keys\n \"Recursively transforms all map keys from strings to keywords.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :source "(defn\n stringify-keys\n \"Recursively transforms all map keys from keywords to strings.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :source "(defn\n prewalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the root of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :source "(defn\n postwalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the leaves of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"}), cljs.core.async.impl.timers ({:sym MAX_LEVEL, :meta {}, :source "(def MAX_LEVEL 15)\n"} {:sym P, :meta {}, :source "(def P (/ 1 2))\n"} {:sym random-level, :meta {:doc nil, :arglists [[] [level]]}, :source "(defn\n random-level\n ([] (random-level 0))\n ([level]\n  (if\n   (and (< (.random js/Math) P) (< level MAX_LEVEL))\n   (recur (inc level))\n   level)))\n"} {:sym skip-list-node, :meta {:doc nil, :arglists [[level] [k v level]]}, :source "(defn\n skip-list-node\n ([level] (skip-list-node nil nil level))\n ([k v level]\n  (let\n   [arr (make-array (inc level))]\n   (loop\n    [i 0]\n    (when (< i (alength arr)) (aset arr i nil) (recur (inc i))))\n   (SkipListNode. k v arr))))\n"} {:sym least-greater-node, :meta {:doc nil, :arglists [[x k level] [x k level update]]}, :source "(defn\n least-greater-node\n ([x k level] (least-greater-node x k level nil))\n ([x k level update]\n  (if-not\n   (neg? level)\n   (let\n    [x\n     (loop\n      [x x]\n      (if-let\n       [x' (aget (.-forward x) level)]\n       (if (< (.-key x') k) (recur x') x)\n       x))]\n    (when-not (nil? update) (aset update level x))\n    (recur x k (dec level) update))\n   x)))\n"} {:sym skip-list, :meta {:doc nil, :arglists ([])}, :source "(defn skip-list [] (SkipList. (skip-list-node 0) 0))\n"} {:sym timeouts-map, :meta {}, :source "(def timeouts-map (skip-list))\n"} {:sym TIMEOUT_RESOLUTION_MS, :meta {}, :source "(def TIMEOUT_RESOLUTION_MS 10)\n"} {:sym timeout, :meta {:doc "returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"returns a channel that will close after msecs\"\n [msecs]\n (let\n  [timeout\n   (+ (.valueOf (js/Date.)) msecs)\n   me\n   (.ceilingEntry timeouts-map timeout)]\n  (or\n   (when\n    (and me (< (.-key me) (+ timeout TIMEOUT_RESOLUTION_MS)))\n    (.-val me))\n   (let\n    [timeout-channel (channels/chan nil)]\n    (.put timeouts-map timeout timeout-channel)\n    (dispatch/queue-delay\n     (fn\n      []\n      (.remove timeouts-map timeout)\n      (impl/close! timeout-channel))\n     msecs)\n    timeout-channel))))\n"}), reagent.dom ({:sym render, :meta {:doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element. The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance.", :arglists [[comp container] [comp container callback]]}, :source "(defn\n render\n \"Render a Reagent component into the DOM. The first argument may be\\n  either a vector (using Reagent's Hiccup syntax), or a React element. The second argument should be a DOM node.\\n\\n  Optionally takes a callback that is called when the component is in place.\\n\\n  Returns the mounted component instance.\"\n ([comp container] (render comp container nil))\n ([comp container callback]\n  (ratom/flush!)\n  (let\n   [f (fn [] (tmpl/as-element (if (fn? comp) (comp) comp)))]\n   (render-comp f container callback))))\n"} {:sym unmount-component-at-node, :meta {:doc nil, :arglists ([container])}, :source "(defn unmount-component-at-node [container] (unmount-comp container))\n"} {:sym dom-node, :meta {:doc "Returns the root DOM node of a mounted component.", :arglists ([this])}, :source "(defn\n dom-node\n \"Returns the root DOM node of a mounted component.\"\n [this]\n (react-dom/findDOMNode this))\n"} {:sym force-update-all, :meta {:doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead.", :arglists ([])}, :source "(defn\n force-update-all\n \"Force re-rendering of all mounted Reagent components. This is\\n  probably only useful in a development environment, when you want to\\n  update components in response to some dynamic changes to code.\\n\\n  Note that force-update-all may not update root components. This\\n  happens if a component 'foo' is mounted with `(render [foo])` (since\\n  functions are passed by value, and not by reference, in\\n  ClojureScript). To get around this you'll have to introduce a layer\\n  of indirection, for example by using `(render [#'foo])` instead.\"\n []\n (ratom/flush!)\n (doseq [v (vals @roots)] (apply re-render-component v))\n \"Updated\")\n"}), cljs.spec.gen.alpha ({:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :source "(defn quick-check [& args] (apply @quick-check-ref args))\n"} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :source "(defn\n for-all*\n \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n [& args]\n (apply @for-all*-ref args))\n"} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :source "(defn\n delay-impl\n [gfnd]\n (generator (fn [rnd size] ((:gen @gfnd) rnd size))))\n"} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :source "(defn\n cat\n \"Returns a generator of a sequence catenated from results of\\ngens, each of which should generate something sequential.\"\n [& gens]\n (fmap (fn* [p1__17540#] (apply concat p1__17540#)) (apply tuple gens)))\n"} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :source "(defn\n gen-for-pred\n \"Given a predicate, returns a built-in generator if one exists.\"\n [pred]\n (if (set? pred) (elements pred) (get @gen-builtins pred)))\n"})}, :nses ({:var-syms [clicks get-lib-version], :type :cljs, :sym basic-lein-cljs.core} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [sort-by ITransientAssociative chunk-first m3-hash-int pr-str* tree-seq unchecked-remainder-int seq reduce contains? every? keep-indexed subs IFind MODULE_URIS take-last bit-set string-hash-cache-count qualified-keyword? -with-meta unchecked-subtract-int -iterator *print-namespace-maps* first native-satisfies? seq? -sorted-seq-from inst-ms iterate -empty ILookup -chunked-rest fn? -assoc keyword-identical? *print-err-fn* dissoc atom bit-shift-right *clojurescript-version* -first peek IKVReduce aget -write iter last namespace -conj = ITransientMap take vector? boolean IChunk bit-shift-left any? aclone vreset! chunk dec APersistentVector map < rest -drop-first boolean? -clone char? -reduce -count swap-vals! keep char mapcat unchecked-long m3-seed some? unchecked-negate symbol-identical? *command-line-args* reverse inst? bit-count sort unchecked-inc-int -compare map-indexed comp array-chunk bit-shift-right-zero-fill -as-transient simple-symbol? IIndexed disj IPrintWithWriter IVector IIterable cons floats pos? fnil nthrest *warn-on-infer* -find sequential? m3-mix-H1 prim-seq *print-level* shuffle hash-keyword find alength bit-xor unsigned-bit-shift-right neg? js-invoke m3-mix-K1 unchecked-float undefined? IMeta reduced? disj! -lookup float? ICloneable booleans int-array set? iterable? -pr-writer take-while vary-meta INext is_proto_ ICounted IMapEntry <= MODULE_INFOS conj! -pop repeatedly reset-vals! IStack -remove-watch IVolatile remove * min -persistent! -nth pop! chunk-append *unchecked-arrays* IReversible reversible? -realized? -add-watch -deref-with-timeout conj -sorted-seq transduce -swap! *print-length* js-delete truth_ compare-and-set! array-seq interleave map? m3-C1 get identity into long double volatile? -key nfirst meta -kv-reduce IHash bit-and-not var? -comparator unchecked-add-int hash-ordered-coll IEquiv cycle -deref empty? short -chunked-first filterv hash quot unchecked-double ranged-iterator ITransientVector longs not= set-print-err-fn! string? es6-iterator m3-C2 *print-newline* unchecked-multiply-int chunk-rest double? vec *print-meta* -notify-watches int second IEditableCollection hash-combine > -name int? associative? unchecked-int js-keys inst-ms* keyword? array-iter -rseq unchecked-multiply even? es6-iterator-seq unchecked-dec Inst double-array spread rseq IReset IEmptyableCollection *print-fn-bodies* float IRecord concat IDerefWithTimeout symbol to-array-2d mod ISet pop IPending -entry-key dissoc! indexed? - -equiv assoc! reduce-kv reset! Fn ffirst counted? assoc-in bit-test ISwap zero? simple-keyword? *main-cli-fn* -assoc-n unchecked-dec-int persistent! set-print-fn! nnext not-every? rem ifind? some INamed IReduce neg-int? drop js-obj ITransientCollection nth sorted? nil? split-at not-native bit-and bounded-count update list* update-in ensure-reduced instance? mix-collection-hash unchecked-add transformer-iterator not -vreset! with-meta unreduced record? type identical? -namespace unchecked-divide-int *out* hash-string set-validator! ident? -meta swap! -chunked-next unchecked-subtract IMap cloneable? qualified-ident? hash-string* true? array -peek ISeq empty volatile! / bit-or m3-fmix vector >= drop-last object? not-empty partition DEMUNGE_PATTERN IAssociative bit-flip long-array ISeqable js-mod integer? mapv infinite? ISequential equiv-map object-array seq-iter IChunkedSeq -next flatten -dissoc doubles -contains-key? ifn? IAtom nat-int? IWatchable subvec -pop! partial chunked-seq? replicate reduced ITransientSet unchecked-byte every-pred missing-protocol load-file distinct? pos-int? unchecked-short odd? reduceable? string-hash-cache inc type->str bit-clear filter -assoc-n! IWithMeta list + aset int-rotate-left keyword *ns* *assert* ICollection chars next ASeq IFn -reset! -rest nil-iter false? *print-readably* ints some-fn *flush-on-newline* to-array list? array? simple-ident? clone bit-not byte max IComparable == count -disjoin! *loaded-libs* apply add-to-string-hash-cache IChunkedNext interpose deref assoc transient -disjoin chunk-cons drop-while IWriter *print-fn* compare complement -assoc! *print-dup* string-iter IDeref sequence constantly chunked-seq ISorted make-array shorts *unchecked-if* enable-console-print! -flush completing unchecked-negate-int hash-unordered-coll repeat unchecked-inc nthnext get-validator number? -conj! chunk-next not-any? into-array -hash qualified-symbol? -dissoc! chunk-buffer seqable? symbol? m3-hash-unencoded-chars unchecked-char system-time -invoke coll? get-in fnext IList -val bytes -seq], :type :cljs, :sym cljs.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into pipeline sub map> pipe unmix filter< sub* remove< untap* toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! map< do-alts pipeline-async Mix toggle* mult mapcat< ioc-alts! unblocking-buffer? put! take!], :type :cljs, :sym cljs.core.async} {:var-syms [acopy ring-buffer fixed-buffer dropping-buffer sliding-buffer promise-buffer], :type :cljs, :sym cljs.core.async.impl.buffers} {:var-syms [box put-active? MAX_DIRTY abort MMC chan], :type :cljs, :sym cljs.core.async.impl.channels} {:var-syms [tasks running? queued? TASK_BATCH_SIZE process-messages queue-dispatcher run queue-delay], :type :cljs, :sym cljs.core.async.impl.dispatch} {:var-syms [EXCEPTION-FRAMES process-exception STATE-IDX aset-object add-exception-frame run-state-machine-wrapped FN-IDX aget-object return-chan BINDINGS-IDX CURRENT-EXCEPTION run-state-machine finished? USER-START-IDX put! take! VALUE-IDX], :type :cljs, :sym cljs.core.async.impl.ioc-helpers} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :cljs, :sym cljs.core.async.impl.protocols} {:var-syms [MAX_LEVEL P random-level skip-list-node least-greater-node skip-list timeouts-map TIMEOUT_RESOLUTION_MS timeout], :type :cljs, :sym cljs.core.async.impl.timers} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [*load-fn* eval compile-str ns->relpath *loaded* require file->ns eval-str js-eval load-source-map! analyze-str *eval-fn*], :type :cljs, :sym cljs.js} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [*default-data-reader-fn* read *tag-table* parse-and-validate-timestamp register-tag-parser! register-default-tag-parser! deregister-default-tag-parser! read-string deregister-tag-parser! parse-timestamp], :type :cljs, :sym cljs.reader} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [update-result invert-reverse-map decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources seg-combine], :type :cljs, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [chars64 char->int int->char encode decode], :type :cljs, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [vlq-base-shift vlq-base vlq-base-mask vlq-continuation-bit to-vlq-signed from-vlq-signed encode-val encode decode], :type :cljs, :sym cljs.source-map.base64-vlq} {:var-syms [form nilable-impl *recursion-limit* *coll-error-limit* explain-printer Specize alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* MAX_INT check-asserts assert* inst-in-range? and-spec-impl describe* map-spec-impl explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen nonconforming unform* abbrev regex? int-in-range? spec? registry rep+impl exercise explain-data tuple-impl multi-spec-impl conform gen* fspec-impl *coll-check-limit* get-spec every-impl spec-impl invalid? amp-impl cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl describe explain-out specize* maybe-impl explain*], :type :cljs, :sym cljs.spec.alpha} {:var-syms [quick-check for-all* delay-impl cat gen-for-pred], :type :cljs, :sym cljs.spec.gen.alpha} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [bool? *suppress-read* *default-data-reader-fn* read default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex sb read-string map-func], :type :cljs, :sym cljs.tools.reader} {:var-syms [read read-string], :type :cljs, :sym cljs.tools.reader.edn} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern matches? throwing-reader ratio-pattern], :type :cljs, :sym cljs.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-dup-keys throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :cljs, :sym cljs.tools.reader.impl.errors} {:var-syms [inspect], :type :cljs, :sym cljs.tools.reader.impl.inspect} {:var-syms [reader-conditional whitespace? last-id char numeric? second' desugar-meta next-id ex-info? reader-conditional? newline? namespace-keys ws-rx], :type :cljs, :sym cljs.tools.reader.impl.utils} {:var-syms [indexing-push-back-reader log-source* merge-meta Reader source-logging-push-back-reader unread peek-char IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line string-push-back-reader line-start? source-logging-reader? IndexingReader node-readable-push-back-reader get-line-number], :type :cljs, :sym cljs.tools.reader.reader-types} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :cljs, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :cljs, :sym clojure.string} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [cli parse-opts summarize get-default-options format-lines make-summary-part], :type :clj, :sym clojure.tools.cli} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [add-files remove-files read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile find-namespaces-in-dir find-ns-decls-in-jarfile read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? deps-from-ns-decl read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated clojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [walk postwalk prewalk keywordize-keys stringify-keys prewalk-replace postwalk-replace], :type :cljs, :sym clojure.walk} {:var-syms [chan <!! put!], :type :clj, :sym dynadoc.aliases} {:var-syms [var-sym->url spec->html example->html init-editor expandable-section ns-sym->url sidebar var->html page-url update-link export-form export source->html app init-example-editor], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler page-state get-clj-vars dev-start get-cljs-nses-and-vars-dynamically -main get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [add-focus clj-compiler-fn version form->serializable init-editor add-callback cljs-compiler-fn transform init add-card prod check-version api-url with-focus->binding init-example-editor init-watcher!], :type :cljs, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [*state], :type :cljs, :sym dynadoc.state} {:var-syms [read-cljs-file get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable parse-uri flatten-vals cli-options process-example], :type :clj, :sym dynadoc.utils} {:var-syms [*cljs-info watch-request *channel->uri init-watcher!], :type :clj, :sym dynadoc.watch} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [chan? code->results], :type :cljs, :sym eval-soup.core} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [bool? *suppress-read* *default-data-reader-fn* read default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex sb read-string map-func], :type :cljs, :sym oakcljs.tools.reader} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern matches? throwing-reader ratio-pattern], :type :cljs, :sym oakcljs.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-dup-keys throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :cljs, :sym oakcljs.tools.reader.impl.errors} {:var-syms [inspect], :type :cljs, :sym oakcljs.tools.reader.impl.inspect} {:var-syms [reader-conditional whitespace? last-id char numeric? second' desugar-meta next-id ex-info? reader-conditional? newline? namespace-keys ws-rx], :type :cljs, :sym oakcljs.tools.reader.impl.utils} {:var-syms [indexing-push-back-reader log-source* merge-meta Reader source-logging-push-back-reader unread peek-char IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line string-push-back-reader line-start? source-logging-reader? IndexingReader node-readable-push-back-reader get-line-number], :type :cljs, :sym oakcljs.tools.reader.reader-types} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated oakclojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [create-console-history get-console-start update-console-start! update-console-history! get-previous-line get-next-line up! down!], :type :cljs, :sym paren-soup.console} {:var-syms [can-undo show-error-message! focused-text selected-text can-redo? can-redo rainbow-delimiters up! refresh! undo! key-name? eval channel? create-editor key-code redo! post-refresh-content! tab! transient-map? refresh-content-element! elem? enter! append-text! line-numbers update-highlight! init can-undo? refresh-content! redo debounce-function refresh-instarepl! edit-and-refresh! rainbow-count update-cursor-position! init-state eval! add-parinfer-after-console-start refresh-numbers! refresh-after-cut-paste! refresh-after-key-event! add-newline update-edit-history! refresh-console-content! append-text prevent-default? initialize! add-parinfer undo obj? down! add-event-listeners! reset-edit-history! hide-error-messages! Editor], :type :cljs, :sym paren-soup.core} {:var-syms [top-level? get-selection get-cursor-position text-node? get-focused-form get-focused-top-level get-parent coll-node? get-nearest-ns get-completion-info get-focused-elem error-node? get-completion-context common-ancestor get-parents node?], :type :cljs, :sym paren-soup.dom} {:var-syms [elem? elems->locations results->html get-collections collection->content create-compiler-fn], :type :cljs, :sym paren-soup.instarepl} {:var-syms [after-render current-component as-component adapt-react-class atom merge-props force-update-all as-element rswap! next-tick track props dispose! state-atom flush children wrap reactify-component unmount-component-at-node render-component component-path cursor state dom-node track! is-client replace-state partial set-state argv render force-update create-class create-element], :type :cljs, :sym reagent.core} {:var-syms [has-console tracking warnings track-warnings], :type :cljs, :sym reagent.debug} {:var-syms [render unmount-component-at-node dom-node force-update-all], :type :cljs, :sym reagent.dom} {:var-syms [fake-raf do-before-flush flush-after-render queue-render next-tick flush mark-rendered schedule render-queue compare-mount-order mount-count next-mount-count do-after-render run-queue ratom-flush], :type :cljs, :sym reagent.impl.batching} {:var-syms [get-props get-wrapper get-argv wrap-render rat-opts obligatory props-argv as-element do-render comp-name add-obligatory cached-react-class state-atom fiber-component-path dash-to-camel reagent-component? static-fns as-class reagent-class? fn-to-class reactify-component extract-children component-path extract-props get-children camelify-map-keys shallow-obj-to-map cljsify react-class? cache-react-class custom-wrapper create-class wrap-funs], :type :cljs, :sym reagent.impl.component} {:var-syms [valid-tag? adapt-react-class synthetic-input-spec has-selection-api? str-coll get-key re-tag as-element input-component? input-render-setup input-component-set-value stringify-class oget hiccup-tag? set-id-class reagent-synthetic-input input-node-set-value convert-props hiccup-err named? kv-conv key-from-vec js-val? input-unmount reagent-input-class native-element reagent-input cache-get input-handle-change input-spec expand-seq-dev cached-prop-name these-inputs-have-selection-api expand-seq reagent-synthetic-input-class find-dom-node cached-parse try-get-key], :type :cljs, :sym reagent.impl.template} {:var-syms [merge-props capitalize dash-to-camel dont-camel-case memoize-1 make-partial-fn *non-reactive* fun-name is-client force-update *always-update*], :type :cljs, :sym reagent.impl.util} {:var-syms [make-track atom make-wrapper IReactiveAtom track dispose! run add-on-dispose! make-track! run-in-reaction IDisposable with-let-destroy make-reaction flush! debug cursor running IRunnable reactive? with-let-values track! check-derefs], :type :cljs, :sym reagent.ratom} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [state build-defcs build-defcc request-render mount unmount], :type :cljs, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [wrap-attrs include-css include-react *group* file-upload], :type :cljs, :sym sablono.core} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}), :ns-meta {:doc "Fundamental library of the Clojure language", :author "Rich Hickey"}, :vars [{:sym *, :meta {:arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'"}, :source "(defn *\n  \"Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'\"\n  {:inline (nary-inline 'multiply 'unchecked_multiply)\n   :inline-arities >1?\n   :added \"1.2\"}\n  ([] 1)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (multiply x y)))\n  ([x y & more]\n     (reduce1 * (* x y) more)))", :spec nil, :examples []} {:sym *', :meta {:arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *"}, :source "(defn *'\n  \"Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *\"\n  {:inline (nary-inline 'multiplyP)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([] 1)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (multiplyP x y)))\n  ([x y & more]\n   (reduce1 *' (*' x y) more)))", :spec nil, :examples []} {:sym *1, :meta {:doc "bound in a repl thread to the most recent value printed"}, :source "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the most recent value printed\"\n   :added \"1.0\"}\n *1)", :spec nil, :examples []} {:sym *2, :meta {:doc "bound in a repl thread to the second most recent value printed"}, :source "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the second most recent value printed\"\n   :added \"1.0\"}\n *2)", :spec nil, :examples []} {:sym *3, :meta {:doc "bound in a repl thread to the third most recent value printed"}, :source "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the third most recent value printed\"\n   :added \"1.0\"}\n *3)", :spec nil, :examples []} {:sym *agent*, :meta {:doc "The agent currently running an action on this thread, else nil"}, :source nil, :spec nil, :examples []} {:sym *allow-unresolved-vars*, :meta {}, :source nil, :spec nil, :examples []} {:sym *assert*, :meta {}, :source nil, :spec nil, :examples []} {:sym *clojure-version*, :meta {:doc "The version info for Clojure core, as a map containing :major :minor \n  :incremental and :qualifier keys. Feature releases may increment \n  :minor and/or :major, bugfix releases will increment :incremental. \n  Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\""}, :source "  (def ^:dynamic *clojure-version*\n    (if (.contains version-string \"SNAPSHOT\")\n      (clojure.lang.RT/assoc clojure-version :interim true)\n      clojure-version))", :spec nil, :examples []} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source nil, :spec nil, :examples []} {:sym *compile-files*, :meta {:doc "Set to true when compiling files, false otherwise."}, :source nil, :spec nil, :examples []} {:sym *compile-path*, :meta {:doc "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\""}, :source nil, :spec nil, :examples []} {:sym *compiler-options*, :meta {:doc "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  Alpha, subject to change."}, :source nil, :spec nil, :examples []} {:sym *data-readers*, :meta {:doc "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var."}, :source "(def ^{:added \"1.4\" :dynamic true} *data-readers*\n  \"Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.\"\n  {})", :spec nil, :examples []} {:sym *default-data-reader-fn*, :meta {:doc "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag."}, :source "(def ^{:added \"1.5\" :dynamic true} *default-data-reader-fn* \n  \"When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.\"\n  nil)", :spec nil, :examples []} {:sym *e, :meta {:doc "bound in a repl thread to the most recent exception caught by the repl"}, :source "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the most recent exception caught by the repl\"\n   :added \"1.0\"}\n *e)", :spec nil, :examples []} {:sym *err*, :meta {:doc "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter"}, :source nil, :spec nil, :examples []} {:sym *file*, :meta {:doc "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined."}, :source nil, :spec nil, :examples []} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source nil, :spec nil, :examples []} {:sym *fn-loader*, :meta {}, :source nil, :spec nil, :examples []} {:sym *in*, :meta {:doc "A java.io.Reader object representing standard input for read operations.\n\n  Defaults to System/in, wrapped in a LineNumberingPushbackReader"}, :source nil, :spec nil, :examples []} {:sym *math-context*, :meta {}, :source nil, :spec nil, :examples []} {:sym *ns*, :meta {:doc "A clojure.lang.Namespace object representing the current namespace."}, :source nil, :spec nil, :examples []} {:sym *out*, :meta {:doc "A java.io.Writer object representing standard output for print operations.\n\n  Defaults to System/out, wrapped in an OutputStreamWriter"}, :source nil, :spec nil, :examples []} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source nil, :spec nil, :examples []} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def ^:dynamic\n ^{:doc \"*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.\"\n   :added \"1.0\"}\n *print-length* nil)", :spec nil, :examples []} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def ^:dynamic\n ^{:doc \"*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.\"\n   :added \"1.0\"}\n *print-level* nil)", :spec nil, :examples []} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source nil, :spec nil, :examples []} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax. It defaults to false, but the REPL binds\n  to true."}, :source "(def ^:dynamic\n ^{:doc \"*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax. It defaults to false, but the REPL binds\n  to true.\"\n   :added \"1.9\"}\n *print-namespace-maps* false)", :spec nil, :examples []} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source nil, :spec nil, :examples []} {:sym *read-eval*, :meta {:doc "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: clojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'clojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dclojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dclojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  "}, :source nil, :spec nil, :examples []} {:sym *reader-resolver*, :meta {}, :source nil, :spec nil, :examples []} {:sym *source-path*, :meta {}, :source nil, :spec nil, :examples []} {:sym *suppress-read*, :meta {}, :source nil, :spec nil, :examples []} {:sym *unchecked-math*, :meta {:doc "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false."}, :source nil, :spec nil, :examples []} {:sym *use-context-classloader*, :meta {}, :source nil, :spec nil, :examples []} {:sym *verbose-defrecords*, :meta {}, :source "(def ^:dynamic *verbose-defrecords* false)", :spec nil, :examples []} {:sym *warn-on-reflection*, :meta {:doc "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false."}, :source nil, :spec nil, :examples []} {:sym +, :meta {:arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'"}, :source "(defn +\n  \"Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'\"\n  {:inline (nary-inline 'add 'unchecked_add)\n   :inline-arities >1?\n   :added \"1.2\"}\n  ([] 0)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (add x y)))\n  ([x y & more]\n     (reduce1 + (+ x y) more)))", :spec nil, :examples []} {:sym +', :meta {:arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +"}, :source "(defn +'\n  \"Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +\"\n  {:inline (nary-inline 'addP)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([] 0)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (addP x y)))\n  ([x y & more]\n   (reduce1 +' (+' x y) more)))", :spec nil, :examples []} {:sym -, :meta {:arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'"}, :source "(defn -\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'\"\n  {:inline (nary-inline 'minus 'unchecked_minus)\n   :inline-arities >0?\n   :added \"1.2\"}\n  ([x] (. clojure.lang.Numbers (minus x)))\n  ([x y] (. clojure.lang.Numbers (minus x y)))\n  ([x y & more]\n     (reduce1 - (- x y) more)))", :spec nil, :examples []} {:sym -', :meta {:arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -"}, :source "(defn -'\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -\"\n  {:inline (nary-inline 'minusP)\n   :inline-arities >0?\n   :added \"1.0\"}\n  ([x] (. clojure.lang.Numbers (minusP x)))\n  ([x y] (. clojure.lang.Numbers (minusP x y)))\n  ([x y & more]\n   (reduce1 -' (-' x y) more)))", :spec nil, :examples []} {:sym ->, :meta {:arglists ([x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc."}, :source "(defmacro ->\n  \"Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.\"\n  {:added \"1.0\"}\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))", :spec nil, :examples []} {:sym ->>, :meta {:arglists ([x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc."}, :source "(defmacro ->>\n  \"Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.\"\n  {:added \"1.1\"}\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x))]\n        (recur threaded (next forms)))\n      x)))", :spec nil, :examples []} {:sym ->ArrayChunk, :meta {:arglists ([am arr off end]), :doc "Positional factory function for class clojure.core.ArrayChunk."}, :source "(deftype ArrayChunk [^clojure.core.ArrayManager am arr ^int off ^int end]\n  \n  clojure.lang.Indexed\n  (nth [_ i] (.aget am arr (+ off i)))\n  \n  (count [_] (- end off))\n\n  clojure.lang.IChunk\n  (dropFirst [_]\n    (if (= off end)\n      (throw (IllegalStateException. \"dropFirst of empty chunk\"))\n      (new ArrayChunk am arr (inc off) end)))\n  \n  (reduce [_ f init]\n    (loop [ret init i off]\n      (if (< i end)\n        (let [ret (f ret (.aget am arr i))]\n          (if (reduced? ret)\n            ret\n            (recur ret (inc i))))\n        ret))))", :spec nil, :examples []} {:sym ->Eduction, :meta {:arglists ([xform coll]), :doc "Positional factory function for class clojure.core.Eduction."}, :source "(deftype Eduction [xform coll]\n   Iterable\n   (iterator [_]\n     (clojure.lang.TransformerIterator/create xform (clojure.lang.RT/iter coll)))\n\n   clojure.lang.IReduceInit\n   (reduce [_ f init]\n     ;; NB (completing f) isolates completion of inner rf from outer rf\n     (transduce xform (completing f) init coll))\n\n   clojure.lang.Sequential)", :spec nil, :examples []} {:sym ->Vec, :meta {:arglists ([am cnt shift root tail _meta]), :doc "Positional factory function for class clojure.core.Vec."}, :source "(deftype Vec [^clojure.core.ArrayManager am ^int cnt ^int shift ^clojure.core.VecNode root tail _meta]\n  Object\n  (equals [this o]\n    (cond \n     (identical? this o) true\n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (.equals (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (if-let [st (seq this)]\n         (.equals st (seq o))\n         (nil? (seq o)))\n     :else false))\n\n  ;todo - cache\n  (hashCode [this]\n    (loop [hash (int 1) i (int 0)]\n      (if (= i cnt)\n        hash\n        (let [val (.nth this i)]\n          (recur (unchecked-add-int (unchecked-multiply-int 31 hash) \n                                (clojure.lang.Util/hash val)) \n                 (inc i))))))\n\n  ;todo - cache\n  clojure.lang.IHashEq\n  (hasheq [this]\n    (Murmur3/hashOrdered this))\n\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.IMeta\n  (meta [_] _meta)\n\n  clojure.lang.IObj\n  (withMeta [_ m] (new Vec am cnt shift root tail m))\n\n  clojure.lang.Indexed\n  (nth [this i]\n    (let [a (.arrayFor this i)]\n      (.aget am a (bit-and i (int 0x1f)))))\n  (nth [this i not-found]\n       (let [z (int 0)]\n         (if (and (>= i z) (< i (.count this)))\n           (.nth this i)\n           not-found)))\n\n  clojure.lang.IPersistentCollection\n  (cons [this val]\n     (if (< (- cnt (.tailoff this)) (int 32))\n      (let [new-tail (.array am (inc (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n        (.aset am new-tail (.alength am tail) val)\n        (new Vec am (inc cnt) shift root new-tail (meta this)))\n      (let [tail-node (VecNode. (.edit root) tail)] \n        (if (> (bit-shift-right cnt (int 5)) (bit-shift-left (int 1) shift)) ;overflow root?\n          (let [new-root (VecNode. (.edit root) (object-array 32))]\n            (doto ^objects (.arr new-root)\n              (aset 0 root)\n              (aset 1 (.newPath this (.edit root) shift tail-node)))\n            (new Vec am (inc cnt) (+ shift (int 5)) new-root (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this)))\n          (new Vec am (inc cnt) shift (.pushTail this shift root tail-node) \n                 (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this))))))\n\n  (empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))                             \n  (equiv [this o]\n    (cond \n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (= (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (clojure.lang.Util/equiv (seq this) (seq o))\n     :else false))\n\n  clojure.lang.IPersistentStack\n  (peek [this]\n    (when (> cnt (int 0)) \n      (.nth this (dec cnt))))\n\n  (pop [this]\n   (cond\n    (zero? cnt) \n      (throw (IllegalStateException. \"Can't pop empty vector\"))\n    (= 1 cnt) \n      (new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))\n    (> (- cnt (.tailoff this)) 1)\n      (let [new-tail (.array am (dec (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am new-tail))\n        (new Vec am (dec cnt) shift root new-tail (meta this)))\n    :else\n      (let [new-tail (.arrayFor this (- cnt 2))\n            new-root ^clojure.core.VecNode (.popTail this shift root)]\n        (cond\n         (nil? new-root) \n           (new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))\n         (and (> shift 5) (nil? (aget ^objects (.arr new-root) 1)))\n           (new Vec am (dec cnt) (- shift 5) (aget ^objects (.arr new-root) 0) new-tail (meta this))\n         :else\n           (new Vec am (dec cnt) shift new-root new-tail (meta this))))))\n\n  clojure.lang.IPersistentVector\n  (assocN [this i val]\n    (cond \n     (and (<= (int 0) i) (< i cnt))\n       (if (>= i (.tailoff this))\n         (let [new-tail (.array am (.alength am tail))]\n           (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n           (.aset am new-tail (bit-and i (int 0x1f)) val)\n           (new Vec am cnt shift root new-tail (meta this)))\n         (new Vec am cnt shift (.doAssoc this shift root i val) tail (meta this)))\n     (= i cnt) (.cons this val)\n     :else (throw (IndexOutOfBoundsException.))))\n  (length [_] cnt)\n  \n  clojure.lang.Reversible\n  (rseq [this]\n        (if (> (.count this) 0)\n          (clojure.lang.APersistentVector$RSeq. this (dec (.count this)))\n          nil))\n  \n  clojure.lang.Associative\n  (assoc [this k v]\n    (if (clojure.lang.Util/isInteger k)\n      (.assocN this k v)\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n  (containsKey [this k]\n    (and (clojure.lang.Util/isInteger k)\n         (<= 0 (int k))\n         (< (int k) cnt)))\n  (entryAt [this k]\n    (if (.containsKey this k)\n      (clojure.lang.MapEntry/create k (.nth this (int k)))\n      nil))\n\n  clojure.lang.ILookup\n  (valAt [this k not-found]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          not-found))\n      not-found))\n\n  (valAt [this k] (.valAt this k nil))\n\n  clojure.lang.IFn\n  (invoke [this k]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          (throw (IndexOutOfBoundsException.))))\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n\n  \n  clojure.lang.Seqable\n  (seq [this] \n    (if (zero? cnt) \n      nil\n      (VecSeq. am this (.arrayFor this 0) 0 0)))\n\n  clojure.lang.Sequential ;marker, no methods\n\n  clojure.core.IVecImpl\n  (tailoff [_] \n    (- cnt (.alength am tail)))\n\n  (arrayFor [this i]\n    (if (and  (<= (int 0) i) (< i cnt))\n      (if (>= i (.tailoff this))\n        tail\n        (loop [node root level shift]\n          (if (zero? level)\n            (.arr node)\n            (recur (aget ^objects (.arr node) (bit-and (bit-shift-right i level) (int 0x1f))) \n                   (- level (int 5))))))\n      (throw (IndexOutOfBoundsException.))))\n\n  (pushTail [this level parent tailnode]\n    (let [subidx (bit-and (bit-shift-right (dec cnt) level) (int 0x1f))\n          parent ^clojure.core.VecNode parent\n          ret (VecNode. (.edit parent) (aclone ^objects (.arr parent)))\n          node-to-insert (if (= level (int 5))\n                           tailnode\n                           (let [child (aget ^objects (.arr parent) subidx)]\n                             (if child\n                               (.pushTail this (- level (int 5)) child tailnode)\n                               (.newPath this (.edit root) (- level (int 5)) tailnode))))]\n      (aset ^objects (.arr ret) subidx node-to-insert)\n      ret))\n\n  (popTail [this level node]\n    (let [node ^clojure.core.VecNode node\n          subidx (bit-and (bit-shift-right (- cnt (int 2)) level) (int 0x1f))]\n      (cond\n       (> level 5) \n         (let [new-child (.popTail this (- level 5) (aget ^objects (.arr node) subidx))]\n           (if (and (nil? new-child) (zero? subidx))\n             nil\n             (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx new-child)\n               (VecNode. (.edit root) arr))))\n       (zero? subidx) nil\n       :else (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx nil)\n               (VecNode. (.edit root) arr)))))\n\n  (newPath [this edit ^int level node]\n    (if (zero? level)\n      node\n      (let [ret (VecNode. edit (object-array 32))]\n        (aset ^objects (.arr ret) 0 (.newPath this edit (- level (int 5)) node))\n        ret)))\n\n  (doAssoc [this level node i val]\n    (let [node ^clojure.core.VecNode node]       \n      (if (zero? level)\n        ;on this branch, array will need val type\n        (let [arr (.aclone am (.arr node))]\n          (.aset am arr (bit-and i (int 0x1f)) val)\n          (VecNode. (.edit node) arr))\n        (let [arr (aclone ^objects (.arr node))\n              subidx (bit-and (bit-shift-right i level) (int 0x1f))]\n          (aset arr subidx (.doAssoc this (- level (int 5)) (aget arr subidx) i val))\n          (VecNode. (.edit node) arr)))))\n\n  java.lang.Comparable\n  (compareTo [this o]\n    (if (identical? this o)\n      0\n      (let [^clojure.lang.IPersistentVector v (cast clojure.lang.IPersistentVector o)\n            vcnt (.count v)]\n        (cond\n          (< cnt vcnt) -1\n          (> cnt vcnt) 1\n          :else\n            (loop [i (int 0)]\n              (if (= i cnt)\n                0\n                (let [comp (clojure.lang.Util/compare (.nth this i) (.nth v i))]\n                  (if (= 0 comp)\n                    (recur (inc i))\n                    comp))))))))\n\n  java.lang.Iterable\n  (iterator [this]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. 0)]\n      (reify java.util.Iterator\n        (hasNext [_] (< (.get i) cnt))\n        (next [_] (try\n                    (.nth this (dec (.incrementAndGet i)))\n                    (catch IndexOutOfBoundsException _\n                      (throw (java.util.NoSuchElementException.)))))\n        (remove [_] (throw (UnsupportedOperationException.))))))\n\n  java.util.Collection\n  (contains [this o] (boolean (some #(= % o) this)))\n  (containsAll [this c] (every? #(.contains this %) c))\n  (isEmpty [_] (zero? cnt))\n  (toArray [this] (into-array Object this))\n  (toArray [this arr]\n    (if (>= (count arr) cnt)\n      (do\n        (dotimes [i cnt]\n          (aset arr i (.nth this i)))\n        arr)\n      (into-array Object this)))\n  (size [_] cnt)\n  (add [_ o] (throw (UnsupportedOperationException.)))\n  (addAll [_ c] (throw (UnsupportedOperationException.)))\n  (clear [_] (throw (UnsupportedOperationException.)))\n  (^boolean remove [_ o] (throw (UnsupportedOperationException.)))\n  (removeAll [_ c] (throw (UnsupportedOperationException.)))\n  (retainAll [_ c] (throw (UnsupportedOperationException.)))\n\n  java.util.List\n  (get [this i] (.nth this i))\n  (indexOf [this o]\n    (loop [i (int 0)]\n      (cond\n        (== i cnt) -1\n        (= o (.nth this i)) i\n        :else (recur (inc i)))))\n  (lastIndexOf [this o]\n    (loop [i (dec cnt)]\n      (cond\n        (< i 0) -1\n        (= o (.nth this i)) i\n        :else (recur (dec i)))))\n  (listIterator [this] (.listIterator this 0))\n  (listIterator [this i]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. i)]\n      (reify java.util.ListIterator\n        (hasNext [_] (< (.get i) cnt))\n        (hasPrevious [_] (pos? i))\n        (next [_] (try\n                    (.nth this (dec (.incrementAndGet i)))\n                    (catch IndexOutOfBoundsException _\n                      (throw (java.util.NoSuchElementException.)))))\n        (nextIndex [_] (.get i))\n        (previous [_] (try\n                        (.nth this (.decrementAndGet i))\n                        (catch IndexOutOfBoundsException _\n                          (throw (java.util.NoSuchElementException.)))))\n        (previousIndex [_] (dec (.get i)))\n        (add [_ e] (throw (UnsupportedOperationException.)))\n        (remove [_] (throw (UnsupportedOperationException.)))\n        (set [_ e] (throw (UnsupportedOperationException.))))))\n  (subList [this a z] (subvec this a z))\n  (add [_ i o] (throw (UnsupportedOperationException.)))\n  (addAll [_ i c] (throw (UnsupportedOperationException.)))\n  (^Object remove [_ ^int i] (throw (UnsupportedOperationException.)))\n  (set [_ i e] (throw (UnsupportedOperationException.)))\n)", :spec nil, :examples []} {:sym ->VecNode, :meta {:arglists ([edit arr]), :doc "Positional factory function for class clojure.core.VecNode."}, :source "(deftype VecNode [edit arr])", :spec nil, :examples []} {:sym ->VecSeq, :meta {:arglists ([am vec anode i offset]), :doc "Positional factory function for class clojure.core.VecSeq."}, :source "(deftype VecSeq [^clojure.core.ArrayManager am ^clojure.core.IVecImpl vec anode ^int i ^int offset] \n  :no-print true\n\n  clojure.core.protocols.InternalReduce\n  (internal-reduce\n   [_ f val]\n   (loop [result val\n          aidx (+ i offset)]\n     (if (< aidx (count vec))\n       (let [node (.arrayFor vec aidx)\n             result (loop [result result\n                           node-idx (bit-and 0x1f aidx)]\n                      (if (< node-idx (.alength am node))\n                        (let [result (f result (.aget am node node-idx))]\n                          (if (reduced? result)\n                            result\n                            (recur result (inc node-idx))))\n                        result))]\n         (if (reduced? result)\n           @result\n           (recur result (bit-and 0xffe0 (+ aidx 32)))))\n       result)))\n  \n  clojure.lang.ISeq\n  (first [_] (.aget am anode offset))\n  (next [this] \n    (if (< (inc offset) (.alength am anode))\n      (new VecSeq am vec anode i (inc offset))\n      (.chunkedNext this)))\n  (more [this]\n    (let [s (.next this)]\n      (or s (clojure.lang.PersistentList/EMPTY))))\n  (cons [this o]\n    (clojure.lang.Cons. o this))\n  (count [this]\n    (loop [i 1\n           s (next this)]\n      (if s\n        (if (instance? clojure.lang.Counted s)\n          (+ i (.count s))\n          (recur (inc i) (next s)))\n        i)))\n  (equiv [this o]\n    (cond\n     (identical? this o) true\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n     (loop [me this\n            you (seq o)]\n       (if (nil? me)\n         (nil? you)\n         (and (clojure.lang.Util/equiv (first me) (first you))\n              (recur (next me) (next you)))))\n     :else false))\n  (empty [_]\n    clojure.lang.PersistentList/EMPTY)\n\n\n  clojure.lang.Seqable\n  (seq [this] this)\n\n  clojure.lang.IChunkedSeq\n  (chunkedFirst [_] (ArrayChunk. am anode offset (.alength am anode)))\n  (chunkedNext [_] \n   (let [nexti (+ i (.alength am anode))]\n     (when (< nexti (count vec))\n       (new VecSeq am vec (.arrayFor vec nexti) nexti 0))))\n  (chunkedMore [this]\n    (let [s (.chunkedNext this)]\n      (or s (clojure.lang.PersistentList/EMPTY)))))", :spec nil, :examples []} {:sym -cache-protocol-fn, :meta {:arglists ([pf x c interf])}, :source "(defn -cache-protocol-fn [^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]\n  (let [cache  (.__methodImplCache pf)\n        f (if (.isInstance c x)\n            interf \n            (find-protocol-method (.protocol cache) (.methodk cache) x))]\n    (when-not f\n      (throw (IllegalArgumentException. (str \"No implementation of method: \" (.methodk cache) \n                                             \" of protocol: \" (:var (.protocol cache)) \n                                             \" found for class: \" (if (nil? x) \"nil\" (.getName (class x)))))))\n    (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))\n    f))", :spec nil, :examples []} {:sym -reset-methods, :meta {:arglists ([protocol])}, :source "(defn -reset-methods [protocol]\n  (doseq [[^clojure.lang.Var v build] (:method-builders protocol)]\n    (let [cache (clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]\n      (.bindRoot v (build cache)))))", :spec nil, :examples []} {:sym .., :meta {:arglists ([x form] [x form & more]), :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand."}, :source "(defmacro ..\n  \"form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \\\"os.name\\\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \\\"os.name\\\"))\n\n  but is easier to write, read, and understand.\"\n  {:added \"1.0\"}\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))", :spec nil, :examples []} {:sym /, :meta {:arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, :source "(defn /\n  \"If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.\"\n  {:inline (nary-inline 'divide)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x] (/ 1 x))\n  ([x y] (. clojure.lang.Numbers (divide x y)))\n  ([x y & more]\n   (reduce1 / (/ x y) more)))", :spec nil, :examples []} {:sym <, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, :source "(defn <\n  \"Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (lt ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (lt x y)))\n  ([x y & more]\n   (if (< x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (< y (first more)))\n     false)))", :spec nil, :examples []} {:sym <=, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, :source "(defn <=\n  \"Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (lte ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (lte x y)))\n  ([x y & more]\n   (if (<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (<= y (first more)))\n     false)))", :spec nil, :examples []} {:sym =, :meta {:arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison."}, :source "(defn =\n  \"Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.\"\n  {:inline (fn [x y] `(. clojure.lang.Util equiv ~x ~y))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (clojure.lang.Util/equiv x y))\n  ([x y & more]\n   (if (clojure.lang.Util/equiv x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (clojure.lang.Util/equiv y (first more)))\n     false)))", :spec nil, :examples []} {:sym ==, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false"}, :source "(defn ==\n  \"Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (equiv ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (equiv x y)))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))", :spec nil, :examples []} {:sym >, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, :source "(defn >\n  \"Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (gt ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (gt x y)))\n  ([x y & more]\n   (if (> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (> y (first more)))\n     false)))", :spec nil, :examples []} {:sym >=, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, :source "(defn >=\n  \"Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (gte ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (gte x y)))\n  ([x y & more]\n   (if (>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (>= y (first more)))\n     false)))", :spec nil, :examples []} {:sym EMPTY-NODE, :meta {}, :source "(def EMPTY-NODE (VecNode. nil (object-array 32)))", :spec nil, :examples []} {:sym Inst, :meta {:doc nil}, :source "(defprotocol Inst\n  (inst-ms* [inst]))", :spec nil, :examples []} {:sym StackTraceElement->vec, :meta {:arglists ([o]), :doc "Constructs a data representation for a StackTraceElement"}, :source "(defn StackTraceElement->vec\n  \"Constructs a data representation for a StackTraceElement\"\n  {:added \"1.9\"}\n  [^StackTraceElement o]\n  [(symbol (.getClassName o)) (symbol (.getMethodName o)) (.getFileName o) (.getLineNumber o)])", :spec nil, :examples []} {:sym Throwable->map, :meta {:arglists ([o]), :doc "Constructs a data representation for a Throwable."}, :source "(defn Throwable->map\n  \"Constructs a data representation for a Throwable.\"\n  {:added \"1.7\"}\n  [^Throwable o]\n  (let [base (fn [^Throwable t]\n               (merge {:type (symbol (.getName (class t)))\n                       :message (.getLocalizedMessage t)}\n                 (when-let [ed (ex-data t)]\n                   {:data ed})\n                 (let [st (.getStackTrace t)]\n                   (when (pos? (alength st))\n                     {:at (StackTraceElement->vec (aget st 0))}))))\n        via (loop [via [], ^Throwable t o]\n              (if t\n                (recur (conj via t) (.getCause t))\n                via))\n        ^Throwable root (peek via)\n        m {:cause (.getLocalizedMessage root)\n           :via (vec (map base via))\n           :trace (vec (map StackTraceElement->vec\n                            (.getStackTrace ^Throwable (or root o))))}\n        data (ex-data root)]\n    (if data\n      (assoc m :data data)\n      m)))", :spec nil, :examples []} {:sym accessor, :meta {:arglists ([s key]), :doc "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas."}, :source "(defn accessor\n  \"Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.\"\n  {:added \"1.0\"\n   :static true}\n  [s key]\n    (. clojure.lang.PersistentStructMap (getAccessor s key)))", :spec nil, :examples []} {:sym aclone, :meta {:arglists ([array]), :doc "Returns a clone of the Java array. Works on arrays of known\n  types."}, :source "(defn aclone\n  \"Returns a clone of the Java array. Works on arrays of known\n  types.\"\n  {:inline (fn [a] `(. clojure.lang.RT (aclone ~a)))\n   :added \"1.0\"}\n  [array] (. clojure.lang.RT (aclone array)))", :spec nil, :examples []} {:sym add-classpath, :meta {:arglists ([url]), :doc "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL"}, :source "(defn add-classpath\n  \"DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL\"\n  {:added \"1.0\"\n   :deprecated \"1.1\"}\n  [url]\n  (println \"WARNING: add-classpath is deprecated\")\n  (clojure.lang.RT/addURL url))", :spec nil, :examples []} {:sym add-watch, :meta {:arglists ([reference key fn]), :doc "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism."}, :source "(defn add-watch\n  \"Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef reference key fn] (.addWatch reference key fn))", :spec nil, :examples []} {:sym agent, :meta {:arglists ([state & options]), :doc "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details."}, :source "(defn agent\n  \"Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.\"\n  {:added \"1.0\"\n   :static true\n   }\n  ([state & options]\n     (let [a (new clojure.lang.Agent state)\n           opts (apply hash-map options)]\n       (setup-reference a options)\n       (when (:error-handler opts)\n         (.setErrorHandler a (:error-handler opts)))\n       (.setErrorMode a (or (:error-mode opts)\n                            (if (:error-handler opts) :continue :fail)))\n       a)))", :spec nil, :examples []} {:sym agent-error, :meta {:arglists ([a]), :doc "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed."}, :source "(defn agent-error\n  \"Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a] (.getError a))", :spec nil, :examples []} {:sym agent-errors, :meta {:arglists ([a]), :doc "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent."}, :source "(defn agent-errors\n  \"DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.\"\n  {:added \"1.0\"\n   :deprecated \"1.2\"}\n  [a]\n  (when-let [e (agent-error a)]\n    (list e)))", :spec nil, :examples []} {:sym aget, :meta {:arglists ([array idx] [array idx & idxs]), :doc "Returns the value at the index/indices. Works on Java arrays of all\n  types."}, :source "(defn aget\n  \"Returns the value at the index/indices. Works on Java arrays of all\n  types.\"\n  {:inline (fn [a i] `(. clojure.lang.RT (aget ~a (int ~i))))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([array idx]\n   (clojure.lang.Reflector/prepRet (.getComponentType (class array)) (. Array (get array idx))))\n  ([array idx & idxs]\n   (apply aget (aget array idx) idxs)))", :spec nil, :examples []} {:sym alength, :meta {:arglists ([array]), :doc "Returns the length of the Java array. Works on arrays of all\n  types."}, :source "(defn alength\n  \"Returns the length of the Java array. Works on arrays of all\n  types.\"\n  {:inline (fn [a] `(. clojure.lang.RT (alength ~a)))\n   :added \"1.0\"}\n  [array] (. clojure.lang.RT (alength array)))", :spec nil, :examples []} {:sym alias, :meta {:arglists ([alias namespace-sym]), :doc "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly."}, :source "(defn alias\n  \"Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.\"\n  {:added \"1.0\"\n   :static true}\n  [alias namespace-sym]\n  (.addAlias *ns* alias (the-ns namespace-sym)))", :spec nil, :examples []} {:sym all-ns, :meta {:arglists ([]), :doc "Returns a sequence of all namespaces."}, :source "(defn all-ns\n  \"Returns a sequence of all namespaces.\"\n  {:added \"1.0\"\n   :static true}\n  [] (clojure.lang.Namespace/all))", :spec nil, :examples []} {:sym alter, :meta {:arglists ([ref fun & args]), :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref."}, :source "(defn alter\n  \"Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref fun & args]\n    (. ref (alter fun args)))", :spec nil, :examples []} {:sym alter-meta!, :meta {:arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, :source "(defn alter-meta!\n  \"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IReference iref f & args] (.alterMeta iref f args))", :spec nil, :examples []} {:sym alter-var-root, :meta {:arglists ([v f & args]), :doc "Atomically alters the root binding of var v by applying f to its\n  current value plus any args"}, :source "(defn alter-var-root\n  \"Atomically alters the root binding of var v by applying f to its\n  current value plus any args\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var v f & args] (.alterRoot v f args))", :spec nil, :examples []} {:sym amap, :meta {:arglists ([a idx ret expr]), :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret."}, :source "(defmacro amap\n  \"Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.\"\n  {:added \"1.0\"}\n  [a idx ret expr]\n  `(let [a# ~a l# (alength a#)\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  l#)\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (unchecked-inc ~idx)))\n         ~ret))))", :spec nil, :examples []} {:sym ancestors, :meta {:arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, :source "(defn ancestors\n  \"Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  {:added \"1.0\"}\n  ([tag] (ancestors global-hierarchy tag))\n  ([h tag] (not-empty\n            (let [ta (get (:ancestors h) tag)]\n              (if (class? tag)\n                (let [superclasses (set (supers tag))]\n                  (reduce1 into1 superclasses\n                    (cons ta\n                          (map #(get (:ancestors h) %) superclasses))))\n                ta)))))", :spec nil, :examples []} {:sym and, :meta {:arglists ([] [x] [x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true."}, :source "(defmacro and\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.\"\n  {:added \"1.0\"}\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))", :spec nil, :examples []} {:sym any?, :meta {:arglists ([x]), :doc "Returns true given any argument."}, :source "(defn any?\n  \"Returns true given any argument.\"\n  {:tag Boolean\n   :added \"1.9\"}\n  [x] true)", :spec nil, :examples []} {:sym apply, :meta {:arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, :source "(defn apply\n  \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.IFn f args]\n     (. f (applyTo (seq args))))\n  ([^clojure.lang.IFn f x args]\n     (. f (applyTo (list* x args))))\n  ([^clojure.lang.IFn f x y args]\n     (. f (applyTo (list* x y args))))\n  ([^clojure.lang.IFn f x y z args]\n     (. f (applyTo (list* x y z args))))\n  ([^clojure.lang.IFn f a b c d & args]\n     (. f (applyTo (cons a (cons b (cons c (cons d (spread args)))))))))", :spec nil, :examples []} {:sym areduce, :meta {:arglists ([a idx ret init expr]), :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret."}, :source "(defmacro areduce\n  \"Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.\"\n  {:added \"1.0\"}\n  [a idx ret init expr]\n  `(let [a# ~a l# (alength a#)]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx l#)\n         (recur (unchecked-inc-int ~idx) ~expr)\n         ~ret))))", :spec nil, :examples []} {:sym array-map, :meta {:arglists ([] [& keyvals]), :doc "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc."}, :source "(defn array-map\n  \"Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (. clojure.lang.PersistentArrayMap EMPTY))\n  ([& keyvals]\n     (clojure.lang.PersistentArrayMap/createAsIfByAssoc (to-array keyvals))))", :spec nil, :examples []} {:sym as->, :meta {:arglists ([expr name & forms]), :doc "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form."}, :source "(defmacro as->\n  \"Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.\"\n  {:added \"1.5\"}\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))", :spec nil, :examples []} {:sym aset, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val."}, :source "(defn aset\n  \"Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.\"\n  {:inline (fn [a i v] `(. clojure.lang.RT (aset ~a (int ~i) ~v)))\n   :inline-arities #{3}\n   :added \"1.0\"}\n  ([array idx val]\n   (. Array (set array idx val))\n   val)\n  ([array idx idx2 & idxv]\n   (apply aset (aget array idx) idx2 idxv)))", :spec nil, :examples []} {:sym aset-boolean, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of boolean. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of boolean. Returns val.\"\n    :added \"1.0\"}\n  aset-boolean setBoolean boolean)", :spec nil, :examples []} {:sym aset-byte, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of byte. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of byte. Returns val.\"\n    :added \"1.0\"}\n  aset-byte setByte byte)", :spec nil, :examples []} {:sym aset-char, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of char. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of char. Returns val.\"\n    :added \"1.0\"}\n  aset-char setChar char)", :spec nil, :examples []} {:sym aset-double, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of double. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of double. Returns val.\"\n    :added \"1.0\"}\n  aset-double setDouble double)", :spec nil, :examples []} {:sym aset-float, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of float. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of float. Returns val.\"\n    :added \"1.0\"}\n  aset-float setFloat float)", :spec nil, :examples []} {:sym aset-int, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of int. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of int. Returns val.\"\n    :added \"1.0\"}\n  aset-int setInt int)", :spec nil, :examples []} {:sym aset-long, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of long. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of long. Returns val.\"\n    :added \"1.0\"}\n  aset-long setLong long)", :spec nil, :examples []} {:sym aset-short, :meta {:arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on arrays of short. Returns val."}, :source "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of short. Returns val.\"\n    :added \"1.0\"}\n  aset-short setShort short)", :spec nil, :examples []} {:sym assert, :meta {:arglists ([x] [x message]), :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true."}, :source "(defmacro assert\n  \"Evaluates expr and throws an exception if it does not evaluate to\n  logical true.\"\n  {:added \"1.0\"}\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))", :spec nil, :examples []} {:sym assoc, :meta {:arglists ([map key val] [map key val & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector)."}, :source "(def\n ^{:arglists '([map key val] [map key val & kvs])\n   :doc \"assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).\"\n   :added \"1.0\"\n   :static true}\n assoc\n (fn ^:static assoc\n   ([map key val] (clojure.lang.RT/assoc map key val))\n   ([map key val & kvs]\n    (let [ret (clojure.lang.RT/assoc map key val)]\n      (if kvs\n        (if (next kvs)\n          (recur ret (first kvs) (second kvs) (nnext kvs))\n          (throw (IllegalArgumentException.\n                  \"assoc expects even number of arguments after map/vector, found odd number\")))\n        ret)))))", :spec nil, :examples []} {:sym assoc!, :meta {:arglists ([coll key val] [coll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, :source "(defn assoc!\n  \"When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.ITransientAssociative coll key val] (.assoc coll key val))\n  ([^clojure.lang.ITransientAssociative coll key val & kvs]\n   (let [ret (.assoc coll key val)]\n     (if kvs\n       (recur ret (first kvs) (second kvs) (nnext kvs))\n       ret))))", :spec nil, :examples []} {:sym assoc-in, :meta {:arglists ([m [k & ks] v]), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :source "(defn assoc-in\n  \"Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.\"\n  {:added \"1.0\"\n   :static true}\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))", :spec nil, :examples []} {:sym associative?, :meta {:arglists ([coll]), :doc "Returns true if coll implements Associative"}, :source "(defn associative?\n \"Returns true if coll implements Associative\"\n {:added \"1.0\"\n  :static true}\n  [coll] (instance? clojure.lang.Associative coll))", :spec nil, :examples []} {:sym atom, :meta {:arglists ([x] [x & options]), :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception."}, :source "(defn atom\n  \"Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.\"\n  {:added \"1.0\"\n   :static true}\n  ([x] (new clojure.lang.Atom x))\n  ([x & options] (setup-reference (atom x) options)))", :spec nil, :examples []} {:sym await, :meta {:arglists ([& agents]), :doc "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called."}, :source "(defn await\n  \"Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.\"\n  {:added \"1.0\"\n   :static true}\n  [& agents]\n  (io! \"await in transaction\"\n    (when *agent*\n      (throw (new Exception \"Can't await in agent action\")))\n    (let [latch (new java.util.concurrent.CountDownLatch (count agents))\n          count-down (fn [agent] (. latch (countDown)) agent)]\n      (doseq [agent agents]\n        (send agent count-down))\n      (. latch (await)))))", :spec nil, :examples []} {:sym await-for, :meta {:arglists ([timeout-ms & agents]), :doc "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise."}, :source "(defn await-for\n  \"Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.\"\n  {:added \"1.0\"\n   :static true}\n  [timeout-ms & agents]\n    (io! \"await-for in transaction\"\n     (when *agent*\n       (throw (new Exception \"Can't await in agent action\")))\n     (let [latch (new java.util.concurrent.CountDownLatch (count agents))\n           count-down (fn [agent] (. latch (countDown)) agent)]\n       (doseq [agent agents]\n           (send agent count-down))\n       (. latch (await  timeout-ms (. java.util.concurrent.TimeUnit MILLISECONDS))))))", :spec nil, :examples []} {:sym await1, :meta {:arglists ([a])}, :source "(defn ^:static await1 [^clojure.lang.Agent a]\n  (when (pos? (.getQueueCount a))\n    (await a))\n    a)", :spec nil, :examples []} {:sym bases, :meta {:arglists ([c]), :doc "Returns the immediate superclass and direct interfaces of c, if any"}, :source "(defn bases\n  \"Returns the immediate superclass and direct interfaces of c, if any\"\n  {:added \"1.0\"\n   :static true}\n  [^Class c]\n  (when c\n    (let [i (seq (.getInterfaces c))\n          s (.getSuperclass c)]\n      (if s (cons s i) i))))", :spec nil, :examples []} {:sym bean, :meta {:arglists ([x]), :doc "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties."}, :source "(defn bean\n  \"Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.\"\n  {:added \"1.0\"}\n  [^Object x]\n  (let [c (. x (getClass))\n\tpmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]\n\t\t\t (let [name (. pd (getName))\n\t\t\t       method (. pd (getReadMethod))]\n\t\t\t   (if (and method (zero? (alength (. method (getParameterTypes)))))\n\t\t\t     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))\n\t\t\t     m)))\n\t\t     {}\n\t\t     (seq (.. java.beans.Introspector\n\t\t\t      (getBeanInfo c)\n\t\t\t      (getPropertyDescriptors))))\n\tv (fn [k] ((pmap k)))\n        snapshot (fn []\n                   (reduce1 (fn [m e]\n                             (assoc m (key e) ((val e))))\n                           {} (seq pmap)))\n        thisfn (fn thisfn [plseq]\n                 (lazy-seq\n                   (when-let [pseq (seq plseq)]\n                     (cons (clojure.lang.MapEntry/create (first pseq) (v (first pseq)))\n                           (thisfn (rest pseq))))))]\n    (proxy [clojure.lang.APersistentMap]\n           []\n      (iterator [] (clojure.lang.SeqIterator. ^java.util.Iterator (thisfn (keys pmap))))\n      (containsKey [k] (contains? pmap k))\n      (entryAt [k] (when (contains? pmap k) (clojure.lang.MapEntry/create k (v k))))\n      (valAt ([k] (when (contains? pmap k) (v k)))\n\t     ([k default] (if (contains? pmap k) (v k) default)))\n      (cons [m] (conj (snapshot) m))\n      (count [] (count pmap))\n      (assoc [k v] (assoc (snapshot) k v))\n      (without [k] (dissoc (snapshot) k))\n      (seq [] (thisfn (keys pmap))))))", :spec nil, :examples []} {:sym bigdec, :meta {:arglists ([x]), :doc "Coerce to BigDecimal"}, :source "(defn bigdec\n  \"Coerce to BigDecimal\"\n  {:tag BigDecimal\n   :added \"1.0\"\n   :static true}\n  [x] (cond\n       (decimal? x) x\n       (float? x) (. BigDecimal valueOf (double x))\n       (ratio? x) (/ (BigDecimal. (.numerator ^clojure.lang.Ratio x)) (.denominator ^clojure.lang.Ratio x))\n       (instance? clojure.lang.BigInt x) (.toBigDecimal ^clojure.lang.BigInt x)\n       (instance? BigInteger x) (BigDecimal. ^BigInteger x)\n       (number? x) (BigDecimal/valueOf (long x))\n       :else (BigDecimal. x)))", :spec nil, :examples []} {:sym bigint, :meta {:arglists ([x]), :doc "Coerce to BigInt"}, :source "(defn bigint\n  \"Coerce to BigInt\"\n  {:tag clojure.lang.BigInt\n   :static true\n   :added \"1.3\"}\n  [x] (cond\n       (instance? clojure.lang.BigInt x) x\n       (instance? BigInteger x) (clojure.lang.BigInt/fromBigInteger x)\n       (decimal? x) (bigint (.toBigInteger ^BigDecimal x))\n       (float? x)  (bigint (. BigDecimal valueOf (double x)))\n       (ratio? x) (bigint (.bigIntegerValue ^clojure.lang.Ratio x))\n       (number? x) (clojure.lang.BigInt/valueOf (long x))\n       :else (bigint (BigInteger. x))))", :spec nil, :examples []} {:sym biginteger, :meta {:arglists ([x]), :doc "Coerce to BigInteger"}, :source "(defn biginteger\n  \"Coerce to BigInteger\"\n  {:tag BigInteger\n   :added \"1.0\"\n   :static true}\n  [x] (cond\n       (instance? BigInteger x) x\n       (instance? clojure.lang.BigInt x) (.toBigInteger ^clojure.lang.BigInt x)\n       (decimal? x) (.toBigInteger ^BigDecimal x)\n       (float? x) (.toBigInteger (. BigDecimal valueOf (double x)))\n       (ratio? x) (.bigIntegerValue ^clojure.lang.Ratio x)\n       (number? x) (BigInteger/valueOf (long x))\n       :else (BigInteger. x)))", :spec nil, :examples []} {:sym binding, :meta {:arglists ([bindings & body]), :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values."}, :source "(defmacro binding\n  \"binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (let [var-ize (fn [var-vals]\n                  (loop [ret [] vvs (seq var-vals)]\n                    (if vvs\n                      (recur  (conj (conj ret `(var ~(first vvs))) (second vvs))\n                             (next (next vvs)))\n                      (seq ret))))]\n    `(let []\n       (push-thread-bindings (hash-map ~@(var-ize bindings)))\n       (try\n         ~@body\n         (finally\n           (pop-thread-bindings))))))", :spec nil, :examples []} {:sym bit-and, :meta {:arglists ([x y] [x y & more]), :doc "Bitwise and"}, :source "(defn bit-and\n  \"Bitwise and\"\n   {:inline (nary-inline 'and)\n    :inline-arities >1?\n    :added \"1.0\"}\n   ([x y] (. clojure.lang.Numbers and x y))\n   ([x y & more]\n      (reduce1 bit-and (bit-and x y) more)))", :spec nil, :examples []} {:sym bit-and-not, :meta {:arglists ([x y] [x y & more]), :doc "Bitwise and with complement"}, :source "(defn bit-and-not\n  \"Bitwise and with complement\"\n  {:inline (nary-inline 'andNot)\n   :inline-arities >1?\n   :added \"1.0\"\n   :static true}\n  ([x y] (. clojure.lang.Numbers andNot x y))\n  ([x y & more]\n    (reduce1 bit-and-not (bit-and-not x y) more)))", :spec nil, :examples []} {:sym bit-clear, :meta {:arglists ([x n]), :doc "Clear bit at index n"}, :source "(defn bit-clear\n  \"Clear bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers clearBit x n))", :spec nil, :examples []} {:sym bit-flip, :meta {:arglists ([x n]), :doc "Flip bit at index n"}, :source "(defn bit-flip\n  \"Flip bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers flipBit x n))", :spec nil, :examples []} {:sym bit-not, :meta {:arglists ([x]), :doc "Bitwise complement"}, :source "(defn bit-not\n  \"Bitwise complement\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (not ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers not x))", :spec nil, :examples []} {:sym bit-or, :meta {:arglists ([x y] [x y & more]), :doc "Bitwise or"}, :source "(defn bit-or\n  \"Bitwise or\"\n  {:inline (nary-inline 'or)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x y] (. clojure.lang.Numbers or x y))\n  ([x y & more]\n    (reduce1 bit-or (bit-or x y) more)))", :spec nil, :examples []} {:sym bit-set, :meta {:arglists ([x n]), :doc "Set bit at index n"}, :source "(defn bit-set\n  \"Set bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers setBit x n))", :spec nil, :examples []} {:sym bit-shift-left, :meta {:arglists ([x n]), :doc "Bitwise shift left"}, :source "(defn bit-shift-left\n  \"Bitwise shift left\"\n  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftLeft ~x ~n)))\n   :added \"1.0\"}\n  [x n] (. clojure.lang.Numbers shiftLeft x n))", :spec nil, :examples []} {:sym bit-shift-right, :meta {:arglists ([x n]), :doc "Bitwise shift right"}, :source "(defn bit-shift-right\n  \"Bitwise shift right\"\n  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftRight ~x ~n)))\n   :added \"1.0\"}\n  [x n] (. clojure.lang.Numbers shiftRight x n))", :spec nil, :examples []} {:sym bit-test, :meta {:arglists ([x n]), :doc "Test bit at index n"}, :source "(defn bit-test\n  \"Test bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers testBit x n))", :spec nil, :examples []} {:sym bit-xor, :meta {:arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, :source "(defn bit-xor\n  \"Bitwise exclusive or\"\n  {:inline (nary-inline 'xor)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x y] (. clojure.lang.Numbers xor x y))\n  ([x y & more]\n    (reduce1 bit-xor (bit-xor x y) more)))", :spec nil, :examples []} {:sym boolean, :meta {:arglists ([x]), :doc "Coerce to boolean"}, :source "(defn boolean\n  \"Coerce to boolean\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (booleanCast ~x)))\n   :added \"1.0\"}\n  [x] (clojure.lang.RT/booleanCast x))", :spec nil, :examples []} {:sym boolean-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of booleans"}, :source "(defn boolean-array\n  \"Creates an array of booleans\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers boolean_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers boolean_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers boolean_array size init-val-or-seq)))", :spec nil, :examples []} {:sym boolean?, :meta {:arglists ([x]), :doc "Return true if x is a Boolean"}, :source "(defn boolean?\n  \"Return true if x is a Boolean\"\n  {:added \"1.9\"}\n  [x] (instance? Boolean x))", :spec nil, :examples []} {:sym booleans, :meta {:arglists ([xs]), :doc "Casts to boolean[]"}, :source "(definline booleans\n  \"Casts to boolean[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers booleans ~xs))", :spec nil, :examples []} {:sym bound-fn, :meta {:arglists ([& fntail]), :doc "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place."}, :source "(defmacro bound-fn\n  \"Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.\"\n  {:added \"1.1\"}\n  [& fntail]\n  `(bound-fn* (fn ~@fntail)))", :spec nil, :examples []} {:sym bound-fn*, :meta {:arglists ([f]), :doc "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place."}, :source "(defn bound-fn*\n  \"Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.\"\n  {:added \"1.1\"\n   :static true}\n  [f]\n  (let [bindings (get-thread-bindings)]\n    (fn [& args]\n      (apply with-bindings* bindings f args))))", :spec nil, :examples []} {:sym bound?, :meta {:arglists ([& vars]), :doc "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided."}, :source "(defn bound?\n  \"Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.\"\n  {:added \"1.2\"\n   :static true}\n  [& vars]\n  (every? #(.isBound ^clojure.lang.Var %) vars))", :spec nil, :examples []} {:sym bounded-count, :meta {:arglists ([n coll]), :doc "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq"}, :source "(defn bounded-count\n  \"If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq\"\n  {:added \"1.9\"}\n  [n coll]\n  (if (counted? coll)\n    (count coll)\n    (loop [i 0 s (seq coll)]\n      (if (and s (< i n))\n        (recur (inc i) (next s))\n        i))))", :spec nil, :examples []} {:sym butlast, :meta {:arglists ([coll]), :doc "Return a seq of all but the last item in coll, in linear time"}, :source "(def \n ^{:arglists '([coll])\n   :doc \"Return a seq of all but the last item in coll, in linear time\"\n   :added \"1.0\"\n   :static true}\n butlast (fn ^:static butlast [s]\n           (loop [ret [] s s]\n             (if (next s)\n               (recur (conj ret (first s)) (next s))\n               (seq ret)))))", :spec nil, :examples []} {:sym byte, :meta {:arglists ([x]), :doc "Coerce to byte"}, :source "(defn byte\n  \"Coerce to byte\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedByteCast 'byteCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/byteCast x))", :spec nil, :examples []} {:sym byte-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of bytes"}, :source "(defn byte-array\n  \"Creates an array of bytes\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers byte_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers byte_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers byte_array size init-val-or-seq)))", :spec nil, :examples []} {:sym bytes, :meta {:arglists ([xs]), :doc "Casts to bytes[]"}, :source "(definline bytes\n  \"Casts to bytes[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers bytes ~xs))", :spec nil, :examples []} {:sym bytes?, :meta {:arglists ([x]), :doc "Return true if x is a byte array"}, :source "(defn bytes?\n  \"Return true if x is a byte array\"\n  {:added \"1.9\"}\n  [x] (if (nil? x)\n        false\n        (-> x class .getComponentType (= Byte/TYPE))))", :spec nil, :examples []} {:sym case, :meta {:arglists ([e & clauses]), :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type."}, :source "(defmacro case \n  \"Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.\"\n  {:added \"1.2\"}\n\n  [e & clauses]\n  (let [ge (with-meta (gensym) {:tag Object})\n        default (if (odd? (count clauses)) \n                  (last clauses)\n                  `(throw (IllegalArgumentException. (str \"No matching clause: \" ~ge))))]\n    (if (> 2 (count clauses))\n      `(let [~ge ~e] ~default)\n      (let [pairs (partition 2 clauses)\n            assoc-test (fn assoc-test [m test expr]\n                         (if (contains? m test)\n                           (throw (IllegalArgumentException. (str \"Duplicate case test constant: \" test)))\n                           (assoc m test expr)))\n            pairs (reduce1\n                       (fn [m [test expr]]\n                         (if (seq? test)\n                           (reduce1 #(assoc-test %1 %2 expr) m test)\n                           (assoc-test m test expr)))\n                       {} pairs)\n            tests (keys pairs)\n            thens (vals pairs)\n            mode (cond\n                   (every? #(and (integer? %) (<= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)\n                   :ints\n                   (every? keyword? tests)\n                   :identity\n                   :else :hashes)]\n        (condp = mode\n          :ints\n          (let [[shift mask imap switch-type] (prep-ints tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))\n          :hashes\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))\n          :identity\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))", :spec nil, :examples []} {:sym cast, :meta {:arglists ([c x]), :doc "Throws a ClassCastException if x is not a c, else returns x."}, :source "(defn cast\n  \"Throws a ClassCastException if x is not a c, else returns x.\"\n  {:added \"1.0\"\n   :static true}\n  [^Class c x] \n  (. c (cast x)))", :spec nil, :examples []} {:sym cat, :meta {:arglists ([rf]), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, :source "(defn cat\n  \"A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.\"\n  {:added \"1.7\"}\n  [rf]\n  (let [rrf (preserving-reduced rf)]  \n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rrf result input)))))", :spec nil, :examples []} {:sym char, :meta {:arglists ([x]), :doc "Coerce to char"}, :source "(defn char\n  \"Coerce to char\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedCharCast 'charCast) ~x)))\n   :added \"1.1\"}\n  [x] (. clojure.lang.RT (charCast x)))", :spec nil, :examples []} {:sym char-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of chars"}, :source "(defn char-array\n  \"Creates an array of chars\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers char_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers char_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers char_array size init-val-or-seq)))", :spec nil, :examples []} {:sym char-escape-string, :meta {:doc "Returns escape string for char or nil if none"}, :source "(def ^{:tag String \n       :doc \"Returns escape string for char or nil if none\"\n       :added \"1.0\"}\n  char-escape-string\n    {\\newline \"\\\\n\"\n     \\tab  \"\\\\t\"\n     \\return \"\\\\r\"\n     \\\" \"\\\\\\\"\"\n     \\\\  \"\\\\\\\\\"\n     \\formfeed \"\\\\f\"\n     \\backspace \"\\\\b\"})", :spec nil, :examples []} {:sym char-name-string, :meta {:doc "Returns name string for char or nil if none"}, :source "(def ^{:tag String\n       :doc \"Returns name string for char or nil if none\"\n       :added \"1.0\"} \n char-name-string\n   {\\newline \"newline\"\n    \\tab \"tab\"\n    \\space \"space\"\n    \\backspace \"backspace\"\n    \\formfeed \"formfeed\"\n    \\return \"return\"})", :spec nil, :examples []} {:sym char?, :meta {:arglists ([x]), :doc "Return true if x is a Character"}, :source "(def\n ^{:arglists '([x])\n   :doc \"Return true if x is a Character\"\n   :added \"1.0\"\n   :static true}\n char? (fn ^:static char? [x] (instance? Character x)))", :spec nil, :examples []} {:sym chars, :meta {:arglists ([xs]), :doc "Casts to chars[]"}, :source "(definline chars\n  \"Casts to chars[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers chars ~xs))", :spec nil, :examples []} {:sym chunk, :meta {:arglists ([b])}, :source "(defn ^:static ^clojure.lang.IChunk chunk [^clojure.lang.ChunkBuffer b]\n  (.chunk b))", :spec nil, :examples []} {:sym chunk-append, :meta {:arglists ([b x])}, :source "(defn ^:static chunk-append [^clojure.lang.ChunkBuffer b x]\n  (.add b x))", :spec nil, :examples []} {:sym chunk-buffer, :meta {:arglists ([capacity])}, :source "(defn ^:static ^clojure.lang.ChunkBuffer chunk-buffer ^clojure.lang.ChunkBuffer [capacity]\n  (clojure.lang.ChunkBuffer. capacity))", :spec nil, :examples []} {:sym chunk-cons, :meta {:arglists ([chunk rest])}, :source "(defn ^:static chunk-cons [chunk rest]\n  (if (clojure.lang.Numbers/isZero (clojure.lang.RT/count chunk))\n    rest\n    (clojure.lang.ChunkedCons. chunk rest)))", :spec nil, :examples []} {:sym chunk-first, :meta {:arglists ([s])}, :source "(defn ^:static  ^clojure.lang.IChunk chunk-first ^clojure.lang.IChunk [^clojure.lang.IChunkedSeq s]\n  (.chunkedFirst s))", :spec nil, :examples []} {:sym chunk-next, :meta {:arglists ([s])}, :source "(defn ^:static ^clojure.lang.ISeq chunk-next ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]\n  (.chunkedNext s))", :spec nil, :examples []} {:sym chunk-rest, :meta {:arglists ([s])}, :source "(defn ^:static ^clojure.lang.ISeq chunk-rest ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]\n  (.chunkedMore s))", :spec nil, :examples []} {:sym chunked-seq?, :meta {:arglists ([s])}, :source "(defn ^:static chunked-seq? [s]\n  (instance? clojure.lang.IChunkedSeq s))", :spec nil, :examples []} {:sym class, :meta {:arglists ([x]), :doc "Returns the Class of x"}, :source "(defn class\n  \"Returns the Class of x\"\n  {:added \"1.0\"\n   :static true}\n  ^Class [^Object x] (if (nil? x) x (. x (getClass))))", :spec nil, :examples []} {:sym class?, :meta {:arglists ([x]), :doc "Returns true if x is an instance of Class"}, :source "(defn class?\n  \"Returns true if x is an instance of Class\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? Class x))", :spec nil, :examples []} {:sym clear-agent-errors, :meta {:arglists ([a]), :doc "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur."}, :source "(defn clear-agent-errors\n  \"DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.\"\n  {:added \"1.0\"\n   :deprecated \"1.2\"}\n  [^clojure.lang.Agent a] (restart-agent a (.deref a)))", :spec nil, :examples []} {:sym clojure-version, :meta {:arglists ([]), :doc "Returns clojure version as a printable string."}, :source "(defn\n  clojure-version \n  \"Returns clojure version as a printable string.\"\n  {:added \"1.0\"}\n  []\n  (str (:major *clojure-version*)\n       \".\"\n       (:minor *clojure-version*)\n       (when-let [i (:incremental *clojure-version*)]\n         (str \".\" i))\n       (when-let [q (:qualifier *clojure-version*)]\n         (when (pos? (count q)) (str \"-\" q)))\n       (when (:interim *clojure-version*)\n         \"-SNAPSHOT\")))", :spec nil, :examples []} {:sym coll?, :meta {:arglists ([x]), :doc "Returns true if x implements IPersistentCollection"}, :source "(defn coll?\n  \"Returns true if x implements IPersistentCollection\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentCollection x))", :spec nil, :examples []} {:sym comment, :meta {:arglists ([& body]), :doc "Ignores body, yields nil"}, :source "(defmacro comment\n  \"Ignores body, yields nil\"\n  {:added \"1.0\"}\n  [& body])", :spec nil, :examples []} {:sym commute, :meta {:arglists ([ref fun & args]), :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set."}, :source "(defn commute\n  \"Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.\"\n  {:added \"1.0\"\n   :static true}\n\n  [^clojure.lang.Ref ref fun & args]\n    (. ref (commute fun args)))", :spec nil, :examples []} {:sym comp, :meta {:arglists ([] [f] [f g] [f g & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, :source "(defn comp\n  \"Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] identity)\n  ([f] f)\n  ([f g] \n     (fn \n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g & fs]\n     (reduce1 comp (list* f g fs))))", :spec nil, :examples []} {:sym comparator, :meta {:arglists ([pred]), :doc "Returns an implementation of java.util.Comparator based upon pred."}, :source "(defn comparator\n  \"Returns an implementation of java.util.Comparator based upon pred.\"\n  {:added \"1.0\"\n   :static true}\n  [pred]\n    (fn [x y]\n      (cond (pred x y) -1 (pred y x) 1 :else 0)))", :spec nil, :examples []} {:sym compare, :meta {:arglists ([x y]), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable"}, :source "(defn compare\n  \"Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable\"\n  {\n   :inline (fn [x y] `(. clojure.lang.Util compare ~x ~y))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Util (compare x y)))", :spec nil, :examples []} {:sym compare-and-set!, :meta {:arglists ([atom oldval newval]), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false"}, :source "(defn compare-and-set!\n  \"Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IAtom atom oldval newval] (.compareAndSet atom oldval newval))", :spec nil, :examples []} {:sym compile, :meta {:arglists ([lib]), :doc "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath."}, :source "(defn compile\n  \"Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.\"\n  {:added \"1.0\"}\n  [lib]\n  (binding [*compile-files* true]\n    (load-one lib true true))\n  lib)", :spec nil, :examples []} {:sym complement, :meta {:arglists ([f]), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :source "(defn complement\n  \"Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.\"\n  {:added \"1.0\"\n   :static true}\n  [f] \n  (fn \n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))", :spec nil, :examples []} {:sym completing, :meta {:arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, :source "(defn completing\n  \"Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.\"\n  {:added \"1.7\"}\n  ([f] (completing f identity))\n  ([f cf]\n     (fn\n       ([] (f))\n       ([x] (cf x))\n       ([x y] (f x y)))))", :spec nil, :examples []} {:sym concat, :meta {:arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, :source "(defn concat\n  \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))", :spec nil, :examples []} {:sym cond, :meta {:arglists ([& clauses]), :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil."}, :source "(defmacro cond\n  \"Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.\"\n  {:added \"1.0\"}\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))", :spec nil, :examples []} {:sym cond->, :meta {:arglists ([expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression."}, :source "(defmacro cond->\n  \"Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.\"\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        steps (map (fn [[test step]] `(if ~test (-> ~g ~step) ~g))\n                   (partition 2 clauses))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))", :spec nil, :examples []} {:sym cond->>, :meta {:arglists ([expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression."}, :source "(defmacro cond->>\n  \"Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.\"\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        steps (map (fn [[test step]] `(if ~test (->> ~g ~step) ~g))\n                   (partition 2 clauses))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))", :spec nil, :examples []} {:sym condp, :meta {:arglists ([pred expr & clauses]), :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown."}, :source "(defmacro condp\n  \"Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.\"\n  {:added \"1.0\"}\n\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (IllegalArgumentException. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))", :spec nil, :examples []} {:sym conj, :meta {:arglists ([coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type."}, :source "(def\n ^{:arglists '([coll x] [coll x & xs])\n   :doc \"conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type.\"\n   :added \"1.0\"\n   :static true}\n conj (fn ^:static conj\n        ([] [])\n        ([coll] coll)\n        ([coll x] (clojure.lang.RT/conj coll x))\n        ([coll x & xs]\n         (if xs\n           (recur (clojure.lang.RT/conj coll x) (first xs) (next xs))\n           (clojure.lang.RT/conj coll x)))))", :spec nil, :examples []} {:sym conj!, :meta {:arglists ([] [coll] [coll x]), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, :source "(defn conj!\n  \"Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.\"\n  {:added \"1.1\"\n   :static true}\n  ([] (transient []))\n  ([coll] coll)\n  ([^clojure.lang.ITransientCollection coll x]\n     (.conj coll x)))", :spec nil, :examples []} {:sym cons, :meta {:arglists ([x seq]), :doc "Returns a new seq where x is the first element and seq is\n    the rest."}, :source "(def\n ^{:arglists '([x seq])\n    :doc \"Returns a new seq where x is the first element and seq is\n    the rest.\"\n   :added \"1.0\"\n   :static true}\n\n cons (fn* ^:static cons [x seq] (. clojure.lang.RT (cons x seq))))", :spec nil, :examples []} {:sym constantly, :meta {:arglists ([x]), :doc "Returns a function that takes any number of arguments and returns x."}, :source "(defn constantly\n  \"Returns a function that takes any number of arguments and returns x.\"\n  {:added \"1.0\"\n   :static true}\n  [x] (fn [& args] x))", :spec nil, :examples []} {:sym construct-proxy, :meta {:arglists ([c & ctor-args]), :doc "Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy."}, :source "(defn construct-proxy\n  \"Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.\"\n  {:added \"1.0\"}\n  [c & ctor-args]\n    (. Reflector (invokeConstructor c (to-array ctor-args))))", :spec nil, :examples []} {:sym contains?, :meta {:arglists ([coll key]), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :source "(defn contains?\n  \"Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.\"\n  {:added \"1.0\"\n   :static true}\n  [coll key] (. clojure.lang.RT (contains coll key)))", :spec nil, :examples []} {:sym count, :meta {:arglists ([coll]), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps"}, :source "(defn count\n  \"Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (count ~x)))\n   :added \"1.0\"}\n  [coll] (clojure.lang.RT/count coll))", :spec nil, :examples []} {:sym counted?, :meta {:arglists ([coll]), :doc "Returns true if coll implements count in constant time"}, :source "(defn counted?\n \"Returns true if coll implements count in constant time\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Counted coll))", :spec nil, :examples []} {:sym create-ns, :meta {:arglists ([sym]), :doc "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name."}, :source "(defn create-ns\n  \"Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/findOrCreate sym))", :spec nil, :examples []} {:sym create-struct, :meta {:arglists ([& keys]), :doc "Returns a structure basis object."}, :source "(defn create-struct\n  \"Returns a structure basis object.\"\n  {:added \"1.0\"\n   :static true}\n  [& keys]\n    (. clojure.lang.PersistentStructMap (createSlotMap keys)))", :spec nil, :examples []} {:sym cycle, :meta {:arglists ([coll]), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :source "(defn cycle\n  \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (clojure.lang.Cycle/create (seq coll)))", :spec nil, :examples []} {:sym dec, :meta {:arglists ([x]), :doc "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'"}, :source "(defn dec\n  \"Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_dec 'dec) ~x)))\n   :added \"1.2\"}\n  [x] (. clojure.lang.Numbers (dec x)))", :spec nil, :examples []} {:sym dec', :meta {:arglists ([x]), :doc "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec"}, :source "(defn dec'\n  \"Returns a number one less than num. Supports arbitrary precision.\n  See also: dec\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (decP ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (decP x)))", :spec nil, :examples []} {:sym decimal?, :meta {:arglists ([n]), :doc "Returns true if n is a BigDecimal"}, :source "(defn decimal?\n  \"Returns true if n is a BigDecimal\"\n  {:added \"1.0\"\n   :static true}\n  [n] (instance? BigDecimal n))", :spec nil, :examples []} {:sym declare, :meta {:arglists ([& names]), :doc "defs the supplied var names with no bindings, useful for making forward declarations."}, :source "(defmacro declare\n  \"defs the supplied var names with no bindings, useful for making forward declarations.\"\n  {:added \"1.0\"}\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))", :spec nil, :examples []} {:sym dedupe, :meta {:arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, :source "(defn dedupe\n  \"Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.\"\n  {:added \"1.7\"}\n  ([]\n   (fn [rf]\n     (let [pv (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pv]\n              (vreset! pv input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))", :spec nil, :examples []} {:sym default-data-readers, :meta {:doc "Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*."}, :source "(def ^{:added \"1.4\"} default-data-readers\n  \"Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*.\"\n  (merge\n    {'uuid #'clojure.uuid/default-uuid-reader}\n    (when-class \"java.sql.Timestamp\"\n      {'inst #'clojure.instant/read-instant-date})))", :spec nil, :examples []} {:sym definline, :meta {:arglists ([name & decl]), :doc "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args."}, :source "(defmacro definline\n  \"Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.\"\n  {:added \"1.0\"}\n  [name & decl]\n  (let [[pre-args [args expr]] (split-with (comp not vector?) decl)]\n    `(do\n       (defn ~name ~@pre-args ~args ~(apply (eval (list `fn args expr)) args))\n       (alter-meta! (var ~name) assoc :inline (fn ~name ~args ~expr))\n       (var ~name))))", :spec nil, :examples []} {:sym definterface, :meta {:arglists ([name & sigs]), :doc "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))"}, :source "(defmacro definterface\n  \"Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))\"\n  {:added \"1.2\"} ;; Present since 1.2, but made public in 1.5.\n  [name & sigs]\n  (let [tag (fn [x] (or (:tag (meta x)) Object))\n        psig (fn [[name [& args]]]\n               (vector name (vec (map tag args)) (tag name) (map meta args)))\n        cname (with-meta (symbol (str (namespace-munge *ns*) \".\" name)) (meta name))]\n    `(let [] \n       (gen-interface :name ~cname :methods ~(vec (map psig sigs)))\n       (import ~cname))))", :spec nil, :examples []} {:sym defmacro, :meta {:arglists ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?]), :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called."}, :source "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))", :spec nil, :examples []} {:sym defmethod, :meta {:arglists ([multifn dispatch-val & fn-tail]), :doc "Creates and installs a new method of multimethod associated with dispatch-value. "}, :source "(defmacro defmethod\n  \"Creates and installs a new method of multimethod associated with dispatch-value. \"\n  {:added \"1.0\"}\n  [multifn dispatch-val & fn-tail]\n  `(. ~(with-meta multifn {:tag 'clojure.lang.MultiFn}) addMethod ~dispatch-val (fn ~@fn-tail)))", :spec nil, :examples []} {:sym defmulti, :meta {:arglists ([name docstring? attr-map? dispatch-fn & options]), :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form)."}, :source "(defmacro defmulti\n  \"Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).\"\n  {:arglists '([name docstring? attr-map? dispatch-fn & options])\n   :added \"1.0\"}\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)\n        mm-name (with-meta mm-name m)]\n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          hierarchy (get options :hierarchy #'global-hierarchy)]\n      (check-valid-options options :default :hierarchy)\n      `(let [v# (def ~mm-name)]\n         (when-not (and (.hasRoot v#) (instance? clojure.lang.MultiFn (deref v#)))\n           (def ~mm-name\n                (new clojure.lang.MultiFn ~(name mm-name) ~dispatch-fn ~default ~hierarchy)))))))", :spec nil, :examples []} {:sym defn, :meta {:arglists ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]), :doc "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions."}, :source "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n\t\t\t\t\t\t\t\t;;(cons `fn fdecl)\n\t\t\t\t\t\t\t\t(with-meta (cons `fn fdecl) {:rettag (:tag m)})))))", :spec "(clojure.spec.alpha/fspec\n :args\n :clojure.core.specs.alpha/defn-args\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym defn-, :meta {:arglists ([name & decls]), :doc "same as defn, yielding non-public def"}, :source "(defmacro defn-\n  \"same as defn, yielding non-public def\"\n  {:added \"1.0\"}\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))", :spec "(clojure.spec.alpha/fspec\n :args\n :clojure.core.specs.alpha/defn-args\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym defonce, :meta {:arglists ([name expr]), :doc "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated"}, :source "(defmacro defonce\n  \"defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated\"\n  {:added \"1.0\"}\n  [name expr]\n  `(let [v# (def ~name)]\n     (when-not (.hasRoot v#)\n       (def ~name ~expr))))", :spec nil, :examples []} {:sym defprotocol, :meta {:arglists ([name & opts+sigs]), :doc "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17"}, :source "(defmacro defprotocol \n  \"A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \\\"A doc string for AProtocol abstraction\\\"\n\n  ;method signatures\n    (bar [this a b] \\\"bar docs\\\")\n    (baz [this a] [this a b] [this a b c] \\\"baz docs\\\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17\"\n  {:added \"1.2\"} \n  [name & opts+sigs]\n  (emit-protocol name opts+sigs))", :spec nil, :examples []} {:sym defrecord, :meta {:arglists ([name [& fields] & opts+specs]), :doc "(defrecord name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the record class will cause the\n             namespace in which the record was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta,\n  __extmap, __hash and __hasheq are currently reserved and should not\n  be used when defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values."}, :source "(defmacro defrecord\n  \"(defrecord name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the record class will cause the\n             namespace in which the record was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta,\n  __extmap, __hash and __hasheq are currently reserved and should not\n  be used when defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.\"\n  {:added \"1.2\"\n   :arglists '([name [& fields] & opts+specs])}\n\n  [name fields & opts+specs]\n  (validate-fields fields name)\n  (let [gname name\n        [interfaces methods opts] (parse-opts+specs opts+specs)\n        ns-part (namespace-munge *ns*)\n        classname (symbol (str ns-part \".\" gname))\n        hinted-fields fields\n        fields (vec (map #(with-meta % nil) fields))]\n    `(let []\n       (declare ~(symbol (str  '-> gname)))\n       (declare ~(symbol (str 'map-> gname)))\n       ~(emit-defrecord name gname (vec hinted-fields) (vec interfaces) methods opts)\n       (import ~classname)\n       ~(build-positional-factory gname classname fields)\n       (defn ~(symbol (str 'map-> gname))\n         ~(str \"Factory function for class \" classname \", taking a map of keywords to field values.\")\n         ([m#] (~(symbol (str classname \"/create\"))\n                (if (instance? clojure.lang.MapEquivalence m#) m# (into {} m#)))))\n       ~classname)))", :spec nil, :examples []} {:sym defstruct, :meta {:arglists ([name & keys]), :doc "Same as (def name (create-struct keys...))"}, :source "(defmacro defstruct\n  \"Same as (def name (create-struct keys...))\"\n  {:added \"1.0\"\n   :static true}\n  [name & keys]\n  `(def ~name (create-struct ~@keys)))", :spec nil, :examples []} {:sym deftype, :meta {:arglists ([name [& fields] & opts+specs]), :doc "(deftype name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the type class will cause the\n             namespace in which the type was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta, __extmap, __hash and __hasheq are currently\n  reserved and should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields"}, :source "(defmacro deftype\n  \"(deftype name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the type class will cause the\n             namespace in which the type was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta, __extmap, __hash and __hasheq are currently\n  reserved and should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields\"\n  {:added \"1.2\"\n   :arglists '([name [& fields] & opts+specs])}\n\n  [name fields & opts+specs]\n  (validate-fields fields name)\n  (let [gname name\n        [interfaces methods opts] (parse-opts+specs opts+specs)\n        ns-part (namespace-munge *ns*)\n        classname (symbol (str ns-part \".\" gname))\n        hinted-fields fields\n        fields (vec (map #(with-meta % nil) fields))\n        [field-args over] (split-at 20 fields)]\n    `(let []\n       ~(emit-deftype* name gname (vec hinted-fields) (vec interfaces) methods opts)\n       (import ~classname)\n       ~(build-positional-factory gname classname fields)\n       ~classname)))", :spec nil, :examples []} {:sym delay, :meta {:arglists ([& body]), :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?"}, :source "(defmacro delay\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?\"\n  {:added \"1.0\"}\n  [& body]\n    (list 'new 'clojure.lang.Delay (list* `^{:once true} fn* [] body)))", :spec nil, :examples []} {:sym delay?, :meta {:arglists ([x]), :doc "returns true if x is a Delay created with delay"}, :source "(defn delay?\n  \"returns true if x is a Delay created with delay\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Delay x))", :spec nil, :examples []} {:sym deliver, :meta {:arglists ([promise val]), :doc "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect."}, :source "(defn deliver\n  \"Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.\"\n  {:added \"1.1\"\n   :static true}\n  [promise val] (promise val))", :spec nil, :examples []} {:sym denominator, :meta {:arglists ([r]), :doc "Returns the denominator part of a Ratio."}, :source "(defn denominator\n  \"Returns the denominator part of a Ratio.\"\n  {:tag BigInteger\n   :added \"1.2\"\n   :static true}\n  [r]\n  (.denominator ^clojure.lang.Ratio r))", :spec nil, :examples []} {:sym deref, :meta {:arglists ([ref] [ref timeout-ms timeout-val]), :doc "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?."}, :source "(defn deref\n  \"Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.\"\n  {:added \"1.0\"\n   :static true}\n  ([ref] (if (instance? clojure.lang.IDeref ref)\n           (.deref ^clojure.lang.IDeref ref)\n           (deref-future ref)))\n  ([ref timeout-ms timeout-val]\n     (if (instance? clojure.lang.IBlockingDeref ref)\n       (.deref ^clojure.lang.IBlockingDeref ref timeout-ms timeout-val)\n       (deref-future ref timeout-ms timeout-val))))", :spec nil, :examples []} {:sym derive, :meta {:arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, :source "(defn derive\n  \"Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  {:added \"1.0\"}\n  ([tag parent]\n   (assert (namespace parent))\n   (assert (or (class? tag) (and (instance? clojure.lang.Named tag) (namespace tag))))\n\n   (alter-var-root #'global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   (assert (instance? clojure.lang.Named parent))\n\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce1 (fn [ret k]\n                        (assoc ret k\n                               (reduce1 conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (Exception. (print-str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (Exception. (print-str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))", :spec nil, :examples []} {:sym descendants, :meta {:arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships."}, :source "(defn descendants\n  \"Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.\"\n  {:added \"1.0\"}\n  ([tag] (descendants global-hierarchy tag))\n  ([h tag] (if (class? tag)\n             (throw (java.lang.UnsupportedOperationException. \"Can't get descendants of classes\"))\n             (not-empty (get (:descendants h) tag)))))", :spec nil, :examples []} {:sym destructure, :meta {:arglists ([bindings])}, :source "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n             (let [pvec\n                   (fn [bvec b val]\n                     (let [gvec (gensym \"vec__\")\n                           gseq (gensym \"seq__\")\n                           gfirst (gensym \"first__\")\n                           has-rest (some #{'&} b)]\n                       (loop [ret (let [ret (conj bvec gvec val)]\n                                    (if has-rest\n                                      (conj ret gseq (list `seq gvec))\n                                      ret))\n                              n 0\n                              bs b\n                              seen-rest? false]\n                         (if (seq bs)\n                           (let [firstb (first bs)]\n                             (cond\n                              (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                   n\n                                                   (nnext bs)\n                                                   true)\n                              (= firstb :as) (pb ret (second bs) gvec)\n                              :else (if seen-rest?\n                                      (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                      (recur (pb (if has-rest\n                                                   (conj ret\n                                                         gfirst `(first ~gseq)\n                                                         gseq `(next ~gseq))\n                                                   ret)\n                                                 firstb\n                                                 (if has-rest\n                                                   gfirst\n                                                   (list `nth gvec n nil)))\n                                             (inc n)\n                                             (next bs)\n                                             seen-rest?))))\n                           ret))))\n                   pmap\n                   (fn [bvec b v]\n                     (let [gmap (gensym \"map__\")\n                           gmapseq (with-meta gmap {:tag 'clojure.lang.ISeq})\n                           defaults (:or b)]\n                       (loop [ret (-> bvec (conj gmap) (conj v)\n                                      (conj gmap) (conj `(if (seq? ~gmap) (clojure.lang.PersistentHashMap/create (seq ~gmapseq)) ~gmap))\n                                      ((fn [ret]\n                                         (if (:as b)\n                                           (conj ret (:as b) gmap)\n                                           ret))))\n                              bes (let [transforms\n                                          (reduce1\n                                            (fn [transforms mk]\n                                              (if (keyword? mk)\n                                                (let [mkns (namespace mk)\n                                                      mkn (name mk)]\n                                                  (cond (= mkn \"keys\") (assoc transforms mk #(keyword (or mkns (namespace %)) (name %)))\n                                                        (= mkn \"syms\") (assoc transforms mk #(list `quote (symbol (or mkns (namespace %)) (name %))))\n                                                        (= mkn \"strs\") (assoc transforms mk str)\n                                                        :else transforms))\n                                                transforms))\n                                            {}\n                                            (keys b))]\n                                    (reduce1\n                                        (fn [bes entry]\n                                          (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                                   (dissoc bes (key entry))\n                                                   ((key entry) bes)))\n                                        (dissoc b :as :or)\n                                        transforms))]\n                         (if (seq bes)\n                           (let [bb (key (first bes))\n                                 bk (val (first bes))\n                                 local (if (instance? clojure.lang.Named bb) (with-meta (symbol nil (name bb)) (meta bb)) bb)\n                                 bv (if (contains? defaults local)\n                                      (list `get gmap bk (defaults local))\n                                      (list `get gmap bk))]\n                             (recur (if (ident? bb)\n                                      (-> ret (conj local bv))\n                                      (pb ret bb bv))\n                                    (next bes)))\n                           ret))))]\n               (cond\n                (symbol? b) (-> bvec (conj b) (conj v))\n                (vector? b) (pvec bvec b v)\n                (map? b) (pmap bvec b v)\n                :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))", :spec nil, :examples []} {:sym disj, :meta {:arglists ([set] [set key] [set key & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, :source "(defn disj\n  \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  {:added \"1.0\"\n   :static true}\n  ([set] set)\n  ([^clojure.lang.IPersistentSet set key]\n   (when set\n     (. set (disjoin key))))\n  ([set key & ks]\n   (when set\n     (let [ret (disj set key)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret)))))", :spec nil, :examples []} {:sym disj!, :meta {:arglists ([set] [set key] [set key & ks]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, :source "(defn disj!\n  \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  {:added \"1.1\"\n   :static true}\n  ([set] set)\n  ([^clojure.lang.ITransientSet set key]\n   (. set (disjoin key)))\n  ([^clojure.lang.ITransientSet set key & ks]\n   (let [ret (. set (disjoin key))]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))", :spec nil, :examples []} {:sym dissoc, :meta {:arglists ([map] [map key] [map key & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, :source "(defn dissoc\n  \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).\"\n  {:added \"1.0\"\n   :static true}\n  ([map] map)\n  ([map key]\n   (. clojure.lang.RT (dissoc map key)))\n  ([map key & ks]\n   (let [ret (dissoc map key)]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))", :spec nil, :examples []} {:sym dissoc!, :meta {:arglists ([map key] [map key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, :source "(defn dissoc!\n  \"Returns a transient map that doesn't contain a mapping for key(s).\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.ITransientMap map key] (.without map key))\n  ([^clojure.lang.ITransientMap map key & ks]\n   (let [ret (.without map key)]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))", :spec nil, :examples []} {:sym distinct, :meta {:arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided."}, :source "(defn distinct\n  \"Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([]\n   (fn [rf]\n     (let [seen (volatile! #{})]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n          (if (contains? @seen input)\n            result\n            (do (vswap! seen conj input)\n                (rf result input))))))))\n  ([coll]\n   (let [step (fn step [xs seen]\n                (lazy-seq\n                  ((fn [[f :as xs] seen]\n                     (when-let [s (seq xs)]\n                       (if (contains? seen f)\n                         (recur (rest s) seen)\n                         (cons f (step (rest s) (conj seen f))))))\n                   xs seen)))]\n     (step coll #{}))))", :spec nil, :examples []} {:sym distinct?, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, :source "(defn distinct?\n  \"Returns true if no two of the arguments are =\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (if (not= x y)\n     (loop [s #{x y} [x & etc :as xs] more]\n       (if xs\n         (if (contains? s x)\n           false\n           (recur (conj s x) etc))\n         true))\n     false)))", :spec nil, :examples []} {:sym doall, :meta {:arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, :source "(defn doall\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))", :spec nil, :examples []} {:sym dorun, :meta {:arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, :source "(defn dorun\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (when-let [s (seq coll)]\n     (recur (next s))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))", :spec nil, :examples []} {:sym doseq, :meta {:arglists ([seq-exprs & body]), :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil."}, :source "(defmacro doseq\n  \"Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \\\"for\\\".  Does not retain\n  the head of the sequence. Returns nil.\"\n  {:added \"1.0\"}\n  [seq-exprs & body]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)]\n                   (if (keyword? k)\n                     (let [steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)]\n                       (cond\n                         (= k :let) [needrec `(let ~v ~subform)]\n                         (= k :while) [false `(when ~v\n                                                ~subform\n                                                ~@(when needrec [recform]))]\n                         (= k :when) [false `(if ~v\n                                               (do\n                                                 ~subform\n                                                 ~@(when needrec [recform]))\n                                               ~recform)]))\n                     (let [seq- (gensym \"seq_\")\n                           chunk- (with-meta (gensym \"chunk_\")\n                                             {:tag 'clojure.lang.IChunk})\n                           count- (gensym \"count_\")\n                           i- (gensym \"i_\")\n                           recform `(recur (next ~seq-) nil 0 0)\n                           steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)\n                           recform-chunk \n                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))\n                           steppair-chunk (step recform-chunk (nnext exprs))\n                           subform-chunk (steppair-chunk 1)]\n                       [true\n                        `(loop [~seq- (seq ~v), ~chunk- nil,\n                                ~count- 0, ~i- 0]\n                           (if (< ~i- ~count-)\n                             (let [~k (.nth ~chunk- ~i-)]\n                               ~subform-chunk\n                               ~@(when needrec [recform-chunk]))\n                             (when-let [~seq- (seq ~seq-)]\n                               (if (chunked-seq? ~seq-)\n                                 (let [c# (chunk-first ~seq-)]\n                                   (recur (chunk-rest ~seq-) c#\n                                          (int (count c#)) (int 0)))\n                                 (let [~k (first ~seq-)]\n                                   ~subform\n                                   ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))", :spec nil, :examples []} {:sym dosync, :meta {:arglists ([& exprs]), :doc "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic."}, :source "(defmacro dosync\n  \"Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.\"\n  {:added \"1.0\"}\n  [& exprs]\n  `(sync nil ~@exprs))", :spec nil, :examples []} {:sym dotimes, :meta {:arglists ([bindings & body]), :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1."}, :source "(defmacro dotimes\n  \"bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# (long ~n)]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (unchecked-inc ~i)))))))", :spec nil, :examples []} {:sym doto, :meta {:arglists ([x & forms]), :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"}, :source "(defmacro doto\n  \"Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \\\"a\\\" 1) (.put \\\"b\\\" 2))\"\n  {:added \"1.0\"}\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (with-meta\n                    (if (seq? f)\n                      `(~(first f) ~gx ~@(next f))\n                      `(~f ~gx))\n                    (meta f)))\n                forms)\n         ~gx)))", :spec nil, :examples []} {:sym double, :meta {:arglists ([x]), :doc "Coerce to double"}, :source "(defn double\n  \"Coerce to double\"\n  {:inline (fn  [x] `(. clojure.lang.RT (doubleCast ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/doubleCast x))", :spec nil, :examples []} {:sym double-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles"}, :source "(defn double-array\n  \"Creates an array of doubles\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers double_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers double_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers double_array size init-val-or-seq)))", :spec nil, :examples []} {:sym double?, :meta {:arglists ([x]), :doc "Return true if x is a Double"}, :source "(defn double?\n  \"Return true if x is a Double\"\n  {:added \"1.9\"}\n  [x] (instance? Double x))", :spec nil, :examples []} {:sym doubles, :meta {:arglists ([xs]), :doc "Casts to double[]"}, :source "(definline doubles\n  \"Casts to double[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers doubles ~xs))", :spec nil, :examples []} {:sym drop, :meta {:arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, :source "(defn drop\n  \"Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([n]\n     (fn [rf]\n       (let [nv (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @nv]\n                (vswap! nv dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))", :spec nil, :examples []} {:sym drop-last, :meta {:arglists ([coll] [n coll]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, :source "(defn drop-last\n  \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n  {:added \"1.0\"\n   :static true}\n  ([coll] (drop-last 1 coll))\n  ([n coll] (map (fn [x _] x) coll (drop n coll))))", :spec nil, :examples []} {:sym drop-while, :meta {:arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, :source "(defn drop-while\n  \"Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([pred]\n     (fn [rf]\n       (let [dv (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @dv]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! dv nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))", :spec nil, :examples []} {:sym eduction, :meta {:arglists ([xform* coll]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, :source "(defn eduction\n  \"Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.\"\n  {:arglists '([xform* coll])\n   :added \"1.7\"}\n  [& xforms]\n  (Eduction. (apply comp (butlast xforms)) (last xforms)))", :spec nil, :examples []} {:sym empty, :meta {:arglists ([coll]), :doc "Returns an empty collection of the same category as coll, or nil"}, :source "(defn empty\n  \"Returns an empty collection of the same category as coll, or nil\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n  (when (instance? clojure.lang.IPersistentCollection coll)\n    (.empty ^clojure.lang.IPersistentCollection coll)))", :spec nil, :examples []} {:sym empty?, :meta {:arglists ([coll]), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :source "(defn empty?\n  \"Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (not (seq coll)))", :spec nil, :examples []} {:sym ensure, :meta {:arglists ([ref]), :doc "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)"}, :source "(defn ensure\n  \"Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref]\n    (. ref (touch))\n    (. ref (deref)))", :spec nil, :examples []} {:sym ensure-reduced, :meta {:arglists ([x]), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :source "(defn ensure-reduced\n  \"If x is already reduced?, returns it, else returns (reduced x)\"\n  {:added \"1.7\"}\n  [x]\n  (if (reduced? x) x (reduced x)))", :spec nil, :examples []} {:sym enumeration-seq, :meta {:arglists ([e]), :doc "Returns a seq on a java.util.Enumeration"}, :source "(defn enumeration-seq\n  \"Returns a seq on a java.util.Enumeration\"\n  {:added \"1.0\"\n   :static true}\n  [e]\n  (clojure.lang.EnumerationSeq/create e))", :spec nil, :examples []} {:sym error-handler, :meta {:arglists ([a]), :doc "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!"}, :source "(defn error-handler\n  \"Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a]\n  (.getErrorHandler a))", :spec nil, :examples []} {:sym error-mode, :meta {:arglists ([a]), :doc "Returns the error-mode of agent a.  See set-error-mode!"}, :source "(defn error-mode\n  \"Returns the error-mode of agent a.  See set-error-mode!\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a]\n  (.getErrorMode a))", :spec nil, :examples []} {:sym eval, :meta {:arglists ([form]), :doc "Evaluates the form data structure (not text!) and returns the result."}, :source "(defn eval\n  \"Evaluates the form data structure (not text!) and returns the result.\"\n  {:added \"1.0\"\n   :static true}\n  [form] (. clojure.lang.Compiler (eval form)))", :spec nil, :examples []} {:sym even?, :meta {:arglists ([n]), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :source "(defn even?\n  \"Returns true if n is even, throws an exception if n is not an integer\"\n  {:added \"1.0\"\n   :static true}\n   [n] (if (integer? n)\n        (zero? (bit-and (clojure.lang.RT/uncheckedLongCast n) 1))\n        (throw (IllegalArgumentException. (str \"Argument must be an integer: \" n)))))", :spec nil, :examples []} {:sym every-pred, :meta {:arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, :source "(defn every-pred\n  \"Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.\"\n  {:added \"1.3\"}\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))", :spec nil, :examples []} {:sym every?, :meta {:arglists ([pred coll]), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :source "(defn every?\n  \"Returns true if (pred x) is logical true for every x in coll, else\n  false.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))", :spec nil, :examples []} {:sym ex-data, :meta {:arglists ([ex]), :doc "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil."}, :source "(defn ex-data\n  \"Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.\"\n  {:added \"1.4\"}\n  [ex]\n  (when (instance? IExceptionInfo ex)\n    (.getData ^IExceptionInfo ex)))", :spec nil, :examples []} {:sym ex-info, :meta {:arglists ([msg map] [msg map cause]), :doc "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data."}, :source "(defn ex-info\n  \"Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.\"\n  {:added \"1.4\"}\n  ([msg map]\n     (ExceptionInfo. msg map))\n  ([msg map cause]\n     (ExceptionInfo. msg map cause)))", :spec nil, :examples []} {:sym extend, :meta {:arglists ([atype & proto+mmaps]), :doc "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders"}, :source "(defn extend \n  \"Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders\"\n  {:added \"1.2\"} \n  [atype & proto+mmaps]\n  (doseq [[proto mmap] (partition 2 proto+mmaps)]\n    (when-not (protocol? proto)\n      (throw (IllegalArgumentException.\n              (str proto \" is not a protocol\"))))\n    (when (implements? proto atype)\n      (throw (IllegalArgumentException. \n              (str atype \" already directly implements \" (:on-interface proto) \" for protocol:\"  \n                   (:var proto)))))\n    (-reset-methods (alter-var-root (:var proto) assoc-in [:impls atype] mmap))))", :spec nil, :examples []} {:sym extend-protocol, :meta {:arglists ([p & specs]), :doc "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))"}, :source "(defmacro extend-protocol \n  \"Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))\"\n  {:added \"1.2\"}\n\n  [p & specs]\n  (emit-extend-protocol p specs))", :spec nil, :examples []} {:sym extend-type, :meta {:arglists ([t & specs]), :doc "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})"}, :source "(defmacro extend-type \n  \"A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})\"\n  {:added \"1.2\"} \n  [t & specs]\n  (emit-extend-type t specs))", :spec nil, :examples []} {:sym extenders, :meta {:arglists ([protocol]), :doc "Returns a collection of the types explicitly extending protocol"}, :source "(defn extenders \n  \"Returns a collection of the types explicitly extending protocol\"\n  {:added \"1.2\"}\n  [protocol]\n  (keys (:impls protocol)))", :spec nil, :examples []} {:sym extends?, :meta {:arglists ([protocol atype]), :doc "Returns true if atype extends protocol"}, :source "(defn extends? \n  \"Returns true if atype extends protocol\"\n  {:added \"1.2\"}\n  [protocol atype]\n  (boolean (or (implements? protocol atype) \n               (get (:impls protocol) atype))))", :spec nil, :examples []} {:sym false?, :meta {:arglists ([x]), :doc "Returns true if x is the value false, false otherwise."}, :source "(defn false?\n  \"Returns true if x is the value false, false otherwise.\"\n  {:tag Boolean,\n   :added \"1.0\"\n   :static true}\n  [x] (clojure.lang.Util/identical x false))", :spec nil, :examples []} {:sym ffirst, :meta {:arglists ([x]), :doc "Same as (first (first x))"}, :source "(def\n ^{:doc \"Same as (first (first x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n ffirst (fn ^:static ffirst [x] (first (first x))))", :spec nil, :examples []} {:sym file-seq, :meta {:arglists ([dir]), :doc "A tree seq on java.io.Files"}, :source "(defn file-seq\n  \"A tree seq on java.io.Files\"\n  {:added \"1.0\"\n   :static true}\n  [dir]\n    (tree-seq\n     (fn [^java.io.File f] (. f (isDirectory)))\n     (fn [^java.io.File d] (seq (. d (listFiles))))\n     dir))", :spec nil, :examples []} {:sym filter, :meta {:arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, :source "(defn filter\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (let [v (.nth c i)]\n                (when (pred v)\n                  (chunk-append b v))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))", :spec nil, :examples []} {:sym filterv, :meta {:arglists ([pred coll]), :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects."}, :source "(defn filterv\n  \"Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\"\n  {:added \"1.4\"\n   :static true}\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))", :spec nil, :examples []} {:sym find, :meta {:arglists ([map key]), :doc "Returns the map entry for key, or nil if key not present."}, :source "(defn find\n  \"Returns the map entry for key, or nil if key not present.\"\n  {:added \"1.0\"\n   :static true}\n  [map key] (. clojure.lang.RT (find map key)))", :spec nil, :examples []} {:sym find-keyword, :meta {:arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically."}, :source "(defn find-keyword\n  \"Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.\"\n  {:tag clojure.lang.Keyword\n   :added \"1.3\"\n   :static true}\n  ([name] (cond (keyword? name) name\n                (symbol? name) (clojure.lang.Keyword/find ^clojure.lang.Symbol name)\n                (string? name) (clojure.lang.Keyword/find ^String name)))\n  ([ns name] (clojure.lang.Keyword/find ns name)))", :spec nil, :examples []} {:sym find-ns, :meta {:arglists ([sym]), :doc "Returns the namespace named by the symbol or nil if it doesn't exist."}, :source "(defn find-ns\n  \"Returns the namespace named by the symbol or nil if it doesn't exist.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/find sym))", :spec nil, :examples []} {:sym find-protocol-impl, :meta {:arglists ([protocol x])}, :source "(defn find-protocol-impl [protocol x]\n  (if (instance? (:on-interface protocol) x)\n    x\n    (let [c (class x)\n          impl #(get (:impls protocol) %)]\n      (or (impl c)\n          (and c (or (first (remove nil? (map impl (butlast (super-chain c)))))\n                     (when-let [t (reduce1 pref (filter impl (disj (supers c) Object)))]\n                       (impl t))\n                     (impl Object)))))))", :spec nil, :examples []} {:sym find-protocol-method, :meta {:arglists ([protocol methodk x])}, :source "(defn find-protocol-method [protocol methodk x]\n  (get (find-protocol-impl protocol x) methodk))", :spec nil, :examples []} {:sym find-var, :meta {:arglists ([sym]), :doc "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name."}, :source "(defn find-var\n  \"Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (. clojure.lang.Var (find sym)))", :spec nil, :examples []} {:sym first, :meta {:arglists ([coll]), :doc "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil."}, :source "(def\n ^{:arglists '([coll])\n   :doc \"Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.\"\n   :added \"1.0\"\n   :static true}\n first (fn ^:static first [coll] (. clojure.lang.RT (first coll))))", :spec nil, :examples []} {:sym flatten, :meta {:arglists ([x]), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence."}, :source "(defn flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence.\"\n  {:added \"1.2\"\n   :static true}\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))", :spec nil, :examples []} {:sym float, :meta {:arglists ([x]), :doc "Coerce to float"}, :source "(defn float\n  \"Coerce to float\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedFloatCast 'floatCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/floatCast x))", :spec nil, :examples []} {:sym float-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of floats"}, :source "(defn float-array\n  \"Creates an array of floats\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers float_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers float_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers float_array size init-val-or-seq)))", :spec nil, :examples []} {:sym float?, :meta {:arglists ([n]), :doc "Returns true if n is a floating point number"}, :source "(defn float?\n  \"Returns true if n is a floating point number\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (instance? Double n)\n      (instance? Float n)))", :spec nil, :examples []} {:sym floats, :meta {:arglists ([xs]), :doc "Casts to float[]"}, :source "(definline floats\n  \"Casts to float[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers floats ~xs))", :spec nil, :examples []} {:sym flush, :meta {:arglists ([]), :doc "Flushes the output stream that is the current value of\n  *out*"}, :source "(defn flush\n  \"Flushes the output stream that is the current value of\n  *out*\"\n  {:added \"1.0\"\n   :static true}\n  []\n    (. *out* (flush))\n    nil)", :spec nil, :examples []} {:sym fn, :meta {:arglists ([& sigs]), :doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function"}, :source "(defmacro fn\n  \"params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function\"\n  {:added \"1.0\", :special-form true,\n   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))", :spec "(clojure.spec.alpha/fspec\n :args\n (clojure.spec.alpha/cat\n  :name\n  (clojure.spec.alpha/? clojure.core/simple-symbol?)\n  :bs\n  (clojure.spec.alpha/alt\n   :arity-1\n   :clojure.core.specs.alpha/args+body\n   :arity-n\n   (clojure.spec.alpha/+\n    (clojure.spec.alpha/spec :clojure.core.specs.alpha/args+body))))\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym fn?, :meta {:arglists ([x]), :doc "Returns true if x implements Fn, i.e. is an object created via fn."}, :source "(defn fn?\n  \"Returns true if x implements Fn, i.e. is an object created via fn.\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Fn x))", :spec nil, :examples []} {:sym fnext, :meta {:arglists ([x]), :doc "Same as (first (next x))"}, :source "(def\n ^{:doc \"Same as (first (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n fnext (fn ^:static fnext [x] (first (next x))))", :spec nil, :examples []} {:sym fnil, :meta {:arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, :source "(defn fnil\n  \"Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.\"\n  {:added \"1.2\"\n   :static true}\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))", :spec nil, :examples []} {:sym for, :meta {:arglists ([seq-exprs body-expr]), :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))"}, :source "(defmacro for\n  \"List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))\"\n  {:added \"1.0\"}\n  [seq-exprs body-expr]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))", :spec nil, :examples []} {:sym force, :meta {:arglists ([x]), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :source "(defn force\n  \"If x is a Delay, returns the (possibly cached) value of its expression, else returns x\"\n  {:added \"1.0\"\n   :static true}\n  [x] (. clojure.lang.Delay (force x)))", :spec nil, :examples []} {:sym format, :meta {:arglists ([fmt & args]), :doc "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax"}, :source "(defn format\n  \"Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax\"\n  {:added \"1.0\"\n   :static true}\n  ^String [fmt & args]\n  (String/format fmt (to-array args)))", :spec nil, :examples []} {:sym frequencies, :meta {:arglists ([coll]), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :source "(defn frequencies\n  \"Returns a map from distinct items in coll to the number of times\n  they appear.\"\n  {:added \"1.2\"\n   :static true}\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))", :spec nil, :examples []} {:sym future, :meta {:arglists ([& body]), :doc "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?."}, :source "(defmacro future\n  \"Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.\"\n  {:added \"1.1\"}\n  [& body] `(future-call (^{:once true} fn* [] ~@body)))", :spec nil, :examples []} {:sym future-call, :meta {:arglists ([f]), :doc "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?."}, :source "(defn future-call \n  \"Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.\"\n  {:added \"1.1\"\n   :static true}\n  [f]\n  (let [f (binding-conveyor-fn f)\n        fut (.submit clojure.lang.Agent/soloExecutor ^Callable f)]\n    (reify \n     clojure.lang.IDeref \n     (deref [_] (deref-future fut))\n     clojure.lang.IBlockingDeref\n     (deref\n      [_ timeout-ms timeout-val]\n      (deref-future fut timeout-ms timeout-val))\n     clojure.lang.IPending\n     (isRealized [_] (.isDone fut))\n     java.util.concurrent.Future\n      (get [_] (.get fut))\n      (get [_ timeout unit] (.get fut timeout unit))\n      (isCancelled [_] (.isCancelled fut))\n      (isDone [_] (.isDone fut))\n      (cancel [_ interrupt?] (.cancel fut interrupt?)))))", :spec nil, :examples []} {:sym future-cancel, :meta {:arglists ([f]), :doc "Cancels the future, if possible."}, :source "(defn future-cancel\n  \"Cancels the future, if possible.\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.cancel f true))", :spec nil, :examples []} {:sym future-cancelled?, :meta {:arglists ([f]), :doc "Returns true if future f is cancelled"}, :source "(defn future-cancelled?\n  \"Returns true if future f is cancelled\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.isCancelled f))", :spec nil, :examples []} {:sym future-done?, :meta {:arglists ([f]), :doc "Returns true if future f is done"}, :source "(defn future-done?\n  \"Returns true if future f is done\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.isDone f))", :spec nil, :examples []} {:sym future?, :meta {:arglists ([x]), :doc "Returns true if x is a future"}, :source "(defn future?\n  \"Returns true if x is a future\"\n  {:added \"1.1\"\n   :static true}\n  [x] (instance? java.util.concurrent.Future x))", :spec nil, :examples []} {:sym gen-class, :meta {:arglists ([& options]), :doc "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  Its return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method."}, :source "(defmacro gen-class \n  \"When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \\\"-\\\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  Its return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \\\"-\\\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.\"\n  {:added \"1.0\"}\n  \n  [& options]\n    (when *compile-files*\n      (let [options-map (into1 {} (map vec (partition 2 options)))\n            [cname bytecode] (generate-class options-map)]\n        (clojure.lang.Compiler/writeClassFile cname bytecode))))", :spec nil, :examples []} {:sym gen-interface, :meta {:arglists ([& options]), :doc "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here."}, :source "(defmacro gen-interface\n  \"When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.\"\n  {:added \"1.0\"}\n\n  [& options]\n    (let [options-map (apply hash-map options)\n          [cname bytecode] (generate-interface options-map)]\n      (when *compile-files*\n        (clojure.lang.Compiler/writeClassFile cname bytecode))\n      (.defineClass ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER)\n                    (str (:name options-map)) bytecode options)))", :spec nil, :examples []} {:sym gensym, :meta {:arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, :source "(defn gensym\n  \"Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (gensym \"G__\"))\n  ([prefix-string] (. clojure.lang.Symbol (intern (str prefix-string (str (. clojure.lang.RT (nextID))))))))", :spec nil, :examples []} {:sym get, :meta {:arglists ([map key] [map key not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, :source "(defn get\n  \"Returns the value mapped to key, not-found or nil if key not present.\"\n  {:inline (fn  [m k & nf] `(. clojure.lang.RT (get ~m ~k ~@nf)))\n   :inline-arities #{2 3}\n   :added \"1.0\"}\n  ([map key]\n   (. clojure.lang.RT (get map key)))\n  ([map key not-found]\n   (. clojure.lang.RT (get map key not-found))))", :spec nil, :examples []} {:sym get-in, :meta {:arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied."}, :source "(defn get-in\n  \"Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.\"\n  {:added \"1.2\"\n   :static true}\n  ([m ks]\n     (reduce1 get m ks))\n  ([m ks not-found]\n     (loop [sentinel (Object.)\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))", :spec nil, :examples []} {:sym get-method, :meta {:arglists ([multifn dispatch-val]), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :source "(defn get-method\n  \"Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn dispatch-val] (.getMethod multifn dispatch-val))", :spec nil, :examples []} {:sym get-proxy-class, :meta {:arglists ([& bases]), :doc "Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object."}, :source "(defn get-proxy-class \n  \"Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.\"\n  {:added \"1.0\"}\n  [& bases]\n    (let [[super interfaces] (get-super-and-interfaces bases)\n          pname (proxy-name super interfaces)]\n      (or (RT/loadClassForName pname)\n          (let [[cname bytecode] (generate-proxy super interfaces)]\n            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))", :spec nil, :examples []} {:sym get-thread-bindings, :meta {:arglists ([]), :doc "Get a map with the Var/value pairs which is currently in effect for the\n  current thread."}, :source "(defn get-thread-bindings\n  \"Get a map with the Var/value pairs which is currently in effect for the\n  current thread.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (clojure.lang.Var/getThreadBindings))", :spec nil, :examples []} {:sym get-validator, :meta {:arglists ([iref]), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :source "(defn get-validator\n  \"Gets the validator-fn for a var/ref/agent/atom.\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IRef iref] (. iref (getValidator)))", :spec nil, :examples []} {:sym group-by, :meta {:arglists ([f coll]), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :source "(defn group-by \n  \"Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.\"\n  {:added \"1.2\"\n   :static true}\n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))", :spec nil, :examples []} {:sym halt-when, :meta {:arglists ([pred] [pred retf]), :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected."}, :source "(defn halt-when\n  \"Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.\"\n  {:added \"1.9\"}\n  ([pred] (halt-when pred nil))\n  ([pred retf]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result]\n            (if (and (map? result) (contains? result ::halt))\n              (::halt result)\n              (rf result)))\n         ([result input]\n            (if (pred input)\n              (reduced {::halt (if retf (retf (rf result) input) input)})\n              (rf result input)))))))", :spec nil, :examples []} {:sym hash, :meta {:arglists ([x]), :doc "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections."}, :source "(defn hash\n  \"Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.\"\n\n  {:added \"1.0\"\n   :static true}\n  [x] (. clojure.lang.Util (hasheq x)))", :spec nil, :examples []} {:sym hash-combine, :meta {:arglists ([x y])}, :source "(defn hash-combine [x y] \n  (clojure.lang.Util/hashCombine x (clojure.lang.Util/hash y)))", :spec nil, :examples []} {:sym hash-map, :meta {:arglists ([] [& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc."}, :source "(defn hash-map\n  \"keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] {})\n  ([& keyvals]\n   (. clojure.lang.PersistentHashMap (create keyvals))))", :spec nil, :examples []} {:sym hash-ordered-coll, :meta {:arglists ([coll]), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :source "(defn hash-ordered-coll\n  \"Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  {:added \"1.6\"\n   :static true}\n  ^long\n  [coll] (clojure.lang.Murmur3/hashOrdered coll))", :spec nil, :examples []} {:sym hash-set, :meta {:arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, :source "(defn hash-set\n  \"Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.\"\n  {:added \"1.0\"\n   :static true}\n  ([] #{})\n  ([& keys]\n   (clojure.lang.PersistentHashSet/create keys)))", :spec nil, :examples []} {:sym hash-unordered-coll, :meta {:arglists ([coll]), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :source "(defn hash-unordered-coll\n  \"Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  {:added \"1.6\"\n   :static true}\n  ^long\n  [coll] (clojure.lang.Murmur3/hashUnordered coll))", :spec nil, :examples []} {:sym ident?, :meta {:arglists ([x]), :doc "Return true if x is a symbol or keyword"}, :source "(defn ident?\n  \"Return true if x is a symbol or keyword\"\n  {:added \"1.9\"}\n  [x] (or (keyword? x) (symbol? x)))", :spec nil, :examples []} {:sym identical?, :meta {:arglists ([x y]), :doc "Tests if 2 arguments are the same object"}, :source "(defn identical?\n  \"Tests if 2 arguments are the same object\"\n  {:inline (fn [x y] `(. clojure.lang.Util identical ~x ~y))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x y] (clojure.lang.Util/identical x y)))", :spec nil, :examples []} {:sym identity, :meta {:arglists ([x]), :doc "Returns its argument."}, :source "(defn identity\n  \"Returns its argument.\"\n  {:added \"1.0\"\n   :static true}\n  [x] x)", :spec nil, :examples []} {:sym if-let, :meta {:arglists ([bindings then] [bindings then else & oldform]), :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else"}, :source "(defmacro if-let\n  \"bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else\"\n  {:added \"1.0\"}\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))", :spec "(clojure.spec.alpha/fspec\n :args\n (clojure.spec.alpha/cat\n  :bindings\n  (clojure.spec.alpha/and\n   clojure.core/vector?\n   :clojure.core.specs.alpha/binding)\n  :then\n  clojure.core/any?\n  :else\n  (clojure.spec.alpha/? clojure.core/any?))\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym if-not, :meta {:arglists ([test then] [test then else]), :doc "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil."}, :source "(defmacro if-not\n  \"Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.\"\n  {:added \"1.0\"}\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))", :spec nil, :examples []} {:sym if-some, :meta {:arglists ([bindings then] [bindings then else & oldform]), :doc "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else"}, :source "(defmacro if-some\n  \"bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else\"\n  {:added \"1.6\"}\n  ([bindings then]\n   `(if-some ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if (nil? temp#)\n          ~else\n          (let [~form temp#]\n            ~then))))))", :spec nil, :examples []} {:sym ifn?, :meta {:arglists ([x]), :doc "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn"}, :source "(defn ifn?\n  \"Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IFn x))", :spec nil, :examples []} {:sym import, :meta {:arglists ([& import-symbols-or-lists]), :doc "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly."}, :source "(defmacro import \n  \"import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.\"\n  {:added \"1.0\"}\n  [& import-symbols-or-lists]\n  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %) \n                   import-symbols-or-lists)]\n    `(do ~@(map #(list 'clojure.core/import* %)\n                (reduce1 (fn [v spec] \n                          (if (symbol? spec)\n                            (conj v (name spec))\n                            (let [p (first spec) cs (rest spec)]\n                              (into1 v (map #(str p \".\" %) cs)))))\n                        [] specs)))))", :spec "(clojure.spec.alpha/fspec\n :args\n :clojure.core.specs.alpha/quotable-import-list\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym in-ns, :meta {:arglists ([name]), :doc "Sets *ns* to the namespace named by the symbol, creating it if needed."}, :source nil, :spec nil, :examples []} {:sym inc, :meta {:arglists ([x]), :doc "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'"}, :source "(defn inc\n  \"Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_inc 'inc) ~x)))\n   :added \"1.2\"}\n  [x] (. clojure.lang.Numbers (inc x)))", :spec nil, :examples []} {:sym inc', :meta {:arglists ([x]), :doc "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc"}, :source "(defn inc'\n  \"Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (incP ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (incP x)))", :spec nil, :examples []} {:sym indexed?, :meta {:arglists ([coll]), :doc "Return true if coll implements Indexed, indicating efficient lookup by index"}, :source "(defn indexed?\n  \"Return true if coll implements Indexed, indicating efficient lookup by index\"\n  {:added \"1.9\"}\n  [coll] (instance? clojure.lang.Indexed coll))", :spec nil, :examples []} {:sym init-proxy, :meta {:arglists ([proxy mappings]), :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy."}, :source "(defn init-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__initClojureFnMappings mappings))\n    proxy)", :spec nil, :examples []} {:sym inst-ms, :meta {:arglists ([inst]), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, :source "(defn inst-ms\n  \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n  {:added \"1.9\"}\n  [inst]\n  (inst-ms* inst))", :spec nil, :examples []} {:sym inst-ms*, :meta {:arglists ([inst]), :doc nil}, :source nil, :spec nil, :examples []} {:sym inst?, :meta {:arglists ([x]), :doc "Return true if x satisfies Inst"}, :source "(defn inst?\n  \"Return true if x satisfies Inst\"\n  {:added \"1.9\"}\n  [x]\n  (satisfies? Inst x))", :spec nil, :examples []} {:sym instance?, :meta {:arglists ([c x]), :doc "Evaluates x and tests if it is an instance of the class\n    c. Returns true or false"}, :source "(def\n ^{:arglists '([^Class c x])\n   :doc \"Evaluates x and tests if it is an instance of the class\n    c. Returns true or false\"\n   :added \"1.0\"}\n instance? (fn instance? [^Class c x] (. c (isInstance x))))", :spec nil, :examples []} {:sym int, :meta {:arglists ([x]), :doc "Coerce to int"}, :source "(defn int\n  \"Coerce to int\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedIntCast 'intCast) ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.RT (intCast x)))", :spec nil, :examples []} {:sym int-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints"}, :source "(defn int-array\n  \"Creates an array of ints\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers int_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers int_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers int_array size init-val-or-seq)))", :spec nil, :examples []} {:sym int?, :meta {:arglists ([x]), :doc "Return true if x is a fixed precision integer"}, :source "(defn int?\n  \"Return true if x is a fixed precision integer\"\n  {:added \"1.9\"}\n  [x] (or (instance? Long x)\n          (instance? Integer x)\n          (instance? Short x)\n          (instance? Byte x)))", :spec nil, :examples []} {:sym integer?, :meta {:arglists ([n]), :doc "Returns true if n is an integer"}, :source "(defn integer?\n  \"Returns true if n is an integer\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (instance? Integer n)\n      (instance? Long n)\n      (instance? clojure.lang.BigInt n)\n      (instance? BigInteger n)\n      (instance? Short n)\n      (instance? Byte n)))", :spec nil, :examples []} {:sym interleave, :meta {:arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, :source "(defn interleave\n  \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] ())\n  ([c1] (lazy-seq c1))\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2) \n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls] \n     (lazy-seq \n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))", :spec nil, :examples []} {:sym intern, :meta {:arglists ([ns name] [ns name val]), :doc "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var."}, :source "(defn intern\n  \"Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.\"\n  {:added \"1.0\"\n   :static true}\n  ([ns ^clojure.lang.Symbol name]\n     (let [v (clojure.lang.Var/intern (the-ns ns) name)]\n       (when (meta name) (.setMeta v (meta name)))\n       v))\n  ([ns name val]\n     (let [v (clojure.lang.Var/intern (the-ns ns) name val)]\n       (when (meta name) (.setMeta v (meta name)))\n       v)))", :spec nil, :examples []} {:sym interpose, :meta {:arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided."}, :source "(defn interpose\n  \"Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([sep]\n   (fn [rf]\n     (let [started (volatile! false)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n          (if @started\n            (let [sepr (rf result sep)]\n              (if (reduced? sepr)\n                sepr\n                (rf sepr input)))\n            (do\n              (vreset! started true)\n              (rf result input))))))))\n  ([sep coll]\n   (drop 1 (interleave (repeat sep) coll))))", :spec nil, :examples []} {:sym into, :meta {:arglists ([] [to] [to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, :source "(defn into\n  \"Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.\"\n  {:added \"1.0\"\n   :static true}\n  ([] [])\n  ([to] to)\n  ([to from]\n     (if (instance? clojure.lang.IEditableCollection to)\n       (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))\n       (reduce conj to from)))\n  ([to xform from]\n     (if (instance? clojure.lang.IEditableCollection to)\n       (with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))", :spec nil, :examples []} {:sym into-array, :meta {:arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE."}, :source "(defn into-array\n  \"Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.\"\n  {:added \"1.0\"\n   :static true}\n  ([aseq]\n     (clojure.lang.RT/seqToTypedArray (seq aseq)))\n  ([type aseq]\n     (clojure.lang.RT/seqToTypedArray type (seq aseq))))", :spec nil, :examples []} {:sym ints, :meta {:arglists ([xs]), :doc "Casts to int[]"}, :source "(definline ints\n  \"Casts to int[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers ints ~xs))", :spec nil, :examples []} {:sym io!, :meta {:arglists ([& body]), :doc "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message."}, :source "(defmacro io!\n  \"If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.\"\n  {:added \"1.0\"}\n  [& body]\n  (let [message (when (string? (first body)) (first body))\n        body (if message (next body) body)]\n    `(if (clojure.lang.LockingTransaction/isRunning)\n       (throw (new IllegalStateException ~(or message \"I/O in transaction\")))\n       (do ~@body))))", :spec nil, :examples []} {:sym isa?, :meta {:arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, :source "(defn isa?\n  \"Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy\"\n  {:added \"1.0\"}\n  ([child parent] (isa? global-hierarchy child parent))\n  ([h child parent]\n   (or (= child parent)\n       (and (class? parent) (class? child)\n            (. ^Class parent isAssignableFrom child))\n       (contains? ((:ancestors h) child) parent)\n       (and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n       (and (vector? parent) (vector? child)\n            (= (count parent) (count child))\n            (loop [ret true i 0]\n              (if (or (not ret) (= i (count parent)))\n                ret\n                (recur (isa? h (child i) (parent i)) (inc i))))))))", :spec nil, :examples []} {:sym iterate, :meta {:arglists ([f x]), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, :source "(defn iterate\n  \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n  {:added \"1.0\"\n   :static true}\n  [f x] (clojure.lang.Iterate/create f x) )", :spec nil, :examples []} {:sym iterator-seq, :meta {:arglists ([iter]), :doc "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object."}, :source "(defn iterator-seq\n  \"Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.\"\n  {:added \"1.0\"\n   :static true}\n  [iter]\n  (clojure.lang.RT/chunkIteratorSeq iter))", :spec nil, :examples []} {:sym juxt, :meta {:arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, :source "(defn juxt \n  \"Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]\"\n  {:added \"1.1\"\n   :static true}\n  ([f] \n     (fn\n       ([] [(f)])\n       ([x] [(f x)])\n       ([x y] [(f x y)])\n       ([x y z] [(f x y z)])\n       ([x y z & args] [(apply f x y z args)])))\n  ([f g] \n     (fn\n       ([] [(f) (g)])\n       ([x] [(f x) (g x)])\n       ([x y] [(f x y) (g x y)])\n       ([x y z] [(f x y z) (g x y z)])\n       ([x y z & args] [(apply f x y z args) (apply g x y z args)])))\n  ([f g h] \n     (fn\n       ([] [(f) (g) (h)])\n       ([x] [(f x) (g x) (h x)])\n       ([x y] [(f x y) (g x y) (h x y)])\n       ([x y z] [(f x y z) (g x y z) (h x y z)])\n       ([x y z & args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)])))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce1 #(conj %1 (%2)) [] fs))\n         ([x] (reduce1 #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce1 #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce1 #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce1 #(conj %1 (apply %2 x y z args)) [] fs))))))", :spec nil, :examples []} {:sym keep, :meta {:arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, :source "(defn keep\n  \"Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (.nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))", :spec nil, :examples []} {:sym keep-indexed, :meta {:arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, :source "(defn keep-indexed\n  \"Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([f]\n   (fn [rf]\n     (let [iv (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! iv inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (.nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))", :spec nil, :examples []} {:sym key, :meta {:arglists ([e]), :doc "Returns the key of the map entry."}, :source "(defn key\n  \"Returns the key of the map entry.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.Map$Entry e]\n    (. e (getKey)))", :spec nil, :examples []} {:sym keys, :meta {:arglists ([map]), :doc "Returns a sequence of the map's keys, in the same order as (seq map)."}, :source "(defn keys\n  \"Returns a sequence of the map's keys, in the same order as (seq map).\"\n  {:added \"1.0\"\n   :static true}\n  [map] (. clojure.lang.RT (keys map)))", :spec nil, :examples []} {:sym keyword, :meta {:arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, :source "(defn keyword\n  \"Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.\"\n  {:tag clojure.lang.Keyword\n   :added \"1.0\"\n   :static true}\n  ([name] (cond (keyword? name) name\n                (symbol? name) (clojure.lang.Keyword/intern ^clojure.lang.Symbol name)\n                (string? name) (clojure.lang.Keyword/intern ^String name)))\n  ([ns name] (clojure.lang.Keyword/intern ns name)))", :spec nil, :examples []} {:sym keyword?, :meta {:arglists ([x]), :doc "Return true if x is a Keyword"}, :source "(defn keyword?\n  \"Return true if x is a Keyword\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Keyword x))", :spec nil, :examples []} {:sym last, :meta {:arglists ([coll]), :doc "Return the last item in coll, in linear time"}, :source "(def \n ^{:arglists '([coll])\n   :doc \"Return the last item in coll, in linear time\"\n   :added \"1.0\"\n   :static true}\n last (fn ^:static last [s]\n        (if (next s)\n          (recur (next s))\n          (first s))))", :spec nil, :examples []} {:sym lazy-cat, :meta {:arglists ([& colls]), :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"}, :source "(defmacro lazy-cat\n  \"Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))\"\n  {:added \"1.0\"}\n  [& colls]\n  `(concat ~@(map #(list `lazy-seq %) colls)))", :spec nil, :examples []} {:sym lazy-seq, :meta {:arglists ([& body]), :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?"}, :source "(defmacro lazy-seq\n  \"Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?\"\n  {:added \"1.0\"}\n  [& body]\n  (list 'new 'clojure.lang.LazySeq (list* '^{:once true} fn* [] body)))", :spec nil, :examples []} {:sym let, :meta {:arglists ([bindings & body]), :doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein."}, :source "(defmacro let\n  \"binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\"\n  {:added \"1.0\", :special-form true, :forms '[(let [bindings*] exprs*)]}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))", :spec "(clojure.spec.alpha/fspec\n :args\n (clojure.spec.alpha/cat\n  :bindings\n  :clojure.core.specs.alpha/bindings\n  :body\n  (clojure.spec.alpha/* clojure.core/any?))\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym letfn, :meta {:arglists ([fnspecs & body]), :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body."}, :source "(defmacro letfn \n  \"fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.\"\n  {:added \"1.0\", :forms '[(letfn [fnspecs*] exprs*)],\n   :special-form true, :url nil}\n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))", :spec nil, :examples []} {:sym line-seq, :meta {:arglists ([rdr]), :doc "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader."}, :source "(defn line-seq\n  \"Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.io.BufferedReader rdr]\n  (when-let [line (.readLine rdr)]\n    (cons line (lazy-seq (line-seq rdr)))))", :spec nil, :examples []} {:sym list, :meta {:arglists ([& items]), :doc "Creates a new list containing the items."}, :source "(def\n ^{:arglists '([& items])\n   :doc \"Creates a new list containing the items.\"\n   :added \"1.0\"}\n  list (. clojure.lang.PersistentList creator))", :spec nil, :examples []} {:sym list*, :meta {:arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, :source "(defn list*\n  \"Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.\"\n  {:added \"1.0\"\n   :static true}\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))", :spec nil, :examples []} {:sym list?, :meta {:arglists ([x]), :doc "Returns true if x implements IPersistentList"}, :source "(defn list?\n  \"Returns true if x implements IPersistentList\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentList x))", :spec nil, :examples []} {:sym load, :meta {:arglists ([& paths]), :doc "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise."}, :source "(defn load\n  \"Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.\"\n  {:redef true\n   :added \"1.0\"}\n  [& paths]\n  (doseq [^String path paths]\n    (let [^String path (if (.startsWith path \"/\")\n                          path\n                          (str (root-directory (ns-name *ns*)) \\/ path))]\n      (when *loading-verbosely*\n        (printf \"(clojure.core/load \\\"%s\\\")\\n\" path)\n        (flush))\n      (check-cyclic-dependency path)\n      (when-not (= path (first *pending-paths*))\n        (binding [*pending-paths* (conj *pending-paths* path)]\n          (clojure.lang.RT/load (.substring path 1)))))))", :spec nil, :examples []} {:sym load-file, :meta {:arglists ([name]), :doc "Sequentially read and evaluate the set of forms contained in the file."}, :source nil, :spec nil, :examples []} {:sym load-reader, :meta {:arglists ([rdr]), :doc "Sequentially read and evaluate the set of forms contained in the\n  stream/file"}, :source "(defn load-reader\n  \"Sequentially read and evaluate the set of forms contained in the\n  stream/file\"\n  {:added \"1.0\"\n   :static true}\n  [rdr] (. clojure.lang.Compiler (load rdr)))", :spec nil, :examples []} {:sym load-string, :meta {:arglists ([s]), :doc "Sequentially read and evaluate the set of forms contained in the\n  string"}, :source "(defn load-string\n  \"Sequentially read and evaluate the set of forms contained in the\n  string\"\n  {:added \"1.0\"\n   :static true}\n  [s]\n  (let [rdr (-> (java.io.StringReader. s)\n                (clojure.lang.LineNumberingPushbackReader.))]\n    (load-reader rdr)))", :spec nil, :examples []} {:sym loaded-libs, :meta {:arglists ([]), :doc "Returns a sorted set of symbols naming the currently loaded libs"}, :source "(defn loaded-libs\n  \"Returns a sorted set of symbols naming the currently loaded libs\"\n  {:added \"1.0\"}\n  [] @*loaded-libs*)", :spec nil, :examples []} {:sym locking, :meta {:arglists ([x & body]), :doc "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances."}, :source "(defmacro locking\n  \"Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.\"\n  {:added \"1.0\"}\n  [x & body]\n  `(let [lockee# ~x]\n     (try\n      (monitor-enter lockee#)\n      ~@body\n      (finally\n       (monitor-exit lockee#)))))", :spec nil, :examples []} {:sym long, :meta {:arglists ([x]), :doc "Coerce to long"}, :source "(defn long\n  \"Coerce to long\"\n  {:inline (fn  [x] `(. clojure.lang.RT (longCast ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/longCast x))", :spec nil, :examples []} {:sym long-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs"}, :source "(defn long-array\n  \"Creates an array of longs\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers long_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers long_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers long_array size init-val-or-seq)))", :spec nil, :examples []} {:sym longs, :meta {:arglists ([xs]), :doc "Casts to long[]"}, :source "(definline longs\n  \"Casts to long[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers longs ~xs))", :spec nil, :examples []} {:sym loop, :meta {:arglists ([bindings & body]), :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target."}, :source "(defmacro loop\n  \"Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.\"\n  {:added \"1.0\", :special-form true, :forms '[(loop [bindings*] exprs*)]}\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))", :spec nil, :examples []} {:sym macroexpand, :meta {:arglists ([form]), :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms."}, :source "(defn macroexpand\n  \"Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.\"\n  {:added \"1.0\"\n   :static true}\n  [form]\n    (let [ex (macroexpand-1 form)]\n      (if (identical? ex form)\n        form\n        (macroexpand ex))))", :spec nil, :examples []} {:sym macroexpand-1, :meta {:arglists ([form]), :doc "If form represents a macro form, returns its expansion,\n  else returns form."}, :source "(defn macroexpand-1\n  \"If form represents a macro form, returns its expansion,\n  else returns form.\"\n  {:added \"1.0\"\n   :static true}\n  [form]\n    (. clojure.lang.Compiler (macroexpand1 form)))", :spec nil, :examples []} {:sym make-array, :meta {:arglists ([type len] [type dim & more-dims]), :doc "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE."}, :source "(defn make-array\n  \"Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.\"\n  {:added \"1.0\"\n   :static true}\n  ([^Class type len]\n   (. Array (newInstance type (int len))))\n  ([^Class type dim & more-dims]\n   (let [dims (cons dim more-dims)\n         ^\"[I\" dimarray (make-array (. Integer TYPE)  (count dims))]\n     (dotimes [i (alength dimarray)]\n       (aset-int dimarray i (nth dims i)))\n     (. Array (newInstance type dimarray)))))", :spec nil, :examples []} {:sym make-hierarchy, :meta {:arglists ([]), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :source "(defn make-hierarchy\n  \"Creates a hierarchy object for use with derive, isa? etc.\"\n  {:added \"1.0\"\n   :static true}\n  [] {:parents {} :descendants {} :ancestors {}})", :spec nil, :examples []} {:sym map, :meta {:arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, :source "(defn map\n  \"Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (int (count c))\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (.nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))", :spec nil, :examples []} {:sym map-entry?, :meta {:arglists ([x]), :doc "Return true if x is a map entry"}, :source "(defn map-entry?\n  \"Return true if x is a map entry\"\n  {:added \"1.8\"}\n  [x]\n\t(instance? java.util.Map$Entry x))", :spec nil, :examples []} {:sym map-indexed, :meta {:arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided."}, :source "(defn map-indexed\n  \"Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([f]\n   (fn [rf]\n     (let [i (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n          (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n   (letfn [(mapi [idx coll]\n                 (lazy-seq\n                   (when-let [s (seq coll)]\n                     (if (chunked-seq? s)\n                       (let [c (chunk-first s)\n                             size (int (count c))\n                             b (chunk-buffer size)]\n                         (dotimes [i size]\n                           (chunk-append b (f (+ idx i) (.nth c i))))\n                         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                       (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n     (mapi 0 coll))))", :spec nil, :examples []} {:sym map?, :meta {:arglists ([x]), :doc "Return true if x implements IPersistentMap"}, :source "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements IPersistentMap\"\n   :added \"1.0\"\n   :static true}\n map? (fn ^:static map? [x] (instance? clojure.lang.IPersistentMap x)))", :spec nil, :examples []} {:sym mapcat, :meta {:arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :source "(defn mapcat\n  \"Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided\"\n  {:added \"1.0\"\n   :static true}\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))", :spec nil, :examples []} {:sym mapv, :meta {:arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, :source "(defn mapv\n  \"Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.\"\n  {:added \"1.4\"\n   :static true}\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))", :spec nil, :examples []} {:sym max, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, :source "(defn max\n  \"Returns the greatest of the nums.\"\n  {:added \"1.0\"\n   :inline-arities >1?\n   :inline (nary-inline 'max)}\n  ([x] x)\n  ([x y] (. clojure.lang.Numbers (max x y)))\n  ([x y & more]\n   (reduce1 max (max x y) more)))", :spec nil, :examples []} {:sym max-key, :meta {:arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned."}, :source "(defn max-key\n  \"Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.\"\n  {:added \"1.0\"\n   :static true}\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (let [kx (k x) ky (k y)\n         [v kv] (if (> kx ky) [x kx] [y ky])]\n     (loop [v v kv kv more more]\n       (if more\n         (let [w (first more)\n               kw (k w)]\n           (if (>= kw kv)\n             (recur w kw (next more))\n             (recur v kv (next more))))\n         v)))))", :spec nil, :examples []} {:sym memfn, :meta {:arglists ([name & args]), :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls."}, :source "(defmacro memfn\n  \"Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.\"\n  {:added \"1.0\"}\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))", :spec nil, :examples []} {:sym memoize, :meta {:arglists ([f]), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :source "(defn memoize\n  \"Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.\"\n  {:added \"1.0\"\n   :static true}\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [e (find @mem args)]\n        (val e)\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))", :spec nil, :examples []} {:sym merge, :meta {:arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, :source "(defn merge\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.\"\n  {:added \"1.0\"\n   :static true}\n  [& maps]\n  (when (some identity maps)\n    (reduce1 #(conj (or %1 {}) %2) maps)))", :spec nil, :examples []} {:sym merge-with, :meta {:arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, :source "(defn merge-with\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).\"\n  {:added \"1.0\"\n   :static true}\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce1 merge-entry (or m1 {}) (seq m2)))]\n      (reduce1 merge2 maps))))", :spec nil, :examples []} {:sym meta, :meta {:arglists ([obj]), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :source "(def\n ^{:arglists '([obj])\n   :doc \"Returns the metadata of obj, returns nil if there is no metadata.\"\n   :added \"1.0\"\n   :static true}\n meta (fn ^:static meta [x]\n        (if (instance? clojure.lang.IMeta x)\n          (. ^clojure.lang.IMeta x (meta)))))", :spec nil, :examples []} {:sym method-sig, :meta {:arglists ([meth])}, :source "(defn method-sig [^java.lang.reflect.Method meth]\n  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])", :spec nil, :examples []} {:sym methods, :meta {:arglists ([multifn]), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :source "(defn methods\n  \"Given a multimethod, returns a map of dispatch values -> dispatch fns\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn] (.getMethodTable multifn))", :spec nil, :examples []} {:sym min, :meta {:arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, :source "(defn min\n  \"Returns the least of the nums.\"\n  {:added \"1.0\"\n   :inline-arities >1?\n   :inline (nary-inline 'min)}\n  ([x] x)\n  ([x y] (. clojure.lang.Numbers (min x y)))\n  ([x y & more]\n   (reduce1 min (min x y) more)))", :spec nil, :examples []} {:sym min-key, :meta {:arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned."}, :source "(defn min-key\n  \"Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.\"\n  {:added \"1.0\"\n   :static true}\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n   (let [kx (k x) ky (k y)\n         [v kv] (if (< kx ky) [x kx] [y ky])]\n     (loop [v v kv kv more more]\n       (if more\n         (let [w (first more)\n               kw (k w)]\n           (if (<= kw kv)\n             (recur w kw (next more))\n             (recur v kv (next more))))\n         v)))))", :spec nil, :examples []} {:sym mix-collection-hash, :meta {:arglists ([hash-basis count]), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :source "(defn mix-collection-hash\n  \"Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  {:added \"1.6\"\n   :static true}\n  ^long\n  [^long hash-basis ^long count] (clojure.lang.Murmur3/mixCollHash hash-basis count))", :spec nil, :examples []} {:sym mod, :meta {:arglists ([num div]), :doc "Modulus of num and div. Truncates toward negative infinity."}, :source "(defn mod\n  \"Modulus of num and div. Truncates toward negative infinity.\"\n  {:added \"1.0\"\n   :static true}\n  [num div] \n  (let [m (rem num div)] \n    (if (or (zero? m) (= (pos? num) (pos? div)))\n      m \n      (+ m div))))", :spec nil, :examples []} {:sym munge, :meta {:arglists ([s])}, :source "(defn munge [s]\n  ((if (symbol? s) symbol str) (clojure.lang.Compiler/munge (str s))))", :spec nil, :examples []} {:sym name, :meta {:arglists ([x]), :doc "Returns the name String of a string, symbol or keyword."}, :source "(defn name\n  \"Returns the name String of a string, symbol or keyword.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [x]\n  (if (string? x) x (. ^clojure.lang.Named x (getName))))", :spec nil, :examples []} {:sym namespace, :meta {:arglists ([x]), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :source "(defn namespace\n  \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [^clojure.lang.Named x]\n    (. x (getNamespace)))", :spec nil, :examples []} {:sym namespace-munge, :meta {:arglists ([ns]), :doc "Convert a Clojure namespace name to a legal Java package name."}, :source "(defn namespace-munge\n  \"Convert a Clojure namespace name to a legal Java package name.\"\n  {:added \"1.2\"}\n  [ns]\n  (.replace (str ns) \\- \\_))", :spec nil, :examples []} {:sym nat-int?, :meta {:arglists ([x]), :doc "Return true if x is a non-negative fixed precision integer"}, :source "(defn nat-int?\n  \"Return true if x is a non-negative fixed precision integer\"\n  {:added \"1.9\"}\n  [x] (and (int? x)\n           (not (neg? x))))", :spec nil, :examples []} {:sym neg-int?, :meta {:arglists ([x]), :doc "Return true if x is a negative fixed precision integer"}, :source "(defn neg-int?\n  \"Return true if x is a negative fixed precision integer\"\n  {:added \"1.9\"}\n  [x] (and (int? x)\n           (neg? x)))", :spec nil, :examples []} {:sym neg?, :meta {:arglists ([num]), :doc "Returns true if num is less than zero, else false"}, :source "(defn neg?\n  \"Returns true if num is less than zero, else false\"\n  {\n   :inline (fn [num] `(. clojure.lang.Numbers (isNeg ~num)))\n   :added \"1.0\"}\n  [num] (. clojure.lang.Numbers (isNeg num)))", :spec nil, :examples []} {:sym newline, :meta {:arglists ([]), :doc "Writes a platform-specific newline to *out*"}, :source "(defn newline\n  \"Writes a platform-specific newline to *out*\"\n  {:added \"1.0\"\n   :static true}\n  []\n    (. *out* (append system-newline))\n    nil)", :spec nil, :examples []} {:sym next, :meta {:arglists ([coll]), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil."}, :source "(def\n ^{:arglists '([coll])\n   :tag clojure.lang.ISeq\n   :doc \"Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.\"\n   :added \"1.0\"\n   :static true}  \n next (fn ^:static next [x] (. clojure.lang.RT (next x))))", :spec nil, :examples []} {:sym nfirst, :meta {:arglists ([x]), :doc "Same as (next (first x))"}, :source "(def\n ^{:doc \"Same as (next (first x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n nfirst (fn ^:static nfirst [x] (next (first x))))", :spec nil, :examples []} {:sym nil?, :meta {:arglists ([x]), :doc "Returns true if x is nil, false otherwise."}, :source "(defn nil?\n  \"Returns true if x is nil, false otherwise.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true\n   :inline (fn [x] (list 'clojure.lang.Util/identical x nil))}\n  [x] (clojure.lang.Util/identical x nil))", :spec nil, :examples []} {:sym nnext, :meta {:arglists ([x]), :doc "Same as (next (next x))"}, :source "(def\n ^{:doc \"Same as (next (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n nnext (fn ^:static nnext [x] (next (next x))))", :spec nil, :examples []} {:sym not, :meta {:arglists ([x]), :doc "Returns true if x is logical false, false otherwise."}, :source "(defn not\n  \"Returns true if x is logical false, false otherwise.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  [x] (if x false true))", :spec nil, :examples []} {:sym not-any?, :meta {:arglists ([pred coll]), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :source "(def\n ^{:tag Boolean\n   :doc \"Returns false if (pred x) is logical true for any x in coll,\n  else true.\"\n   :arglists '([pred coll])\n   :added \"1.0\"}\n not-any? (comp not some))", :spec nil, :examples []} {:sym not-empty, :meta {:arglists ([coll]), :doc "If coll is empty, returns nil, else coll"}, :source "(defn not-empty\n  \"If coll is empty, returns nil, else coll\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (when (seq coll) coll))", :spec nil, :examples []} {:sym not-every?, :meta {:arglists ([pred coll]), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :source "(def\n ^{:tag Boolean\n   :doc \"Returns false if (pred x) is logical true for every x in\n  coll, else true.\"\n   :arglists '([pred coll])\n   :added \"1.0\"}\n not-every? (comp not every?))", :spec nil, :examples []} {:sym not=, :meta {:arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, :source "(defn not=\n  \"Same as (not (= obj1 obj2))\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))", :spec nil, :examples []} {:sym ns, :meta {:arglists ([name docstring? attr-map? references*]), :doc "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))"}, :source "(defmacro ns\n  \"Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))\"\n  {:arglists '([name docstring? attr-map? references*])\n   :added \"1.0\"}\n  [name & references]\n  (let [process-reference\n        (fn [[kname & args]]\n          `(~(symbol \"clojure.core\" (clojure.core/name kname))\n             ~@(map #(list 'quote %) args)))\n        docstring  (when (string? (first references)) (first references))\n        references (if docstring (next references) references)\n        name (if docstring\n               (vary-meta name assoc :doc docstring)\n               name)\n        metadata   (when (map? (first references)) (first references))\n        references (if metadata (next references) references)\n        name (if metadata\n               (vary-meta name merge metadata)\n               name)\n        gen-class-clause (first (filter #(= :gen-class (first %)) references))\n        gen-class-call\n          (when gen-class-clause\n            (list* `gen-class :name (.replace (str name) \\- \\_) :impl-ns name :main true (next gen-class-clause)))\n        references (remove #(= :gen-class (first %)) references)\n        ;ns-effect (clojure.core/in-ns name)\n        name-metadata (meta name)]\n    `(do\n       (clojure.core/in-ns '~name)\n       ~@(when name-metadata\n           `((.resetMeta (clojure.lang.Namespace/find '~name) ~name-metadata)))\n       (with-loading-context\n        ~@(when gen-class-call (list gen-class-call))\n        ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))\n            `((clojure.core/refer '~'clojure.core)))\n        ~@(map process-reference references))\n        (if (.equals '~name 'clojure.core) \n          nil\n          (do (dosync (commute @#'*loaded-libs* conj '~name)) nil)))))", :spec "(clojure.spec.alpha/fspec\n :args\n :clojure.core.specs.alpha/ns-form\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym ns-aliases, :meta {:arglists ([ns]), :doc "Returns a map of the aliases for the namespace."}, :source "(defn ns-aliases\n  \"Returns a map of the aliases for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getAliases (the-ns ns)))", :spec nil, :examples []} {:sym ns-imports, :meta {:arglists ([ns]), :doc "Returns a map of the import mappings for the namespace."}, :source "(defn ns-imports\n  \"Returns a map of the import mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (filter-key val (partial instance? Class) (ns-map ns)))", :spec nil, :examples []} {:sym ns-interns, :meta {:arglists ([ns]), :doc "Returns a map of the intern mappings for the namespace."}, :source "(defn ns-interns\n  \"Returns a map of the intern mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (= ns (.ns v))))\n                (ns-map ns))))", :spec nil, :examples []} {:sym ns-map, :meta {:arglists ([ns]), :doc "Returns a map of all the mappings for the namespace."}, :source "(defn ns-map\n  \"Returns a map of all the mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getMappings (the-ns ns)))", :spec nil, :examples []} {:sym ns-name, :meta {:arglists ([ns]), :doc "Returns the name of the namespace, a symbol."}, :source "(defn ns-name\n  \"Returns the name of the namespace, a symbol.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getName (the-ns ns)))", :spec nil, :examples []} {:sym ns-publics, :meta {:arglists ([ns]), :doc "Returns a map of the public intern mappings for the namespace."}, :source "(defn ns-publics\n  \"Returns a map of the public intern mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (= ns (.ns v))\n                                 (.isPublic v)))\n                (ns-map ns))))", :spec nil, :examples []} {:sym ns-refers, :meta {:arglists ([ns]), :doc "Returns a map of the refer mappings for the namespace."}, :source "(defn ns-refers\n  \"Returns a map of the refer mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (not= ns (.ns v))))\n                (ns-map ns))))", :spec nil, :examples []} {:sym ns-resolve, :meta {:arglists ([ns sym] [ns env sym]), :doc "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace."}, :source "(defn ns-resolve\n  \"Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  ([ns sym]\n    (ns-resolve ns nil sym))\n  ([ns env sym]\n    (when-not (contains? env sym)\n      (clojure.lang.Compiler/maybeResolveIn (the-ns ns) sym))))", :spec nil, :examples []} {:sym ns-unalias, :meta {:arglists ([ns sym]), :doc "Removes the alias for the symbol from the namespace."}, :source "(defn ns-unalias\n  \"Removes the alias for the symbol from the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns sym]\n  (.removeAlias (the-ns ns) sym))", :spec nil, :examples []} {:sym ns-unmap, :meta {:arglists ([ns sym]), :doc "Removes the mappings for the symbol from the namespace."}, :source "(defn ns-unmap\n  \"Removes the mappings for the symbol from the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns sym]\n  (.unmap (the-ns ns) sym))", :spec nil, :examples []} {:sym nth, :meta {:arglists ([coll index] [coll index not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, :source "(defn nth\n  \"Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.\"\n  {:inline (fn  [c i & nf] `(. clojure.lang.RT (nth ~c ~i ~@nf)))\n   :inline-arities #{2 3}\n   :added \"1.0\"}\n  ([coll index] (. clojure.lang.RT (nth coll index)))\n  ([coll index not-found] (. clojure.lang.RT (nth coll index not-found))))", :spec nil, :examples []} {:sym nthnext, :meta {:arglists ([coll n]), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :source "(defn nthnext\n  \"Returns the nth next of coll, (seq coll) when n is 0.\"\n  {:added \"1.0\"\n   :static true}\n  [coll n]\n    (loop [n n xs (seq coll)]\n      (if (and xs (pos? n))\n        (recur (dec n) (next xs))\n        xs)))", :spec nil, :examples []} {:sym nthrest, :meta {:arglists ([coll n]), :doc "Returns the nth rest of coll, coll when n is 0."}, :source "(defn nthrest\n  \"Returns the nth rest of coll, coll when n is 0.\"\n  {:added \"1.3\"\n   :static true}\n  [coll n]\n    (loop [n n xs coll]\n      (if-let [xs (and (pos? n) (seq xs))]\n        (recur (dec n) (rest xs))\n        xs)))", :spec nil, :examples []} {:sym num, :meta {:arglists ([x]), :doc "Coerce to Number"}, :source "(defn num\n  \"Coerce to Number\"\n  {:tag Number\n   :inline (fn  [x] `(. clojure.lang.Numbers (num ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (num x)))", :spec nil, :examples []} {:sym number?, :meta {:arglists ([x]), :doc "Returns true if x is a Number"}, :source "(defn number?\n  \"Returns true if x is a Number\"\n  {:added \"1.0\"\n   :static true}\n  [x]\n  (instance? Number x))", :spec nil, :examples []} {:sym numerator, :meta {:arglists ([r]), :doc "Returns the numerator part of a Ratio."}, :source "(defn numerator\n  \"Returns the numerator part of a Ratio.\"\n  {:tag BigInteger\n   :added \"1.2\"\n   :static true}\n  [r]\n  (.numerator ^clojure.lang.Ratio r))", :spec nil, :examples []} {:sym object-array, :meta {:arglists ([size-or-seq]), :doc "Creates an array of objects"}, :source "(defn object-array\n  \"Creates an array of objects\"\n  {:inline (fn [arg] `(. clojure.lang.RT object_array ~arg))\n   :inline-arities #{1}\n   :added \"1.2\"}\n  ([size-or-seq] (. clojure.lang.RT object_array size-or-seq)))", :spec nil, :examples []} {:sym odd?, :meta {:arglists ([n]), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :source "(defn odd?\n  \"Returns true if n is odd, throws an exception if n is not an integer\"\n  {:added \"1.0\"\n   :static true}\n  [n] (not (even? n)))", :spec nil, :examples []} {:sym or, :meta {:arglists ([] [x] [x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil."}, :source "(defmacro or\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.\"\n  {:added \"1.0\"}\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))", :spec nil, :examples []} {:sym parents, :meta {:arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, :source "(defn parents\n  \"Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  {:added \"1.0\"}\n  ([tag] (parents global-hierarchy tag))\n  ([h tag] (not-empty\n            (let [tp (get (:parents h) tag)]\n              (if (class? tag)\n                (into1 (set (bases tag)) tp)\n                tp)))))", :spec nil, :examples []} {:sym partial, :meta {:arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, :source "(defn partial\n  \"Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.\"\n  {:added \"1.0\"\n   :static true}\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))", :spec nil, :examples []} {:sym partition, :meta {:arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, :source "(defn partition\n  \"Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.\"\n  {:added \"1.0\"\n   :static true}\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (when (= n (count p))\n             (cons p (partition n step (nthrest s step))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (if (= n (count p))\n             (cons p (partition n step pad (nthrest s step)))\n             (list (take n (concat p pad)))))))))", :spec nil, :examples []} {:sym partition-all, :meta {:arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, :source "(defn partition-all\n  \"Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([^long n]\n   (fn [rf]\n     (let [a (java.util.ArrayList. n)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (= n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (let [seg (doall (take n s))]\n          (cons seg (partition-all n step (nthrest s step))))))))", :spec nil, :examples []} {:sym partition-by, :meta {:arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, :source "(defn partition-by\n  \"Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([f]\n  (fn [rf]\n    (let [a (java.util.ArrayList.)\n          pv (volatile! ::none)]\n      (fn\n        ([] (rf))\n        ([result]\n           (let [result (if (.isEmpty a)\n                          result\n                          (let [v (vec (.toArray a))]\n                            ;;clear first!\n                            (.clear a)\n                            (unreduced (rf result v))))]\n             (rf result)))\n        ([result input]\n           (let [pval @pv\n                 val (f input)]\n             (vreset! pv val)\n             (if (or (identical? pval ::none)\n                     (= val pval))\n               (do\n                 (.add a input)\n                 result)\n               (let [v (vec (.toArray a))]\n                 (.clear a)\n                 (let [ret (rf result v)]\n                   (when-not (reduced? ret)\n                     (.add a input))\n                   ret)))))))))\n  ([f coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (let [fst (first s)\n              fv (f fst)\n              run (cons fst (take-while #(= fv (f %)) (next s)))]\n          (cons run (partition-by f (seq (drop (count run) s)))))))))", :spec nil, :examples []} {:sym pcalls, :meta {:arglists ([& fns]), :doc "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values"}, :source "(defn pcalls\n  \"Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values\"\n  {:added \"1.0\"\n   :static true}\n  [& fns] (pmap #(%) fns))", :spec nil, :examples []} {:sym peek, :meta {:arglists ([coll]), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :source "(defn peek\n  \"For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (peek coll)))", :spec nil, :examples []} {:sym persistent!, :meta {:arglists ([coll]), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :source "(defn persistent! \n  \"Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.ITransientCollection coll]\n  (.persistent coll))", :spec nil, :examples []} {:sym pmap, :meta {:arglists ([f coll] [f coll & colls]), :doc "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead."}, :source "(defn pmap\n  \"Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.\"\n  {:added \"1.0\"\n   :static true}\n  ([f coll]\n   (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n         rets (map #(future (f %)) coll)\n         step (fn step [[x & xs :as vs] fs]\n                (lazy-seq\n                 (if-let [s (seq fs)]\n                   (cons (deref x) (step xs (rest s)))\n                   (map deref vs))))]\n     (step rets (drop n rets))))\n  ([f coll & colls]\n   (let [step (fn step [cs]\n                (lazy-seq\n                 (let [ss (map seq cs)]\n                   (when (every? identity ss)\n                     (cons (map first ss) (step (map rest ss)))))))]\n     (pmap #(apply f %) (step (cons coll colls))))))", :spec nil, :examples []} {:sym pop, :meta {:arglists ([coll]), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast."}, :source "(defn pop\n  \"For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (pop coll)))", :spec nil, :examples []} {:sym pop!, :meta {:arglists ([coll]), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, :source "(defn pop!\n  \"Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.ITransientVector coll] \n  (.pop coll))", :spec nil, :examples []} {:sym pop-thread-bindings, :meta {:arglists ([]), :doc "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before."}, :source "(defn pop-thread-bindings\n  \"Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (clojure.lang.Var/popThreadBindings))", :spec nil, :examples []} {:sym pos-int?, :meta {:arglists ([x]), :doc "Return true if x is a positive fixed precision integer"}, :source "(defn pos-int?\n  \"Return true if x is a positive fixed precision integer\"\n  {:added \"1.9\"}\n  [x] (and (int? x)\n           (pos? x)))", :spec nil, :examples []} {:sym pos?, :meta {:arglists ([num]), :doc "Returns true if num is greater than zero, else false"}, :source "(defn pos?\n  \"Returns true if num is greater than zero, else false\"\n  {\n   :inline (fn [num] `(. clojure.lang.Numbers (isPos ~num)))\n   :added \"1.0\"}\n  [num] (. clojure.lang.Numbers (isPos num)))", :spec nil, :examples []} {:sym pr, :meta {:arglists ([] [x] [x & more]), :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader"}, :source "(defn pr\n  \"Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader\"\n  {:dynamic true\n   :added \"1.0\"}\n  ([] nil)\n  ([x]\n     (pr-on x *out*))\n  ([x & more]\n   (pr x)\n   (. *out* (append \\space))\n   (if-let [nmore (next more)]\n     (recur (first more) nmore)\n     (apply pr more))))", :spec nil, :examples []} {:sym pr-str, :meta {:arglists ([& xs]), :doc "pr to a string, returning it"}, :source "(defn pr-str\n  \"pr to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply pr xs)))", :spec nil, :examples []} {:sym prefer-method, :meta {:arglists ([multifn dispatch-val-x dispatch-val-y]), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict"}, :source "(defn prefer-method\n  \"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn dispatch-val-x dispatch-val-y]\n  (. multifn preferMethod dispatch-val-x dispatch-val-y))", :spec nil, :examples []} {:sym prefers, :meta {:arglists ([multifn]), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :source "(defn prefers\n  \"Given a multimethod, returns a map of preferred value -> set of other values\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn] (.getPreferTable multifn))", :spec nil, :examples []} {:sym primitives-classnames, :meta {}, :source "(def primitives-classnames\n  {Float/TYPE \"Float/TYPE\"\n   Integer/TYPE \"Integer/TYPE\"\n   Long/TYPE \"Long/TYPE\"\n   Boolean/TYPE \"Boolean/TYPE\"\n   Character/TYPE \"Character/TYPE\"\n   Double/TYPE \"Double/TYPE\"\n   Byte/TYPE \"Byte/TYPE\"\n   Short/TYPE \"Short/TYPE\"})", :spec nil, :examples []} {:sym print, :meta {:arglists ([& more]), :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption."}, :source "(defn print\n  \"Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (binding [*print-readably* nil]\n      (apply pr more)))", :spec nil, :examples []} {:sym print-ctor, :meta {:arglists ([o print-args w])}, :source "(defn print-ctor [o print-args ^Writer w]\n  (.write w \"#=(\")\n  (.write w (.getName ^Class (class o)))\n  (.write w \". \")\n  (print-args o w)\n  (.write w \")\"))", :spec nil, :examples []} {:sym print-dup, :meta {}, :source "(defmulti print-dup (fn [x writer] (class x)))", :spec nil, :examples []} {:sym print-method, :meta {}, :source "(defmulti print-method (fn [x writer]\n                         (let [t (get (meta x) :type)]\n                           (if (keyword? t) t (class x)))))", :spec nil, :examples []} {:sym print-simple, :meta {:arglists ([o w])}, :source "(defn print-simple [o, ^Writer w]\n  (print-meta o w)\n  (.write w (str o)))", :spec nil, :examples []} {:sym print-str, :meta {:arglists ([& xs]), :doc "print to a string, returning it"}, :source "(defn print-str\n  \"print to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply print xs)))", :spec nil, :examples []} {:sym printf, :meta {:arglists ([fmt & args]), :doc "Prints formatted output, as per format"}, :source "(defn printf\n  \"Prints formatted output, as per format\"\n  {:added \"1.0\"\n   :static true}\n  [fmt & args]\n  (print (apply format fmt args)))", :spec nil, :examples []} {:sym println, :meta {:arglists ([& more]), :doc "Same as print followed by (newline)"}, :source "(defn println\n  \"Same as print followed by (newline)\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (binding [*print-readably* nil]\n      (apply prn more)))", :spec nil, :examples []} {:sym println-str, :meta {:arglists ([& xs]), :doc "println to a string, returning it"}, :source "(defn println-str\n  \"println to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply println xs)))", :spec nil, :examples []} {:sym prn, :meta {:arglists ([& more]), :doc "Same as pr followed by (newline). Observes *flush-on-newline*"}, :source "(defn prn\n  \"Same as pr followed by (newline). Observes *flush-on-newline*\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (apply pr more)\n    (newline)\n    (when *flush-on-newline*\n      (flush)))", :spec nil, :examples []} {:sym prn-str, :meta {:arglists ([& xs]), :doc "prn to a string, returning it"}, :source "(defn prn-str\n  \"prn to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n  (with-out-str\n   (apply prn xs)))", :spec nil, :examples []} {:sym promise, :meta {:arglists ([]), :doc "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?."}, :source "(defn promise\n  \"Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (let [d (java.util.concurrent.CountDownLatch. 1)\n        v (atom d)]\n    (reify \n     clojure.lang.IDeref\n       (deref [_] (.await d) @v)\n     clojure.lang.IBlockingDeref\n       (deref\n        [_ timeout-ms timeout-val]\n        (if (.await d timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)\n          @v\n          timeout-val))  \n     clojure.lang.IPending\n      (isRealized [this]\n       (zero? (.getCount d)))\n     clojure.lang.IFn\n     (invoke\n      [this x]\n      (when (and (pos? (.getCount d))\n                 (compare-and-set! v d x))\n        (.countDown d)\n        this)))))", :spec nil, :examples []} {:sym proxy, :meta {:arglists ([class-and-interfaces args & fs]), :doc "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied."}, :source "(defmacro proxy\n  \"class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.\"\n  {:added \"1.0\"}\n  [class-and-interfaces args & fs]\n   (let [bases (map #(or (resolve %) (throw (Exception. (str \"Can't resolve: \" %)))) \n                    class-and-interfaces)\n         [super interfaces] (get-super-and-interfaces bases)\n         compile-effect (when *compile-files*\n                          (let [[cname bytecode] (generate-proxy super interfaces)]\n                            (clojure.lang.Compiler/writeClassFile cname bytecode)))\n         pc-effect (apply get-proxy-class bases)\n         pname (proxy-name super interfaces)]\n     ;remember the class to prevent it from disappearing before use\n     (intern *ns* (symbol pname) pc-effect)\n     `(let [;pc# (get-proxy-class ~@class-and-interfaces)\n            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   \n        (init-proxy p#\n         ~(loop [fmap {} fs fs]\n            (if fs\n              (let [[sym & meths] (first fs)\n                    meths (if (vector? (first meths))\n                            (list meths)\n                            meths)\n                    meths (map (fn [[params & body]]\n                                   (cons (apply vector 'this params) body))\n                               meths)]\n                (if-not (contains? fmap (name sym))\t\t  \n                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))\n\t\t           (throw (IllegalArgumentException.\n\t\t\t              (str \"Method '\" (name sym) \"' redefined\")))))\n              fmap)))\n        p#)))", :spec nil, :examples []} {:sym proxy-call-with-super, :meta {:arglists ([call this meth])}, :source "(defn proxy-call-with-super [call this meth]\n (let [m (proxy-mappings this)]\n    (update-proxy this (assoc m meth nil))\n    (try\n      (call)\n      (finally (update-proxy this m)))))", :spec nil, :examples []} {:sym proxy-mappings, :meta {:arglists ([proxy]), :doc "Takes a proxy instance and returns the proxy's fn map."}, :source "(defn proxy-mappings\n  \"Takes a proxy instance and returns the proxy's fn map.\"\n  {:added \"1.0\"}\n  [^IProxy proxy]\n    (. proxy (__getClojureFnMappings)))", :spec nil, :examples []} {:sym proxy-name, :meta {:arglists ([super interfaces])}, :source "(defn proxy-name\n {:tag String} \n [^Class super interfaces]\n  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]\n    (apply str (.replace (str *ns*) \\- \\_) \".proxy\"\n      (interleave (repeat \"$\")\n        (concat\n          [(.getName super)]\n          (map #(subs % (inc (.lastIndexOf ^String % \".\"))) inames)\n          [(Integer/toHexString (hash inames))])))))", :spec nil, :examples []} {:sym proxy-super, :meta {:arglists ([meth & args]), :doc "Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this"}, :source "(defmacro proxy-super \n  \"Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this\"\n  {:added \"1.0\"}\n  [meth & args]\n `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))", :spec nil, :examples []} {:sym push-thread-bindings, :meta {:arglists ([bindings]), :doc "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))"}, :source "(defn push-thread-bindings\n  \"WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))\"\n  {:added \"1.1\"\n   :static true} \n  [bindings]\n  (clojure.lang.Var/pushThreadBindings bindings))", :spec nil, :examples []} {:sym pvalues, :meta {:arglists ([& exprs]), :doc "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel"}, :source "(defmacro pvalues\n  \"Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel\"\n  {:added \"1.0\"\n   :static true}\n  [& exprs]\n  `(pcalls ~@(map #(list `fn [] %) exprs)))", :spec nil, :examples []} {:sym qualified-ident?, :meta {:arglists ([x]), :doc "Return true if x is a symbol or keyword with a namespace"}, :source "(defn qualified-ident?\n  \"Return true if x is a symbol or keyword with a namespace\"\n  {:added \"1.9\"}\n  [x] (boolean (and (ident? x) (namespace x) true)))", :spec nil, :examples []} {:sym qualified-keyword?, :meta {:arglists ([x]), :doc "Return true if x is a keyword with a namespace"}, :source "(defn qualified-keyword?\n  \"Return true if x is a keyword with a namespace\"\n  {:added \"1.9\"}\n  [x] (boolean (and (keyword? x) (namespace x) true)))", :spec nil, :examples []} {:sym qualified-symbol?, :meta {:arglists ([x]), :doc "Return true if x is a symbol with a namespace"}, :source "(defn qualified-symbol?\n  \"Return true if x is a symbol with a namespace\"\n  {:added \"1.9\"}\n  [x] (boolean (and (symbol? x) (namespace x) true)))", :spec nil, :examples []} {:sym quot, :meta {:arglists ([num div]), :doc "quot[ient] of dividing numerator by denominator."}, :source "(defn quot\n  \"quot[ient] of dividing numerator by denominator.\"\n  {:added \"1.0\"\n   :static true\n   :inline (fn [x y] `(. clojure.lang.Numbers (quotient ~x ~y)))}\n  [num div]\n    (. clojure.lang.Numbers (quotient num div)))", :spec nil, :examples []} {:sym rand, :meta {:arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, :source "(defn rand\n  \"Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).\"\n  {:added \"1.0\"\n   :static true}\n  ([] (. Math (random)))\n  ([n] (* n (rand))))", :spec nil, :examples []} {:sym rand-int, :meta {:arglists ([n]), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :source "(defn rand-int\n  \"Returns a random integer between 0 (inclusive) and n (exclusive).\"\n  {:added \"1.0\"\n   :static true}\n  [n] (int (rand n)))", :spec nil, :examples []} {:sym rand-nth, :meta {:arglists ([coll]), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :source "(defn rand-nth\n  \"Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.\"\n  {:added \"1.2\"\n   :static true}\n  [coll]\n  (nth coll (rand-int (count coll))))", :spec nil, :examples []} {:sym random-sample, :meta {:arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, :source "(defn random-sample\n  \"Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.\"\n  {:added \"1.7\"}\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))", :spec nil, :examples []} {:sym range, :meta {:arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list."}, :source "(defn range\n  \"Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.\"\n  {:added \"1.0\"\n   :static true}\n  ([]\n   (iterate inc' 0))\n  ([end]\n   (if (instance? Long end)\n     (clojure.lang.LongRange/create end)\n     (clojure.lang.Range/create end)))\n  ([start end]\n   (if (and (instance? Long start) (instance? Long end))\n     (clojure.lang.LongRange/create start end)\n     (clojure.lang.Range/create start end)))\n  ([start end step]\n   (if (and (instance? Long start) (instance? Long end) (instance? Long step))\n     (clojure.lang.LongRange/create start end step)\n     (clojure.lang.Range/create start end step))))", :spec nil, :examples []} {:sym ratio?, :meta {:arglists ([n]), :doc "Returns true if n is a Ratio"}, :source "(defn ratio?\n  \"Returns true if n is a Ratio\"\n  {:added \"1.0\"\n   :static true}\n  [n] (instance? clojure.lang.Ratio n))", :spec nil, :examples []} {:sym rational?, :meta {:arglists ([n]), :doc "Returns true if n is a rational number"}, :source "(defn rational? \n  \"Returns true if n is a rational number\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (integer? n) (ratio? n) (decimal? n)))", :spec nil, :examples []} {:sym rationalize, :meta {:arglists ([num]), :doc "returns the rational value of num"}, :source "(defn rationalize\n  \"returns the rational value of num\"\n  {:added \"1.0\"\n   :static true}\n  [num]\n  (. clojure.lang.Numbers (rationalize num)))", :spec nil, :examples []} {:sym re-find, :meta {:arglists ([m] [re s]), :doc "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups."}, :source "(defn re-find\n  \"Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.\"\n  {:added \"1.0\"\n   :static true}\n  ([^java.util.regex.Matcher m]\n   (when (. m (find))\n     (re-groups m)))\n  ([^java.util.regex.Pattern re s]\n   (let [m (re-matcher re s)]\n     (re-find m))))", :spec nil, :examples []} {:sym re-groups, :meta {:arglists ([m]), :doc "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match."}, :source "(defn re-groups\n  \"Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Matcher m]\n    (let [gc  (. m (groupCount))]\n      (if (zero? gc)\n        (. m (group))\n        (loop [ret [] c 0]\n          (if (<= c gc)\n            (recur (conj ret (. m (group c))) (inc c))\n            ret)))))", :spec nil, :examples []} {:sym re-matcher, :meta {:arglists ([re s]), :doc "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find."}, :source "(defn re-matcher\n  \"Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.\"\n  {:tag java.util.regex.Matcher\n   :added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n    (. re (matcher s)))", :spec nil, :examples []} {:sym re-matches, :meta {:arglists ([re s]), :doc "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups."}, :source "(defn re-matches\n  \"Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n    (let [m (re-matcher re s)]\n      (when (. m (matches))\n        (re-groups m))))", :spec nil, :examples []} {:sym re-pattern, :meta {:arglists ([s]), :doc "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher."}, :source "(defn re-pattern\n  \"Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.\"\n  {:tag java.util.regex.Pattern\n   :added \"1.0\"\n   :static true}\n  [s] (if (instance? java.util.regex.Pattern s)\n        s\n        (. java.util.regex.Pattern (compile s))))", :spec nil, :examples []} {:sym re-seq, :meta {:arglists ([re s]), :doc "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups."}, :source "(defn re-seq\n  \"Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n  (let [m (re-matcher re s)]\n    ((fn step []\n       (when (. m (find))\n         (cons (re-groups m) (lazy-seq (step))))))))", :spec nil, :examples []} {:sym read, :meta {:arglists ([] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?] [opts stream]), :doc "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read"}, :source "(defn read\n  \"Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read\"\n  {:added \"1.0\"\n   :static true}\n  ([]\n   (read *in*))\n  ([stream]\n   (read stream true nil))\n  ([stream eof-error? eof-value]\n   (read stream eof-error? eof-value false))\n  ([stream eof-error? eof-value recursive?]\n   (. clojure.lang.LispReader (read stream (boolean eof-error?) eof-value recursive?)))\n  ([opts stream]\n   (. clojure.lang.LispReader (read stream opts))))", :spec nil, :examples []} {:sym read-line, :meta {:arglists ([]), :doc "Reads the next line from stream that is the current value of *in* ."}, :source "(defn read-line\n  \"Reads the next line from stream that is the current value of *in* .\"\n  {:added \"1.0\"\n   :static true}\n  []\n  (if (instance? clojure.lang.LineNumberingPushbackReader *in*)\n    (.readLine ^clojure.lang.LineNumberingPushbackReader *in*)\n    (.readLine ^java.io.BufferedReader *in*)))", :spec nil, :examples []} {:sym read-string, :meta {:arglists ([s] [opts s]), :doc "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string"}, :source "(defn read-string\n  \"Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string\"\n  {:added \"1.0\"\n   :static true}\n  ([s] (clojure.lang.RT/readString s))\n  ([opts s] (clojure.lang.RT/readString s opts)))", :spec nil, :examples []} {:sym reader-conditional, :meta {:arglists ([form splicing?]), :doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing."}, :source "(defn reader-conditional\n  \"Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.\"\n  {:added \"1.7\"}\n  [form ^Boolean splicing?]\n  (clojure.lang.ReaderConditional/create form splicing?))", :spec nil, :examples []} {:sym reader-conditional?, :meta {:arglists ([value]), :doc "Return true if the value is the data representation of a reader conditional"}, :source "(defn reader-conditional?\n  \"Return true if the value is the data representation of a reader conditional\"\n  {:added \"1.7\"}\n  [value]\n  (instance? clojure.lang.ReaderConditional value))", :spec nil, :examples []} {:sym realized?, :meta {:arglists ([x]), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}, :source "(defn realized?\n  \"Returns true if a value has been produced for a promise, delay, future or lazy sequence.\"\n  {:added \"1.3\"}\n  [^clojure.lang.IPending x] (.isRealized x))", :spec nil, :examples []} {:sym record?, :meta {:arglists ([x]), :doc "Returns true if x is a record"}, :source "(defn record?\n  \"Returns true if x is a record\"\n  {:added \"1.6\"\n   :static true}\n  [x]\n  (instance? clojure.lang.IRecord x))", :spec nil, :examples []} {:sym reduce, :meta {:arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, :source "(defn reduce\n  \"f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.\"\n  {:added \"1.0\"}\n  ([f coll]\n     (if (instance? clojure.lang.IReduce coll)\n       (.reduce ^clojure.lang.IReduce coll f)\n       (clojure.core.protocols/coll-reduce coll f)))\n  ([f val coll]\n     (if (instance? clojure.lang.IReduceInit coll)\n       (.reduce ^clojure.lang.IReduceInit coll f val)\n       (clojure.core.protocols/coll-reduce coll f val))))", :spec nil, :examples []} {:sym reduce-kv, :meta {:arglists ([f init coll]), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :source "(defn reduce-kv\n  \"Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.\"  \n  {:added \"1.4\"}\n  ([f init coll]\n     (clojure.core.protocols/kv-reduce coll f init)))", :spec nil, :examples []} {:sym reduced, :meta {:arglists ([x]), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :source "(defn reduced\n  \"Wraps x in a way such that a reduce will terminate with the value x\"\n  {:added \"1.5\"}\n  [x]\n  (clojure.lang.Reduced. x))", :spec nil, :examples []} {:sym reduced?, :meta {:arglists ([x]), :doc "Returns true if x is the result of a call to reduced"}, :source "(defn reduced?\n  \"Returns true if x is the result of a call to reduced\"\n  {:inline (fn [x] `(clojure.lang.RT/isReduced ~x ))\n   :inline-arities #{1}\n   :added \"1.5\"}\n  ([x] (clojure.lang.RT/isReduced x)))", :spec nil, :examples []} {:sym reductions, :meta {:arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, :source "(defn reductions\n  \"Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.\"\n  {:added \"1.2\"}\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (if (reduced? init)\n       (list @init)\n       (cons init\n             (lazy-seq\n              (when-let [s (seq coll)]\n                (reductions f (f init (first s)) (rest s))))))))", :spec nil, :examples []} {:sym ref, :meta {:arglists ([x] [x & options]), :doc "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history."}, :source "(defn ref\n  \"Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.\"\n  {:added \"1.0\"\n   :static true\n   }\n  ([x] (new clojure.lang.Ref x))\n  ([x & options] \n   (let [r  ^clojure.lang.Ref (setup-reference (ref x) options)\n         opts (apply hash-map options)]\n    (when (:max-history opts)\n      (.setMaxHistory r (:max-history opts)))\n    (when (:min-history opts)\n      (.setMinHistory r (:min-history opts)))\n    r)))", :spec nil, :examples []} {:sym ref-history-count, :meta {:arglists ([ref]), :doc "Returns the history count of a ref"}, :source "(defn ref-history-count\n  \"Returns the history count of a ref\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.Ref ref]\n    (.getHistoryCount ref))", :spec nil, :examples []} {:sym ref-max-history, :meta {:arglists ([ref] [ref n]), :doc "Gets the max-history of a ref, or sets it and returns the ref"}, :source "(defn ref-max-history\n  \"Gets the max-history of a ref, or sets it and returns the ref\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.Ref ref]\n    (.getMaxHistory ref))\n  ([^clojure.lang.Ref ref n]\n    (.setMaxHistory ref n)))", :spec nil, :examples []} {:sym ref-min-history, :meta {:arglists ([ref] [ref n]), :doc "Gets the min-history of a ref, or sets it and returns the ref"}, :source "(defn ref-min-history\n  \"Gets the min-history of a ref, or sets it and returns the ref\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.Ref ref]\n    (.getMinHistory ref))\n  ([^clojure.lang.Ref ref n]\n    (.setMinHistory ref n)))", :spec nil, :examples []} {:sym ref-set, :meta {:arglists ([ref val]), :doc "Must be called in a transaction. Sets the value of ref.\n  Returns val."}, :source "(defn ref-set\n  \"Must be called in a transaction. Sets the value of ref.\n  Returns val.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref val]\n    (. ref (set val)))", :spec nil, :examples []} {:sym refer, :meta {:arglists ([ns-sym & filters]), :doc "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly."}, :source "(defn refer\n  \"refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.\"\n  {:added \"1.0\"}\n  [ns-sym & filters]\n    (let [ns (or (find-ns ns-sym) (throw (new Exception (str \"No namespace: \" ns-sym))))\n          fs (apply hash-map filters)\n          nspublics (ns-publics ns)\n          rename (or (:rename fs) {})\n          exclude (set (:exclude fs))\n          to-do (if (= :all (:refer fs))\n                  (keys nspublics)\n                  (or (:refer fs) (:only fs) (keys nspublics)))]\n      (when (and to-do (not (instance? clojure.lang.Sequential to-do)))\n        (throw (new Exception \":only/:refer value must be a sequential collection of symbols\")))\n      (doseq [sym to-do]\n        (when-not (exclude sym)\n          (let [v (nspublics sym)]\n            (when-not v\n              (throw (new java.lang.IllegalAccessError\n                          (if (get (ns-interns ns) sym)\n                            (str sym \" is not public\")\n                            (str sym \" does not exist\")))))\n            (. *ns* (refer (or (rename sym) sym) v)))))))", :spec nil, :examples []} {:sym refer-clojure, :meta {:arglists ([& filters]), :doc "Same as (refer 'clojure.core <filters>)"}, :source "(defmacro refer-clojure\n  \"Same as (refer 'clojure.core <filters>)\"\n  {:added \"1.0\"}\n  [& filters]\n  `(clojure.core/refer '~'clojure.core ~@filters))", :spec "(clojure.spec.alpha/fspec\n :args\n (clojure.spec.alpha/*\n  (clojure.spec.alpha/alt\n   :exclude\n   (clojure.spec.alpha/cat\n    :op\n    (clojure.core.specs.alpha/quotable #{:exclude})\n    :arg\n    (clojure.core.specs.alpha/quotable\n     :clojure.core.specs.alpha/exclude))\n   :only\n   (clojure.spec.alpha/cat\n    :op\n    (clojure.core.specs.alpha/quotable #{:only})\n    :arg\n    (clojure.core.specs.alpha/quotable :clojure.core.specs.alpha/only))\n   :rename\n   (clojure.spec.alpha/cat\n    :op\n    (clojure.core.specs.alpha/quotable #{:rename})\n    :arg\n    (clojure.core.specs.alpha/quotable\n     :clojure.core.specs.alpha/rename))))\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym reify, :meta {:arglists ([& opts+specs]), :doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \"foo\"] \n       (reify Object \n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}"}, :source "(defmacro reify \n  \"reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \\\"foo\\\"] \n       (reify Object \n         (toString [this] f))))\n  == \\\"foo\\\"\n\n  (seq (let [f \\\"foo\\\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\\\f \\\\o \\\\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \\\"foo\\\")))\n  == {:k :v}\"\n  {:added \"1.2\"} \n  [& opts+specs]\n  (let [[interfaces methods] (parse-opts+specs opts+specs)]\n    (with-meta `(reify* ~interfaces ~@methods) (meta &form))))", :spec nil, :examples []} {:sym release-pending-sends, :meta {:arglists ([]), :doc "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched."}, :source "(defn release-pending-sends\n  \"Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.\"\n  {:added \"1.0\"\n   :static true}\n  [] (clojure.lang.Agent/releasePendingSends))", :spec nil, :examples []} {:sym rem, :meta {:arglists ([num div]), :doc "remainder of dividing numerator by denominator."}, :source "(defn rem\n  \"remainder of dividing numerator by denominator.\"\n  {:added \"1.0\"\n   :static true\n   :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}\n  [num div]\n    (. clojure.lang.Numbers (remainder num div)))", :spec nil, :examples []} {:sym remove, :meta {:arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, :source "(defn remove\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))", :spec nil, :examples []} {:sym remove-all-methods, :meta {:arglists ([multifn]), :doc "Removes all of the methods of multimethod."}, :source "(defn remove-all-methods\n  \"Removes all of the methods of multimethod.\"\n  {:added \"1.2\"\n   :static true} \n [^clojure.lang.MultiFn multifn]\n (.reset multifn))", :spec nil, :examples []} {:sym remove-method, :meta {:arglists ([multifn dispatch-val]), :doc "Removes the method of multimethod associated with dispatch-value."}, :source "(defn remove-method\n  \"Removes the method of multimethod associated with dispatch-value.\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.MultiFn multifn dispatch-val]\n (. multifn removeMethod dispatch-val))", :spec nil, :examples []} {:sym remove-ns, :meta {:arglists ([sym]), :doc "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace."}, :source "(defn remove-ns\n  \"Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/remove sym))", :spec nil, :examples []} {:sym remove-watch, :meta {:arglists ([reference key]), :doc "Removes a watch (set by add-watch) from a reference"}, :source "(defn remove-watch\n  \"Removes a watch (set by add-watch) from a reference\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef reference key]\n  (.removeWatch reference key))", :spec nil, :examples []} {:sym repeat, :meta {:arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, :source "(defn repeat\n  \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n  {:added \"1.0\"\n   :static true}\n  ([x] (clojure.lang.Repeat/create x))\n  ([n x] (clojure.lang.Repeat/create n x)))", :spec nil, :examples []} {:sym repeatedly, :meta {:arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, :source "(defn repeatedly\n  \"Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it\"\n  {:added \"1.0\"\n   :static true}\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))", :spec nil, :examples []} {:sym replace, :meta {:arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, :source "(defn replace\n  \"Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (reduce1 (fn [v i]\n                  (if-let [e (find smap (nth v i))]\n                    (assoc v i (val e))\n                    v))\n                coll (range (count coll)))\n       (map #(if-let [e (find smap %)] (val e) %) coll))))", :spec nil, :examples []} {:sym replicate, :meta {:arglists ([n x]), :doc "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs."}, :source "(defn replicate\n  \"DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.\"\n  {:added \"1.0\"\n   :deprecated \"1.3\"}\n  [n x] (take n (repeat x)))", :spec nil, :examples []} {:sym require, :meta {:arglists ([& args]), :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))"}, :source "(defn require\n  \"Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))\"\n  {:added \"1.0\"}\n\n  [& args]\n  (apply load-libs :require args))", :spec nil, :examples []} {:sym reset!, :meta {:arglists ([atom newval]), :doc "Sets the value of atom to newval without regard for the\n  current value. Returns newval."}, :source "(defn reset!\n  \"Sets the value of atom to newval without regard for the\n  current value. Returns newval.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IAtom atom newval] (.reset atom newval))", :spec nil, :examples []} {:sym reset-meta!, :meta {:arglists ([iref metadata-map]), :doc "Atomically resets the metadata for a namespace/var/ref/agent/atom"}, :source "(defn reset-meta!\n  \"Atomically resets the metadata for a namespace/var/ref/agent/atom\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IReference iref metadata-map] (.resetMeta iref metadata-map))", :spec nil, :examples []} {:sym reset-vals!, :meta {:arglists ([atom newval]), :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset."}, :source "(defn reset-vals!\n  \"Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.\"\n  {:added \"1.9\"}\n  ^clojure.lang.IPersistentVector [^clojure.lang.IAtom2 atom newval] (.resetVals atom newval))", :spec nil, :examples []} {:sym resolve, :meta {:arglists ([sym] [env sym]), :doc "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)"}, :source "(defn resolve\n  \"same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)\"\n  {:added \"1.0\"\n   :static true}\n  ([sym] (ns-resolve *ns* sym))\n  ([env sym] (ns-resolve *ns* env sym)))", :spec nil, :examples []} {:sym rest, :meta {:arglists ([coll]), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :source "(def\n ^{:arglists '([coll])\n   :tag clojure.lang.ISeq\n   :doc \"Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.\"\n   :added \"1.0\"\n   :static true}  \n rest (fn ^:static rest [x] (. clojure.lang.RT (more x))))", :spec nil, :examples []} {:sym restart-agent, :meta {:arglists ([a new-state & options]), :doc "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed."}, :source "(defn restart-agent\n  \"When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.\"\n  {:added \"1.2\"\n   :static true\n   }\n  [^clojure.lang.Agent a, new-state & options]\n  (let [opts (apply hash-map options)]\n    (.restart a new-state (if (:clear-actions opts) true false))))", :spec nil, :examples []} {:sym resultset-seq, :meta {:arglists ([rs]), :doc "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs"}, :source "(defn resultset-seq\n  \"Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs\"\n  {:added \"1.0\"}\n  [^java.sql.ResultSet rs]\n    (let [rsmeta (. rs (getMetaData))\n          idxs (range 1 (inc (. rsmeta (getColumnCount))))\n          keys (map (comp keyword #(.toLowerCase ^String %))\n                    (map (fn [i] (. rsmeta (getColumnLabel i))) idxs))\n          check-keys\n                (or (apply distinct? keys)\n                    (throw (Exception. \"ResultSet must have unique column labels\")))\n          row-struct (apply create-struct keys)\n          row-values (fn [] (map (fn [^Integer i] (. rs (getObject i))) idxs))\n          rows (fn thisfn []\n                 (when (. rs (next))\n                   (cons (apply struct row-struct (row-values)) (lazy-seq (thisfn)))))]\n      (rows)))", :spec nil, :examples []} {:sym reverse, :meta {:arglists ([coll]), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :source "(defn reverse\n  \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n    (reduce1 conj () coll))", :spec nil, :examples []} {:sym reversible?, :meta {:arglists ([coll]), :doc "Returns true if coll implements Reversible"}, :source "(defn reversible?\n \"Returns true if coll implements Reversible\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Reversible coll))", :spec nil, :examples []} {:sym rseq, :meta {:arglists ([rev]), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :source "(defn rseq\n  \"Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Reversible rev]\n    (. rev (rseq)))", :spec nil, :examples []} {:sym rsubseq, :meta {:arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, :source "(defn rsubseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.Sorted sc test key]\n   (let [include (mk-bound-fn sc test key)]\n     (if (#{< <=} test)\n       (when-let [[e :as s] (. sc seqFrom key false)]\n         (if (include e) s (next s)))\n       (take-while include (. sc seq false)))))\n  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]\n   (when-let [[e :as s] (. sc seqFrom end-key false)]\n     (take-while (mk-bound-fn sc start-test start-key)\n                 (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))", :spec nil, :examples []} {:sym run!, :meta {:arglists ([proc coll]), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :source "(defn run!\n  \"Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil\"\n  {:added \"1.7\"}\n  [proc coll]\n  (reduce #(proc %2) nil coll)\n  nil)", :spec nil, :examples []} {:sym satisfies?, :meta {:arglists ([protocol x]), :doc "Returns true if x satisfies the protocol"}, :source "(defn satisfies? \n  \"Returns true if x satisfies the protocol\"\n  {:added \"1.2\"}\n  [protocol x]\n  (boolean (find-protocol-impl protocol x)))", :spec nil, :examples []} {:sym second, :meta {:arglists ([x]), :doc "Same as (first (next x))"}, :source "(def\n ^{:doc \"Same as (first (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n second (fn ^:static second [x] (first (next x))))", :spec nil, :examples []} {:sym select-keys, :meta {:arglists ([map keyseq]), :doc "Returns a map containing only those entries in map whose key is in keys"}, :source "(defn select-keys\n  \"Returns a map containing only those entries in map whose key is in keys\"\n  {:added \"1.0\"\n   :static true}\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [entry (. clojure.lang.RT (find map (first keys)))]\n          (recur\n           (if entry\n             (conj ret entry)\n             ret)\n           (next keys)))\n        (with-meta ret (meta map)))))", :spec nil, :examples []} {:sym send, :meta {:arglists ([a f & args]), :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)"}, :source "(defn send\n  \"Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Agent a f & args]\n  (apply send-via clojure.lang.Agent/pooledExecutor a f args))", :spec nil, :examples []} {:sym send-off, :meta {:arglists ([a f & args]), :doc "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)"}, :source "(defn send-off\n  \"Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Agent a f & args]\n  (apply send-via clojure.lang.Agent/soloExecutor a f args))", :spec nil, :examples []} {:sym send-via, :meta {:arglists ([executor a f & args]), :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)"}, :source "(defn send-via\n  \"Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.5\"}\n  [executor ^clojure.lang.Agent a f & args]\n  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args executor))", :spec nil, :examples []} {:sym seq, :meta {:arglists ([coll]), :doc "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object."}, :source "(def\n ^{:arglists '(^clojure.lang.ISeq [coll])\n   :doc \"Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.\"\n   :tag clojure.lang.ISeq\n   :added \"1.0\"\n   :static true}\n seq (fn ^:static seq ^clojure.lang.ISeq [coll] (. clojure.lang.RT (seq coll))))", :spec nil, :examples []} {:sym seq?, :meta {:arglists ([x]), :doc "Return true if x implements ISeq"}, :source "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements ISeq\"\n   :added \"1.0\"\n   :static true}\n seq? (fn ^:static seq? [x] (instance? clojure.lang.ISeq x)))", :spec nil, :examples []} {:sym seqable?, :meta {:arglists ([x]), :doc "Return true if the seq function is supported for x"}, :source "(defn seqable?\n  \"Return true if the seq function is supported for x\"\n  {:added \"1.9\"}\n  [x] (clojure.lang.RT/canSeq x))", :spec nil, :examples []} {:sym seque, :meta {:arglists ([s] [n-or-q s]), :doc "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer."}, :source "(defn seque\n  \"Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.\"\n  {:added \"1.0\"\n   :static true}\n  ([s] (seque 100 s))\n  ([n-or-q s]\n   (let [^BlockingQueue q (if (instance? BlockingQueue n-or-q)\n                             n-or-q\n                             (LinkedBlockingQueue. (int n-or-q)))\n         NIL (Object.) ;nil sentinel since LBQ doesn't support nils\n         agt (agent (lazy-seq s)) ; never start with nil; that signifies we've already put eos\n         log-error (fn [q e]\n                     (if (.offer q q)\n                       (throw e)\n                       e))\n         fill (fn [s]\n                (when s\n                  (if (instance? Exception s) ; we failed to .offer an error earlier\n                    (log-error q s)\n                    (try\n                      (loop [[x & xs :as s] (seq s)]\n                        (if s\n                          (if (.offer q (if (nil? x) NIL x))\n                            (recur xs)\n                            s)\n                          (when-not (.offer q q) ; q itself is eos sentinel\n                            ()))) ; empty seq, not nil, so we know to put eos next time\n                      (catch Exception e\n                        (log-error q e))))))\n         drain (fn drain []\n                 (lazy-seq\n                  (let [x (.take q)]\n                    (if (identical? x q) ;q itself is eos sentinel\n                      (do @agt nil)  ;touch agent just to propagate errors\n                      (do\n                        (send-off agt fill)\n                        (release-pending-sends)\n                        (cons (if (identical? x NIL) nil x) (drain)))))))]\n     (send-off agt fill)\n     (drain))))", :spec nil, :examples []} {:sym sequence, :meta {:arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, :source "(defn sequence\n  \"Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n     (if (seq? coll) coll\n         (or (seq coll) ())))\n  ([xform coll]\n     (or (clojure.lang.RT/chunkIteratorSeq\n         (clojure.lang.TransformerIterator/create xform (clojure.lang.RT/iter coll)))\n       ()))\n  ([xform coll & colls]\n     (or (clojure.lang.RT/chunkIteratorSeq\n         (clojure.lang.TransformerIterator/createMulti\n           xform\n           (map #(clojure.lang.RT/iter %) (cons coll colls))))\n       ())))", :spec nil, :examples []} {:sym sequential?, :meta {:arglists ([coll]), :doc "Returns true if coll implements Sequential"}, :source "(defn sequential?\n \"Returns true if coll implements Sequential\"\n {:added \"1.0\"\n  :static true}\n  [coll] (instance? clojure.lang.Sequential coll))", :spec nil, :examples []} {:sym set, :meta {:arglists ([coll]), :doc "Returns a set of the distinct elements of coll."}, :source "(defn set\n  \"Returns a set of the distinct elements of coll.\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n  (if (set? coll)\n    (with-meta coll nil)\n    (if (instance? clojure.lang.IReduceInit coll)\n      (persistent! (.reduce ^clojure.lang.IReduceInit coll conj! (transient #{})))\n      (persistent! (reduce1 conj! (transient #{}) coll)))))", :spec nil, :examples []} {:sym set-agent-send-executor!, :meta {:arglists ([executor]), :doc "Sets the ExecutorService to be used by send"}, :source "(defn set-agent-send-executor!\n  \"Sets the ExecutorService to be used by send\"\n  {:added \"1.5\"}\n  [executor]\n  (set! clojure.lang.Agent/pooledExecutor executor))", :spec nil, :examples []} {:sym set-agent-send-off-executor!, :meta {:arglists ([executor]), :doc "Sets the ExecutorService to be used by send-off"}, :source "(defn set-agent-send-off-executor!\n  \"Sets the ExecutorService to be used by send-off\"\n  {:added \"1.5\"}\n  [executor]\n  (set! clojure.lang.Agent/soloExecutor executor))", :spec nil, :examples []} {:sym set-error-handler!, :meta {:arglists ([a handler-fn]), :doc "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception."}, :source "(defn set-error-handler!\n  \"Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a, handler-fn]\n  (.setErrorHandler a handler-fn))", :spec nil, :examples []} {:sym set-error-mode!, :meta {:arglists ([a mode-keyword]), :doc "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error."}, :source "(defn set-error-mode!\n  \"Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a, mode-keyword]\n  (.setErrorMode a mode-keyword))", :spec nil, :examples []} {:sym set-validator!, :meta {:arglists ([iref validator-fn]), :doc "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed."}, :source "(defn set-validator!\n  \"Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef iref validator-fn] (. iref (setValidator validator-fn)))", :spec nil, :examples []} {:sym set?, :meta {:arglists ([x]), :doc "Returns true if x implements IPersistentSet"}, :source "(defn set?\n  \"Returns true if x implements IPersistentSet\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentSet x))", :spec nil, :examples []} {:sym short, :meta {:arglists ([x]), :doc "Coerce to short"}, :source "(defn short\n  \"Coerce to short\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedShortCast 'shortCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/shortCast x))", :spec nil, :examples []} {:sym short-array, :meta {:arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of shorts"}, :source "(defn short-array\n  \"Creates an array of shorts\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers short_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers short_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers short_array size init-val-or-seq)))", :spec nil, :examples []} {:sym shorts, :meta {:arglists ([xs]), :doc "Casts to shorts[]"}, :source "(definline shorts\n  \"Casts to shorts[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers shorts ~xs))", :spec nil, :examples []} {:sym shuffle, :meta {:arglists ([coll]), :doc "Return a random permutation of coll"}, :source "(defn shuffle\n  \"Return a random permutation of coll\"\n  {:added \"1.2\"\n   :static true}\n  [^java.util.Collection coll]\n  (let [al (java.util.ArrayList. coll)]\n    (java.util.Collections/shuffle al)\n    (clojure.lang.RT/vector (.toArray al))))", :spec nil, :examples []} {:sym shutdown-agents, :meta {:arglists ([]), :doc "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted"}, :source "(defn shutdown-agents\n  \"Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted\"\n  {:added \"1.0\"\n   :static true}\n  [] (. clojure.lang.Agent shutdown))", :spec nil, :examples []} {:sym simple-ident?, :meta {:arglists ([x]), :doc "Return true if x is a symbol or keyword without a namespace"}, :source "(defn simple-ident?\n  \"Return true if x is a symbol or keyword without a namespace\"\n  {:added \"1.9\"}\n  [x] (and (ident? x) (nil? (namespace x))))", :spec nil, :examples []} {:sym simple-keyword?, :meta {:arglists ([x]), :doc "Return true if x is a keyword without a namespace"}, :source "(defn simple-keyword?\n  \"Return true if x is a keyword without a namespace\"\n  {:added \"1.9\"}\n  [x] (and (keyword? x) (nil? (namespace x))))", :spec nil, :examples []} {:sym simple-symbol?, :meta {:arglists ([x]), :doc "Return true if x is a symbol without a namespace"}, :source "(defn simple-symbol?\n  \"Return true if x is a symbol without a namespace\"\n  {:added \"1.9\"}\n  [x] (and (symbol? x) (nil? (namespace x))))", :spec nil, :examples []} {:sym slurp, :meta {:arglists ([f & opts]), :doc "Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments."}, :source "(defn slurp\n  \"Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.\"\n  {:added \"1.0\"\n   :tag String}\n  ([f & opts]\n     (let [opts (normalize-slurp-opts opts)\n           sw (java.io.StringWriter.)]\n       (with-open [^java.io.Reader r (apply jio/reader f opts)]\n         (jio/copy r sw)\n         (.toString sw)))))", :spec nil, :examples []} {:sym some, :meta {:arglists ([pred coll]), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :source "(defn some\n  \"Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))", :spec nil, :examples []} {:sym some->, :meta {:arglists ([expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc"}, :source "(defmacro some->\n  \"When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc\"\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        steps (map (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))\n                   forms)]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))", :spec nil, :examples []} {:sym some->>, :meta {:arglists ([expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc"}, :source "(defmacro some->>\n  \"When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc\"\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        steps (map (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))\n                   forms)]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))", :spec nil, :examples []} {:sym some-fn, :meta {:arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, :source "(defn some-fn\n  \"Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.\"\n  {:added \"1.3\"}\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))", :spec nil, :examples []} {:sym some?, :meta {:arglists ([x]), :doc "Returns true if x is not nil, false otherwise."}, :source "(defn some?\n  \"Returns true if x is not nil, false otherwise.\"\n  {:tag Boolean\n   :added \"1.6\"\n   :static true}\n  [x] (not (nil? x)))", :spec nil, :examples []} {:sym sort, :meta {:arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array."}, :source "(defn sort\n  \"Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (sort compare coll))\n  ([^java.util.Comparator comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       (. java.util.Arrays (sort a comp))\n       (seq a))\n     ())))", :spec nil, :examples []} {:sym sort-by, :meta {:arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array."}, :source "(defn sort-by\n  \"Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.\"\n  {:added \"1.0\"\n   :static true}\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn ^java.util.Comparator comp coll]\n   (sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)))", :spec nil, :examples []} {:sym sorted-map, :meta {:arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc."}, :source "(defn sorted-map\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([& keyvals]\n   (clojure.lang.PersistentTreeMap/create keyvals)))", :spec nil, :examples []} {:sym sorted-map-by, :meta {:arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc."}, :source "(defn sorted-map-by\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([comparator & keyvals]\n   (clojure.lang.PersistentTreeMap/create comparator keyvals)))", :spec nil, :examples []} {:sym sorted-set, :meta {:arglists ([& keys]), :doc "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, :source "(defn sorted-set\n  \"Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.\"\n  {:added \"1.0\"\n   :static true}\n  ([& keys]\n   (clojure.lang.PersistentTreeSet/create keys)))", :spec nil, :examples []} {:sym sorted-set-by, :meta {:arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj."}, :source "(defn sorted-set-by\n  \"Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.\"\n  {:added \"1.1\"\n   :static true} \n  ([comparator & keys]\n   (clojure.lang.PersistentTreeSet/create comparator keys)))", :spec nil, :examples []} {:sym sorted?, :meta {:arglists ([coll]), :doc "Returns true if coll implements Sorted"}, :source "(defn sorted?\n \"Returns true if coll implements Sorted\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Sorted coll))", :spec nil, :examples []} {:sym special-symbol?, :meta {:arglists ([s]), :doc "Returns true if s names a special form"}, :source "(defn special-symbol?\n  \"Returns true if s names a special form\"\n  {:added \"1.0\"\n   :static true}\n  [s]\n    (contains? (. clojure.lang.Compiler specials) s))", :spec nil, :examples []} {:sym spit, :meta {:arglists ([f content & options]), :doc "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer."}, :source "(defn spit\n  \"Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.\"\n  {:added \"1.2\"}\n  [f content & options]\n  (with-open [^java.io.Writer w (apply jio/writer f options)]\n    (.write w (str content))))", :spec nil, :examples []} {:sym split-at, :meta {:arglists ([n coll]), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :source "(defn split-at\n  \"Returns a vector of [(take n coll) (drop n coll)]\"\n  {:added \"1.0\"\n   :static true}\n  [n coll]\n    [(take n coll) (drop n coll)])", :spec nil, :examples []} {:sym split-with, :meta {:arglists ([pred coll]), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :source "(defn split-with\n  \"Returns a vector of [(take-while pred coll) (drop-while pred coll)]\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n    [(take-while pred coll) (drop-while pred coll)])", :spec nil, :examples []} {:sym str, :meta {:arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, :source "(defn str\n  \"With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  (^String [] \"\")\n  (^String [^Object x]\n   (if (nil? x) \"\" (. x (toString))))\n  (^String [x & ys]\n     ((fn [^StringBuilder sb more]\n          (if more\n            (recur (. sb  (append (str (first more)))) (next more))\n            (str sb)))\n      (new StringBuilder (str x)) ys)))", :spec nil, :examples []} {:sym string?, :meta {:arglists ([x]), :doc "Return true if x is a String"}, :source "(def\n ^{:arglists '([x])\n   :doc \"Return true if x is a String\"\n   :added \"1.0\"\n   :static true}\n string? (fn ^:static string? [x] (instance? String x)))", :spec nil, :examples []} {:sym struct, :meta {:arglists ([s & vals]), :doc "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil."}, :source "(defn struct\n  \"Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.\"\n  {:added \"1.0\"\n   :static true}\n  [s & vals]\n    (. clojure.lang.PersistentStructMap (construct s vals)))", :spec nil, :examples []} {:sym struct-map, :meta {:arglists ([s & inits]), :doc "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis."}, :source "(defn struct-map\n  \"Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.\"\n  {:added \"1.0\"\n   :static true}\n  [s & inits]\n    (. clojure.lang.PersistentStructMap (create s inits)))", :spec nil, :examples []} {:sym subs, :meta {:arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, :source "(defn subs\n  \"Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.\"\n  {:added \"1.0\"\n   :static true}\n  (^String [^String s start] (. s (substring start)))\n  (^String [^String s start end] (. s (substring start end))))", :spec nil, :examples []} {:sym subseq, :meta {:arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, :source "(defn subseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.Sorted sc test key]\n   (let [include (mk-bound-fn sc test key)]\n     (if (#{> >=} test)\n       (when-let [[e :as s] (. sc seqFrom key true)]\n         (if (include e) s (next s)))\n       (take-while include (. sc seq true)))))\n  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]\n   (when-let [[e :as s] (. sc seqFrom start-key true)]\n     (take-while (mk-bound-fn sc end-test end-key)\n                 (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))", :spec nil, :examples []} {:sym subvec, :meta {:arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, :source "(defn subvec\n  \"Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.\"\n  {:added \"1.0\"\n   :static true}\n  ([v start]\n   (subvec v start (count v)))\n  ([v start end]\n   (. clojure.lang.RT (subvec v start end))))", :spec nil, :examples []} {:sym supers, :meta {:arglists ([class]), :doc "Returns the immediate and indirect superclasses and interfaces of c, if any"}, :source "(defn supers\n  \"Returns the immediate and indirect superclasses and interfaces of c, if any\"\n  {:added \"1.0\"\n   :static true}\n  [^Class class]\n  (loop [ret (set (bases class)) cs ret]\n    (if (seq cs)\n      (let [c (first cs) bs (bases c)]\n        (recur (into1 ret bs) (into1 (disj cs c) bs)))\n      (not-empty ret))))", :spec nil, :examples []} {:sym swap!, :meta {:arglists ([atom f] [atom f x] [atom f x y] [atom f x y & args]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, :source "(defn swap!\n  \"Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.IAtom atom f] (.swap atom f))\n  ([^clojure.lang.IAtom atom f x] (.swap atom f x))\n  ([^clojure.lang.IAtom atom f x y] (.swap atom f x y))\n  ([^clojure.lang.IAtom atom f x y & args] (.swap atom f x y args)))", :spec nil, :examples []} {:sym swap-vals!, :meta {:arglists ([atom f] [atom f x] [atom f x y] [atom f x y & args]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap."}, :source "(defn swap-vals!\n  \"Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.\"\n  {:added \"1.9\"}\n  (^clojure.lang.IPersistentVector [^clojure.lang.IAtom2 atom f] (.swapVals atom f))\n  (^clojure.lang.IPersistentVector [^clojure.lang.IAtom2 atom f x] (.swapVals atom f x))\n  (^clojure.lang.IPersistentVector [^clojure.lang.IAtom2 atom f x y] (.swapVals atom f x y))\n  (^clojure.lang.IPersistentVector [^clojure.lang.IAtom2 atom f x y & args] (.swapVals atom f x y args)))", :spec nil, :examples []} {:sym symbol, :meta {:arglists ([name] [ns name]), :doc "Returns a Symbol with the given namespace and name."}, :source "(defn symbol\n  \"Returns a Symbol with the given namespace and name.\"\n  {:tag clojure.lang.Symbol\n   :added \"1.0\"\n   :static true}\n  ([name] (if (symbol? name) name (clojure.lang.Symbol/intern name)))\n  ([ns name] (clojure.lang.Symbol/intern ns name)))", :spec nil, :examples []} {:sym symbol?, :meta {:arglists ([x]), :doc "Return true if x is a Symbol"}, :source "(defn symbol?\n  \"Return true if x is a Symbol\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Symbol x))", :spec nil, :examples []} {:sym sync, :meta {:arglists ([flags-ignored-for-now & body]), :doc "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic."}, :source "(defmacro sync\n  \"transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.\"\n  {:added \"1.0\"}\n  [flags-ignored-for-now & body]\n  `(. clojure.lang.LockingTransaction\n      (runInTransaction (fn [] ~@body))))", :spec nil, :examples []} {:sym tagged-literal, :meta {:arglists ([tag form]), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :source "(defn tagged-literal\n  \"Construct a data representation of a tagged literal from a\n  tag symbol and a form.\"\n  {:added \"1.7\"}\n  [^clojure.lang.Symbol tag form]\n  (clojure.lang.TaggedLiteral/create tag form))", :spec nil, :examples []} {:sym tagged-literal?, :meta {:arglists ([value]), :doc "Return true if the value is the data representation of a tagged literal"}, :source "(defn tagged-literal?\n  \"Return true if the value is the data representation of a tagged literal\"\n  {:added \"1.7\"}\n  [value]\n  (instance? clojure.lang.TaggedLiteral value))", :spec nil, :examples []} {:sym take, :meta {:arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, :source "(defn take\n  \"Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([n]\n     (fn [rf]\n       (let [nv (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @nv\n                    nn (vswap! nv dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n      (when (pos? n) \n        (when-let [s (seq coll)]\n          (cons (first s) (take (dec n) (rest s))))))))", :spec nil, :examples []} {:sym take-last, :meta {:arglists ([n coll]), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :source "(defn take-last\n  \"Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n  {:added \"1.1\"\n   :static true}\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))", :spec nil, :examples []} {:sym take-nth, :meta {:arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, :source "(defn take-nth\n  \"Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([n]\n     (fn [rf]\n       (let [iv (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! iv inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (first s) (take-nth n (drop n s)))))))", :spec nil, :examples []} {:sym take-while, :meta {:arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, :source "(defn take-while\n  \"Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  {:added \"1.0\"\n   :static true}\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (when (pred (first s))\n          (cons (first s) (take-while pred (rest s))))))))", :spec nil, :examples []} {:sym test, :meta {:arglists ([v]), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :source "(defn test\n  \"test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception\"\n  {:added \"1.0\"}\n  [v]\n    (let [f (:test (meta v))]\n      (if f\n        (do (f) :ok)\n        :no-test)))", :spec nil, :examples []} {:sym the-ns, :meta {:arglists ([x]), :doc "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found."}, :source "(defn the-ns\n  \"If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.\"\n  {:added \"1.0\"\n   :static true}\n  ^clojure.lang.Namespace [x]\n  (if (instance? clojure.lang.Namespace x)\n    x\n    (or (find-ns x) (throw (Exception. (str \"No namespace: \" x \" found\"))))))", :spec nil, :examples []} {:sym thread-bound?, :meta {:arglists ([& vars]), :doc "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided."}, :source "(defn thread-bound?\n  \"Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.\"\n  {:added \"1.2\"\n   :static true}\n  [& vars]\n  (every? #(.getThreadBinding ^clojure.lang.Var %) vars))", :spec nil, :examples []} {:sym time, :meta {:arglists ([expr]), :doc "Evaluates expr and prints the time it took.  Returns the value of\n expr."}, :source "(defmacro time\n  \"Evaluates expr and prints the time it took.  Returns the value of\n expr.\"\n  {:added \"1.0\"}\n  [expr]\n  `(let [start# (. System (nanoTime))\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (/ (double (- (. System (nanoTime)) start#)) 1000000.0) \" msecs\"))\n     ret#))", :spec nil, :examples []} {:sym to-array, :meta {:arglists ([coll]), :doc "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray()."}, :source "(defn to-array\n  \"Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().\"\n  {:tag \"[Ljava.lang.Object;\"\n   :added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (toArray coll)))", :spec nil, :examples []} {:sym to-array-2d, :meta {:arglists ([coll]), :doc "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection."}, :source "(defn to-array-2d\n  \"Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.\"\n  {:tag \"[[Ljava.lang.Object;\"\n   :added \"1.0\"\n   :static true}\n  [^java.util.Collection coll]\n    (let [ret (make-array (. Class (forName \"[Ljava.lang.Object;\")) (. coll (size)))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))", :spec nil, :examples []} {:sym trampoline, :meta {:arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, :source "(defn trampoline\n  \"trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.\"\n  {:added \"1.0\"\n   :static true}\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))", :spec nil, :examples []} {:sym transduce, :meta {:arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, :source "(defn transduce\n  \"reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.\"  {:added \"1.7\"}\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (if (instance? clojure.lang.IReduceInit coll)\n                 (.reduce ^clojure.lang.IReduceInit coll f init)\n                 (clojure.core.protocols/coll-reduce coll f init))]\n       (f ret))))", :spec nil, :examples []} {:sym transient, :meta {:arglists ([coll]), :doc "Returns a new, transient version of the collection, in constant time."}, :source "(defn transient \n  \"Returns a new, transient version of the collection, in constant time.\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.IEditableCollection coll] \n  (.asTransient coll))", :spec nil, :examples []} {:sym tree-seq, :meta {:arglists ([branch? children root]), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, :source "(defn tree-seq\n  \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.\"\n  {:added \"1.0\"\n   :static true}\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))", :spec nil, :examples []} {:sym true?, :meta {:arglists ([x]), :doc "Returns true if x is the value true, false otherwise."}, :source "(defn true?\n  \"Returns true if x is the value true, false otherwise.\"\n  {:tag Boolean,\n   :added \"1.0\"\n   :static true}\n  [x] (clojure.lang.Util/identical x true))", :spec nil, :examples []} {:sym type, :meta {:arglists ([x]), :doc "Returns the :type metadata of x, or its Class if none"}, :source "(defn type \n  \"Returns the :type metadata of x, or its Class if none\"\n  {:added \"1.0\"\n   :static true}\n  [x]\n  (or (get (meta x) :type) (class x)))", :spec nil, :examples []} {:sym unchecked-add, :meta {:arglists ([x y]), :doc "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-add\n  \"Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_add ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_add x y)))", :spec nil, :examples []} {:sym unchecked-add-int, :meta {:arglists ([x y]), :doc "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-add-int\n  \"Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_add ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_add x y)))", :spec nil, :examples []} {:sym unchecked-byte, :meta {:arglists ([x]), :doc "Coerce to byte. Subject to rounding or truncation."}, :source "(defn unchecked-byte\n  \"Coerce to byte. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedByteCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedByteCast x))", :spec nil, :examples []} {:sym unchecked-char, :meta {:arglists ([x]), :doc "Coerce to char. Subject to rounding or truncation."}, :source "(defn unchecked-char\n  \"Coerce to char. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedCharCast ~x)))\n   :added \"1.3\"}\n  [x] (. clojure.lang.RT (uncheckedCharCast x)))", :spec nil, :examples []} {:sym unchecked-dec, :meta {:arglists ([x]), :doc "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-dec\n  \"Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_dec ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_dec x)))", :spec nil, :examples []} {:sym unchecked-dec-int, :meta {:arglists ([x]), :doc "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-dec-int\n  \"Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_dec ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_dec x)))", :spec nil, :examples []} {:sym unchecked-divide-int, :meta {:arglists ([x y]), :doc "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation."}, :source "(defn unchecked-divide-int\n  \"Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_divide ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_divide x y)))", :spec nil, :examples []} {:sym unchecked-double, :meta {:arglists ([x]), :doc "Coerce to double. Subject to rounding."}, :source "(defn unchecked-double\n  \"Coerce to double. Subject to rounding.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedDoubleCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedDoubleCast x))", :spec nil, :examples []} {:sym unchecked-float, :meta {:arglists ([x]), :doc "Coerce to float. Subject to rounding."}, :source "(defn unchecked-float\n  \"Coerce to float. Subject to rounding.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedFloatCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedFloatCast x))", :spec nil, :examples []} {:sym unchecked-inc, :meta {:arglists ([x]), :doc "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-inc\n  \"Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_inc ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_inc x)))", :spec nil, :examples []} {:sym unchecked-inc-int, :meta {:arglists ([x]), :doc "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-inc-int\n  \"Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_inc ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_inc x)))", :spec nil, :examples []} {:sym unchecked-int, :meta {:arglists ([x]), :doc "Coerce to int. Subject to rounding or truncation."}, :source "(defn unchecked-int\n  \"Coerce to int. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedIntCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedIntCast x))", :spec nil, :examples []} {:sym unchecked-long, :meta {:arglists ([x]), :doc "Coerce to long. Subject to rounding or truncation."}, :source "(defn unchecked-long\n  \"Coerce to long. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedLongCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedLongCast x))", :spec nil, :examples []} {:sym unchecked-multiply, :meta {:arglists ([x y]), :doc "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-multiply\n  \"Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_multiply ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_multiply x y)))", :spec nil, :examples []} {:sym unchecked-multiply-int, :meta {:arglists ([x y]), :doc "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-multiply-int\n  \"Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_multiply ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_multiply x y)))", :spec nil, :examples []} {:sym unchecked-negate, :meta {:arglists ([x]), :doc "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-negate\n  \"Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_minus ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_minus x)))", :spec nil, :examples []} {:sym unchecked-negate-int, :meta {:arglists ([x]), :doc "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-negate-int\n  \"Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_negate ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_negate x)))", :spec nil, :examples []} {:sym unchecked-remainder-int, :meta {:arglists ([x y]), :doc "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation."}, :source "(defn unchecked-remainder-int\n  \"Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_remainder ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_remainder x y)))", :spec nil, :examples []} {:sym unchecked-short, :meta {:arglists ([x]), :doc "Coerce to short. Subject to rounding or truncation."}, :source "(defn unchecked-short\n  \"Coerce to short. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedShortCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedShortCast x))", :spec nil, :examples []} {:sym unchecked-subtract, :meta {:arglists ([x y]), :doc "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-subtract\n  \"Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_minus ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_minus x y)))", :spec nil, :examples []} {:sym unchecked-subtract-int, :meta {:arglists ([x y]), :doc "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow."}, :source "(defn unchecked-subtract-int\n  \"Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_subtract ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_subtract x y)))", :spec nil, :examples []} {:sym underive, :meta {:arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, :source "(defn underive\n  \"Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  {:added \"1.0\"}\n  ([tag parent] (alter-var-root #'global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n\t  childsParents (if (parentMap tag)\n\t\t\t  (disj (parentMap tag) parent) #{})\n\t  newParents (if (not-empty childsParents)\n\t\t       (assoc parentMap tag childsParents)\n\t\t       (dissoc parentMap tag))\n\t  deriv-seq (flatten (map #(cons (key %) (interpose (key %) (val %)))\n\t\t\t\t       (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n\t(reduce1 #(apply derive %1 %2) (make-hierarchy)\n\t\t(partition 2 deriv-seq))\n\th))))", :spec nil, :examples []} {:sym unquote, :meta {}, :source "(def unquote)", :spec nil, :examples []} {:sym unquote-splicing, :meta {}, :source "(def unquote-splicing)", :spec nil, :examples []} {:sym unreduced, :meta {:arglists ([x]), :doc "If x is reduced?, returns (deref x), else returns x"}, :source "(defn unreduced\n  \"If x is reduced?, returns (deref x), else returns x\"\n  {:added \"1.7\"}\n  [x]\n  (if (reduced? x) (deref x) x))", :spec nil, :examples []} {:sym unsigned-bit-shift-right, :meta {:arglists ([x n]), :doc "Bitwise shift right, without sign-extension."}, :source "(defn unsigned-bit-shift-right\n  \"Bitwise shift right, without sign-extension.\"\n  {:inline (fn [x n] `(. clojure.lang.Numbers (unsignedShiftRight ~x ~n)))\n   :added \"1.6\"}\n  [x n] (. clojure.lang.Numbers unsignedShiftRight x n))", :spec nil, :examples []} {:sym update, :meta {:arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, :source "(defn update\n  \"'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.\"\n  {:added \"1.7\"\n   :static true}\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))", :spec nil, :examples []} {:sym update-in, :meta {:arglists ([m ks f & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, :source "(defn update-in\n  \"'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.\"\n  {:added \"1.0\"\n   :static true}\n  ([m ks f & args]\n     (let [up (fn up [m ks f args]\n                (let [[k & ks] ks]\n                  (if ks\n                    (assoc m k (up (get m k) ks f args))\n                    (assoc m k (apply f (get m k) args)))))]\n       (up m ks f args))))", :spec nil, :examples []} {:sym update-proxy, :meta {:arglists ([proxy mappings]), :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy."}, :source "(defn update-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__updateClojureFnMappings mappings))\n    proxy)", :spec nil, :examples []} {:sym uri?, :meta {:arglists ([x]), :doc "Return true if x is a java.net.URI"}, :source "(defn uri?\n  \"Return true if x is a java.net.URI\"\n  {:added \"1.9\"}\n  [x] (instance? java.net.URI x))", :spec nil, :examples []} {:sym use, :meta {:arglists ([& args]), :doc "Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer."}, :source "(defn use\n  \"Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.\"\n  {:added \"1.0\"}\n  [& args] (apply load-libs :require :use args))", :spec nil, :examples []} {:sym uuid?, :meta {:arglists ([x]), :doc "Return true if x is a java.util.UUID"}, :source "(defn uuid?\n  \"Return true if x is a java.util.UUID\"\n  {:added \"1.9\"}\n  [x] (instance? java.util.UUID x))", :spec nil, :examples []} {:sym val, :meta {:arglists ([e]), :doc "Returns the value in the map entry."}, :source "(defn val\n  \"Returns the value in the map entry.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.Map$Entry e]\n    (. e (getValue)))", :spec nil, :examples []} {:sym vals, :meta {:arglists ([map]), :doc "Returns a sequence of the map's values, in the same order as (seq map)."}, :source "(defn vals\n  \"Returns a sequence of the map's values, in the same order as (seq map).\"\n  {:added \"1.0\"\n   :static true}\n  [map] (. clojure.lang.RT (vals map)))", :spec nil, :examples []} {:sym var-get, :meta {:arglists ([x]), :doc "Gets the value in the var object"}, :source "(defn var-get\n  \"Gets the value in the var object\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var x] (. x (get)))", :spec nil, :examples []} {:sym var-set, :meta {:arglists ([x val]), :doc "Sets the value in the var object to val. The var must be\n thread-locally bound."}, :source "(defn var-set\n  \"Sets the value in the var object to val. The var must be\n thread-locally bound.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var x val] (. x (set val)))", :spec nil, :examples []} {:sym var?, :meta {:arglists ([v]), :doc "Returns true if v is of type clojure.lang.Var"}, :source "(defn var?\n  \"Returns true if v is of type clojure.lang.Var\"\n  {:added \"1.0\"\n   :static true}\n  [v] (instance? clojure.lang.Var v))", :spec nil, :examples []} {:sym vary-meta, :meta {:arglists ([obj f & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, :source "(defn vary-meta\n \"Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.\"\n {:added \"1.0\"\n   :static true}\n [obj f & args]\n  (with-meta obj (apply f (meta obj) args)))", :spec nil, :examples []} {:sym vec, :meta {:arglists ([coll]), :doc "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified."}, :source "(defn vec\n  \"Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (if (vector? coll)\n     (if (instance? clojure.lang.IObj coll)\n       (with-meta coll nil)\n       (clojure.lang.LazilyPersistentVector/create coll))\n     (clojure.lang.LazilyPersistentVector/create coll))))", :spec nil, :examples []} {:sym vector, :meta {:arglists ([] [a] [a b] [a b c] [a b c d] [a b c d e] [a b c d e f] [a b c d e f & args]), :doc "Creates a new vector containing the args."}, :source "(defn vector\n  \"Creates a new vector containing the args.\"\n  {:added \"1.0\"\n   :static true}\n  ([] [])\n  ([a] [a])\n  ([a b] [a b])\n  ([a b c] [a b c])\n  ([a b c d] [a b c d])\n\t([a b c d e] [a b c d e])\n\t([a b c d e f] [a b c d e f])\n  ([a b c d e f & args]\n     (. clojure.lang.LazilyPersistentVector (create (cons a (cons b (cons c (cons d (cons e (cons f args))))))))))", :spec nil, :examples []} {:sym vector-of, :meta {:arglists ([t] [t & elements]), :doc "Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector."}, :source "(defn vector-of\n  \"Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.\"\n  {:added \"1.2\"\n   :arglists '([t] [t & elements])}\n  ([t]\n   (let [^clojure.core.ArrayManager am (ams-check t)]\n     (Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))\n  ([t x1]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 1)]\n     (.aset am arr 0 x1)\n     (Vec. am 1 5 EMPTY-NODE arr nil)))\n  ([t x1 x2]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 2)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (Vec. am 2 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 3)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (Vec. am 3 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 4)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (.aset am arr 3 x4)\n     (Vec. am 4 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4 & xn]\n   (loop [v  (vector-of t x1 x2 x3 x4)\n          xn xn]\n     (if xn\n       (recur (conj v (first xn)) (next xn))\n       v))))", :spec nil, :examples []} {:sym vector?, :meta {:arglists ([x]), :doc "Return true if x implements IPersistentVector"}, :source "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements IPersistentVector\"\n   :added \"1.0\"\n   :static true}\n vector? (fn ^:static vector? [x] (instance? clojure.lang.IPersistentVector x)))", :spec nil, :examples []} {:sym volatile!, :meta {:arglists ([val]), :doc "Creates and returns a Volatile with an initial value of val."}, :source "(defn volatile!\n  \"Creates and returns a Volatile with an initial value of val.\"\n  {:added \"1.7\"\n   :tag clojure.lang.Volatile}\n  [val]\n  (clojure.lang.Volatile. val))", :spec nil, :examples []} {:sym volatile?, :meta {:arglists ([x]), :doc "Returns true if x is a volatile."}, :source "(defn volatile?\n  \"Returns true if x is a volatile.\"\n  {:added \"1.7\"}\n  [x]\n  (instance? clojure.lang.Volatile x))", :spec nil, :examples []} {:sym vreset!, :meta {:arglists ([vol newval]), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :source "(defn vreset!\n  \"Sets the value of volatile to newval without regard for the\n   current value. Returns newval.\"\n  {:added \"1.7\"}\n  [^clojure.lang.Volatile vol newval]\n  (.reset vol newval))", :spec nil, :examples []} {:sym vswap!, :meta {:arglists ([vol f & args]), :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in."}, :source "(defmacro vswap!\n  \"Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.\"\n  {:added \"1.7\"}\n  [vol f & args]\n  (let [v (with-meta vol {:tag 'clojure.lang.Volatile})]\n    `(.reset ~v (~f (.deref ~v) ~@args))))", :spec nil, :examples []} {:sym when, :meta {:arglists ([test & body]), :doc "Evaluates test. If logical true, evaluates body in an implicit do."}, :source "(defmacro when\n  \"Evaluates test. If logical true, evaluates body in an implicit do.\"\n  {:added \"1.0\"}\n  [test & body]\n  (list 'if test (cons 'do body)))", :spec nil, :examples []} {:sym when-first, :meta {:arglists ([bindings & body]), :doc "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"}, :source "(defmacro when-first\n  \"bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))", :spec nil, :examples []} {:sym when-let, :meta {:arglists ([bindings & body]), :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test"}, :source "(defmacro when-let\n  \"bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))", :spec "(clojure.spec.alpha/fspec\n :args\n (clojure.spec.alpha/cat\n  :bindings\n  (clojure.spec.alpha/and\n   clojure.core/vector?\n   :clojure.core.specs.alpha/binding)\n  :body\n  (clojure.spec.alpha/* clojure.core/any?))\n :ret\n clojure.core/any?\n :fn\n nil)\n", :examples []} {:sym when-not, :meta {:arglists ([test & body]), :doc "Evaluates test. If logical false, evaluates body in an implicit do."}, :source "(defmacro when-not\n  \"Evaluates test. If logical false, evaluates body in an implicit do.\"\n  {:added \"1.0\"}\n  [test & body]\n    (list 'if test nil (cons 'do body)))", :spec nil, :examples []} {:sym when-some, :meta {:arglists ([bindings & body]), :doc "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test"}, :source "(defmacro when-some\n  \"bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test\"\n  {:added \"1.6\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (if (nil? temp#)\n         nil\n         (let [~form temp#]\n           ~@body)))))", :spec nil, :examples []} {:sym while, :meta {:arglists ([test & body]), :doc "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil"}, :source "(defmacro while\n  \"Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil\"\n  {:added \"1.0\"}\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))", :spec nil, :examples []} {:sym with-bindings, :meta {:arglists ([binding-map & body]), :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body."}, :source "(defmacro with-bindings\n  \"Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.\"\n  {:added \"1.1\"}\n  [binding-map & body]\n  `(with-bindings* ~binding-map (fn [] ~@body)))", :spec nil, :examples []} {:sym with-bindings*, :meta {:arglists ([binding-map f & args]), :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns."}, :source "(defn with-bindings*\n  \"Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.\"\n  {:added \"1.1\"\n   :static true}\n  [binding-map f & args]\n  (push-thread-bindings binding-map)\n  (try\n    (apply f args)\n    (finally\n      (pop-thread-bindings))))", :spec nil, :examples []} {:sym with-in-str, :meta {:arglists ([s & body]), :doc "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s."}, :source "(defmacro with-in-str\n  \"Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n  {:added \"1.0\"}\n  [s & body]\n  `(with-open [s# (-> (java.io.StringReader. ~s) clojure.lang.LineNumberingPushbackReader.)]\n     (binding [*in* s#]\n       ~@body)))", :spec nil, :examples []} {:sym with-loading-context, :meta {:arglists ([& body])}, :source "(defmacro with-loading-context [& body]\n  `((fn loading# [] \n        (. clojure.lang.Var (pushThreadBindings {clojure.lang.Compiler/LOADER  \n                                                 (.getClassLoader (.getClass ^Object loading#))}))\n        (try\n         ~@body\n         (finally\n          (. clojure.lang.Var (popThreadBindings)))))))", :spec nil, :examples []} {:sym with-local-vars, :meta {:arglists ([name-vals-vec & body]), :doc "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set"}, :source "(defmacro with-local-vars\n  \"varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set\"\n  {:added \"1.0\"}\n  [name-vals-vec & body]\n  (assert-args\n     (vector? name-vals-vec) \"a vector for its binding\"\n     (even? (count name-vals-vec)) \"an even number of forms in binding vector\")\n  `(let [~@(interleave (take-nth 2 name-vals-vec)\n                       (repeat '(.. clojure.lang.Var create setDynamic)))]\n     (. clojure.lang.Var (pushThreadBindings (hash-map ~@name-vals-vec)))\n     (try\n      ~@body\n      (finally (. clojure.lang.Var (popThreadBindings))))))", :spec nil, :examples []} {:sym with-meta, :meta {:arglists ([obj m]), :doc "Returns an object of the same type and value as obj, with\n    map m as its metadata."}, :source "(def\n ^{:arglists '([^clojure.lang.IObj obj m])\n   :doc \"Returns an object of the same type and value as obj, with\n    map m as its metadata.\"\n   :added \"1.0\"\n   :static true}\n with-meta (fn ^:static with-meta [^clojure.lang.IObj x m]\n             (. x (withMeta m))))", :spec nil, :examples []} {:sym with-open, :meta {:arglists ([bindings & body]), :doc "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order."}, :source "(defmacro with-open\n  \"bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  (cond\n    (= (count bindings) 0) `(do ~@body)\n    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)\n                              (try\n                                (with-open ~(subvec bindings 2) ~@body)\n                                (finally\n                                  (. ~(bindings 0) close))))\n    :else (throw (IllegalArgumentException.\n                   \"with-open only allows Symbols in bindings\"))))", :spec nil, :examples []} {:sym with-out-str, :meta {:arglists ([& body]), :doc "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls."}, :source "(defmacro with-out-str\n  \"Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n  {:added \"1.0\"}\n  [& body]\n  `(let [s# (new java.io.StringWriter)]\n     (binding [*out* s#]\n       ~@body\n       (str s#))))", :spec nil, :examples []} {:sym with-precision, :meta {:arglists ([precision & exprs]), :doc "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP."}, :source "(defmacro with-precision\n  \"Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.\"\n  {:added \"1.0\"}\n  [precision & exprs]\n    (let [[body rm] (if (= (first exprs) :rounding)\n                      [(next (next exprs))\n                       `((. java.math.RoundingMode ~(second exprs)))]\n                      [exprs nil])]\n      `(binding [*math-context* (java.math.MathContext. ~precision ~@rm)]\n         ~@body)))", :spec nil, :examples []} {:sym with-redefs, :meta {:arglists ([bindings & body]), :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing."}, :source "(defmacro with-redefs\n  \"binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.\"\n  {:added \"1.3\"}\n  [bindings & body]\n  `(with-redefs-fn ~(zipmap (map #(list `var %) (take-nth 2 bindings))\n                            (take-nth 2 (next bindings)))\n                    (fn [] ~@body)))", :spec nil, :examples []} {:sym with-redefs-fn, :meta {:arglists ([binding-map func]), :doc "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing."}, :source "(defn with-redefs-fn\n  \"Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.\"\n  {:added \"1.3\"}\n  [binding-map func]\n  (let [root-bind (fn [m]\n                    (doseq [[a-var a-val] m]\n                      (.bindRoot ^clojure.lang.Var a-var a-val)))\n        old-vals (zipmap (keys binding-map)\n                         (map #(.getRawRoot ^clojure.lang.Var %) (keys binding-map)))]\n    (try\n      (root-bind binding-map)\n      (func)\n      (finally\n        (root-bind old-vals)))))", :spec nil, :examples []} {:sym xml-seq, :meta {:arglists ([root]), :doc "A tree seq on the xml elements as per xml/parse"}, :source "(defn xml-seq\n  \"A tree seq on the xml elements as per xml/parse\"\n  {:added \"1.0\"\n   :static true}\n  [root]\n    (tree-seq\n     (complement string?)\n     (comp seq :content)\n     root))", :spec nil, :examples []} {:sym zero?, :meta {:arglists ([num]), :doc "Returns true if num is zero, else false"}, :source "(defn zero?\n  \"Returns true if num is zero, else false\"\n  {\n   :inline (fn [num] `(. clojure.lang.Numbers (isZero ~num)))\n   :added \"1.0\"}\n  [num] (. clojure.lang.Numbers (isZero num)))", :spec nil, :examples []} {:sym zipmap, :meta {:arglists ([keys vals]), :doc "Returns a map with the keys mapped to the corresponding vals."}, :source "(defn zipmap\n  \"Returns a map with the keys mapped to the corresponding vals.\"\n  {:added \"1.0\"\n   :static true}\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))", :spec nil, :examples []}], :rel-path "../"}</script>
        <script type="text/javascript" src="../main.js"></script>
    </body>
</html>
